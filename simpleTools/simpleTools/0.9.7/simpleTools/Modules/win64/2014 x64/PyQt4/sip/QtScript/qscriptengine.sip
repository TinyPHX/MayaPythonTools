// qscriptengine.sip generated by MetaSIP on Fri Mar  1 21:46:02 2013
//
// This file is part of the QtScript Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// If you are unsure which license is appropriate for your use, please
// contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%If (Qt_4_3_0 -)
%ModuleCode
#include <qscriptengine.h>
%End
%End

%If (Qt_4_3_0 -)

class QScriptEngine : QObject
{
%TypeHeaderCode
#include <qscriptengine.h>
%End

%TypeCode
#if QT_VERSION >= 0x040400

// Save a Python callable in a QScriptValue so that it can be retrieved later
// by the handler.
static void qtscript_func_wrapper(QScriptEngine *eng, QScriptValue *qsv, PyObject *py)
{
    QString addr = QString::number((qulonglong)py);
    qsv->setData(QScriptValue(eng, addr));

    // Make sure that the callable isn't garbage collected.  This shouldn't be
    // a problem as we wouldn't normally be called in a loop.
    Py_INCREF(py);
}


// Invoke the saved Python callable on behalf of C++.
static QScriptValue qtscript_func_handler(QScriptContext *context, QScriptEngine *eng)
{
    QScriptValue qsv;

    QString addr = context->callee().data().toString();
    PyObject *py = (PyObject *)addr.toULongLong();

    SIP_BLOCK_THREADS

    PyObject *res_obj = sipCallMethod(0, py, "DD", context, sipType_QScriptContext, NULL, eng, sipType_QScriptEngine, NULL);

    if (!res_obj)
        PyErr_Print();
    else
    {
        QScriptValue *res;

        if (sipParseResult(0, py, res_obj, "D5", sipType_QScriptValue, &res) < 0)
            PyErr_Print();
        else
            qsv = *res;
    }

    Py_XDECREF(res_obj);

    SIP_UNBLOCK_THREADS

    return qsv;
}

#endif
%End

%ConvertToSubClassCode
    sipType = (sipCpp->inherits(sipName_QScriptEngine) ? sipType_QScriptEngine : 0);
%End

public:
    enum ValueOwnership
    {
        QtOwnership,
        ScriptOwnership,
        AutoOwnership,
    };

    enum QObjectWrapOption
    {
        ExcludeChildObjects,
        ExcludeSuperClassMethods,
        ExcludeSuperClassProperties,
        AutoCreateDynamicProperties,
%If (Qt_4_4_0 -)
        SkipMethodsInEnumeration,
%End
%If (Qt_4_4_0 -)
        PreferExistingWrapperObject,
%End
%If (Qt_4_5_0 -)
        ExcludeSuperClassContents,
%End
%If (Qt_4_5_0 -)
        ExcludeDeleteLater,
%End
%If (Qt_4_7_0 -)
        ExcludeSlots,
%End
    };

    typedef QFlags<QScriptEngine::QObjectWrapOption> QObjectWrapOptions;
    QScriptEngine();
    explicit QScriptEngine(QObject *parent /TransferThis/);
    virtual ~QScriptEngine();
    QScriptValue globalObject() const;
    QScriptContext *currentContext() const;
    QScriptContext *pushContext();
    void popContext();
    bool canEvaluate(const QString &program) const;
    QScriptValue evaluate(const QString &program, const QString &fileName /DocValue="Py_v3:''"/ = QString(), int lineNumber = 1);
    bool hasUncaughtException() const;
    QStringList uncaughtExceptionBacktrace() const;
    QScriptValue uncaughtException() const;
    int uncaughtExceptionLineNumber() const;
    QScriptValue nullValue();
    QScriptValue undefinedValue();
%If (Qt_4_4_0 -)
    QScriptValue newFunction(SIP_PYCALLABLE signature, int length = 0);
%MethodCode
        // This is implemented for Qt v4.4 and later because we rely on the
        // QScriptValue::setData() support.
        
        Py_BEGIN_ALLOW_THREADS
        sipRes = new QScriptValue(sipCpp->newFunction(qtscript_func_handler, a1));
        Py_END_ALLOW_THREADS
        
        qtscript_func_wrapper(sipCpp, sipRes, a0);
%End

%End
%If (Qt_4_4_0 -)
    QScriptValue newFunction(SIP_PYCALLABLE signature, const QScriptValue &prototype, int length = 0);
%MethodCode
        // This is implemented for Qt v4.4 and later because we rely on the
        // QScriptValue::setData() support.
        
        Py_BEGIN_ALLOW_THREADS
        sipRes = new QScriptValue(sipCpp->newFunction(qtscript_func_handler, *a1, a2));
        Py_END_ALLOW_THREADS
        
        qtscript_func_wrapper(sipCpp, sipRes, a0);
%End

%End
    QScriptValue newVariant(const QVariant &value);
%If (Qt_4_4_0 -)
    QScriptValue newVariant(const QScriptValue &object, const QVariant &value);
%End
    QScriptValue newRegExp(const QRegExp &regexp);
    QScriptValue newObject();
%If (Qt_4_4_0 -)
    QScriptValue newObject(QScriptClass *scriptClass, const QScriptValue &data = QScriptValue());
%End
    QScriptValue newArray(uint length = 0);
    QScriptValue newRegExp(const QString &pattern, const QString &flags);
    QScriptValue newDate(qsreal value);
    QScriptValue newDate(const QDateTime &value);
    QScriptValue newQObject(QObject *object /GetWrapper/, QScriptEngine::ValueOwnership ownership = QScriptEngine::QtOwnership, const QFlags<QScriptEngine::QObjectWrapOption> &options = 0);
%MethodCode
        // We have to handle the object ownership manually.
        Py_BEGIN_ALLOW_THREADS
        sipRes = new QScriptValue(sipCpp->newQObject(a0, a1, *a2));
        Py_END_ALLOW_THREADS
        
        if (a1 == QScriptEngine::ScriptOwnership || (a1 == QScriptEngine::AutoOwnership && !a0->parent()))
            sipTransferTo(a0Wrapper, sipSelf);
%End

%If (Qt_4_4_0 -)
    QScriptValue newQObject(const QScriptValue &scriptObject, QObject *qtObject /GetWrapper/, QScriptEngine::ValueOwnership ownership = QScriptEngine::QtOwnership, const QFlags<QScriptEngine::QObjectWrapOption> &options = 0);
%MethodCode
        // We have to handle the object ownership manually.
        Py_BEGIN_ALLOW_THREADS
        sipRes = new QScriptValue(sipCpp->newQObject(*a0, a1, a2, *a3));
        Py_END_ALLOW_THREADS
        
        if (a2 == QScriptEngine::ScriptOwnership || (a2 == QScriptEngine::AutoOwnership && !a1->parent()))
            sipTransferTo(a1Wrapper, sipSelf);
%End

%End
    QScriptValue newQMetaObject(const QMetaObject *metaObject, const QScriptValue &ctor = QScriptValue());
    QScriptValue defaultPrototype(int metaTypeId) const;
    void setDefaultPrototype(int metaTypeId, const QScriptValue &prototype);
    QScriptValue importExtension(const QString &extension);
    void collectGarbage();
    void setProcessEventsInterval(int interval);
    int processEventsInterval() const;
%If (Qt_4_4_0 -)
    bool isEvaluating() const;
%End
%If (Qt_4_4_0 -)
    void abortEvaluation(const QScriptValue &result = QScriptValue());
%End
%If (Qt_4_4_0 -)
    void clearExceptions();
%End
%If (Qt_4_4_0 -)
    QStringList availableExtensions() const;
%End
%If (Qt_4_4_0 -)
    QStringList importedExtensions() const;
%End
%If (Qt_4_4_0 -)
    void setAgent(QScriptEngineAgent *agent);
%End
%If (Qt_4_4_0 -)
    QScriptEngineAgent *agent() const;
%End
%If (Qt_4_4_0 -)
    QScriptString toStringHandle(const QString &str);
%End
%If (Qt_4_5_0 -)
    void setGlobalObject(const QScriptValue &object);
%End
%If (Qt_4_5_0 -)
    static QScriptSyntaxCheckResult checkSyntax(const QString &program);
%End
%If (Qt_4_5_0 -)
    void installTranslatorFunctions(const QScriptValue &object = QScriptValue());
%End
%If (Qt_4_5_0 -)
    QScriptValue toObject(const QScriptValue &value);
%End

signals:
%If (Qt_4_4_0 -)
    void signalHandlerException(const QScriptValue &exception);
%End

public:
%If (Qt_4_7_0 -)
    void reportAdditionalMemoryCost(int size);
%End

private:
    QScriptEngine(const QScriptEngine &);
};

%End
%If (Qt_4_3_0 -)
QFlags<QScriptEngine::QObjectWrapOption> operator|(QScriptEngine::QObjectWrapOption f1, QFlags<QScriptEngine::QObjectWrapOption> f2);
%End
%If (Qt_4_4_0 -)
bool qScriptConnect(QObject *sender, SIP_SIGNAL signal, const QScriptValue &receiver, const QScriptValue &function);
%End
%If (Qt_4_4_0 -)
bool qScriptDisconnect(QObject *sender, SIP_SIGNAL signal, const QScriptValue &receiver, const QScriptValue &function);
%End
%If (Qt_4_5_0 -)

class QScriptSyntaxCheckResult
{
%TypeHeaderCode
#include <qscriptengine.h>
%End

public:
    enum State
    {
        Error,
        Intermediate,
        Valid,
    };

    QScriptSyntaxCheckResult(const QScriptSyntaxCheckResult &other);
    ~QScriptSyntaxCheckResult();
    QScriptSyntaxCheckResult::State state() const;
    int errorLineNumber() const;
    int errorColumnNumber() const;
    QString errorMessage() const;

private:
    QScriptSyntaxCheckResult();
};

%End
