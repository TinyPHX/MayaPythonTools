<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html><head><title>QNetworkReply Class Reference</title><style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style></head><body><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr /><td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" width="32" /></td><td width="1">&#160;&#160;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&#160;&#183; <a href="classes.html"><font color="#004faf">All Classes</font></a>&#160;&#183; <a href="modules.html"><font color="#004faf">Modules</font></a></td></table><h1 align="center">QNetworkReply Class Reference<br /><sup><sup>[<a href="qtnetwork.html">QtNetwork</a> module]</sup></sup></h1><p>The QNetworkReply class contains the data and headers for a
request sent with <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> <a href="#details">More...</a></p>

<p>Inherits <a href="qiodevice.html">QIODevice</a>.</p><h3>Types</h3><ul><li><div class="fn" />enum <b><a href="qnetworkreply.html#NetworkError-enum">NetworkError</a></b> { NoError, ConnectionRefusedError, RemoteHostClosedError, HostNotFoundError, ..., TemporaryNetworkFailureError }</li></ul><h3>Methods</h3><ul><li><div class="fn" /><b><a href="qnetworkreply.html#QNetworkReply">__init__</a></b> (<i>self</i>, QObject&#160;<i>parent</i>&#160;=&#160;None)</li><li><div class="fn" /><b><a href="qnetworkreply.html#abort">abort</a></b> (<i>self</i>)</li><li><div class="fn" />QVariant <b><a href="qnetworkreply.html#attribute">attribute</a></b> (<i>self</i>, QNetworkRequest.Attribute&#160;<i>code</i>)</li><li><div class="fn" /><b><a href="qnetworkreply.html#close">close</a></b> (<i>self</i>)</li><li><div class="fn" />NetworkError <b><a href="qnetworkreply.html#error">error</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qnetworkreply.html#hasRawHeader">hasRawHeader</a></b> (<i>self</i>, QByteArray&#160;<i>headerName</i>)</li><li><div class="fn" />QVariant <b><a href="qnetworkreply.html#header">header</a></b> (<i>self</i>, QNetworkRequest.KnownHeaders&#160;<i>header</i>)</li><li><div class="fn" /><b><a href="qnetworkreply.html#ignoreSslErrors">ignoreSslErrors</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qnetworkreply.html#ignoreSslErrors-2">ignoreSslErrors</a></b> (<i>self</i>, list-of-QSslError&#160;<i>errors</i>)</li><li><div class="fn" />bool <b><a href="qnetworkreply.html#isFinished">isFinished</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qnetworkreply.html#isRunning">isRunning</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qnetworkreply.html#isSequential">isSequential</a></b> (<i>self</i>)</li><li><div class="fn" />QNetworkAccessManager <b><a href="qnetworkreply.html#manager">manager</a></b> (<i>self</i>)</li><li><div class="fn" />QNetworkAccessManager.Operation <b><a href="qnetworkreply.html#operation">operation</a></b> (<i>self</i>)</li><li><div class="fn" />QByteArray <b><a href="qnetworkreply.html#rawHeader">rawHeader</a></b> (<i>self</i>, QByteArray&#160;<i>headerName</i>)</li><li><div class="fn" />list-of-QByteArray <b><a href="qnetworkreply.html#rawHeaderList">rawHeaderList</a></b> (<i>self</i>)</li><li><div class="fn" />list-of-tuple-of-QByteArray-QByteArray <b><a href="qnetworkreply.html#rawHeaderPairs">rawHeaderPairs</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qnetworkreply.html#readBufferSize">readBufferSize</a></b> (<i>self</i>)</li><li><div class="fn" />QNetworkRequest <b><a href="qnetworkreply.html#request">request</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qnetworkreply.html#setAttribute">setAttribute</a></b> (<i>self</i>, QNetworkRequest.Attribute&#160;<i>code</i>, QVariant&#160;<i>value</i>)</li><li><div class="fn" /><b><a href="qnetworkreply.html#setError">setError</a></b> (<i>self</i>, NetworkError&#160;<i>errorCode</i>, QString&#160;<i>errorString</i>)</li><li><div class="fn" /><b><a href="qnetworkreply.html#setFinished">setFinished</a></b> (<i>self</i>, bool&#160;<i>finished</i>)</li><li><div class="fn" /><b><a href="qnetworkreply.html#setHeader">setHeader</a></b> (<i>self</i>, QNetworkRequest.KnownHeaders&#160;<i>header</i>, QVariant&#160;<i>value</i>)</li><li><div class="fn" /><b><a href="qnetworkreply.html#setOperation">setOperation</a></b> (<i>self</i>, QNetworkAccessManager.Operation&#160;<i>operation</i>)</li><li><div class="fn" /><b><a href="qnetworkreply.html#setRawHeader">setRawHeader</a></b> (<i>self</i>, QByteArray&#160;<i>headerName</i>, QByteArray&#160;<i>value</i>)</li><li><div class="fn" /><b><a href="qnetworkreply.html#setReadBufferSize">setReadBufferSize</a></b> (<i>self</i>, int&#160;<i>size</i>)</li><li><div class="fn" /><b><a href="qnetworkreply.html#setRequest">setRequest</a></b> (<i>self</i>, QNetworkRequest&#160;<i>request</i>)</li><li><div class="fn" /><b><a href="qnetworkreply.html#setSslConfiguration">setSslConfiguration</a></b> (<i>self</i>, QSslConfiguration&#160;<i>configuration</i>)</li><li><div class="fn" /><b><a href="qnetworkreply.html#setUrl">setUrl</a></b> (<i>self</i>, QUrl&#160;<i>url</i>)</li><li><div class="fn" />QSslConfiguration <b><a href="qnetworkreply.html#sslConfiguration">sslConfiguration</a></b> (<i>self</i>)</li><li><div class="fn" />QUrl <b><a href="qnetworkreply.html#url">url</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qnetworkreply.html#writeData">writeData</a></b> (<i>self</i>, str&#160;<i>data</i>)</li></ul><h3>Qt Signals</h3><ul><li><div class="fn" />void <b><a href="qnetworkreply.html#downloadProgress">downloadProgress</a></b> (qint64,qint64)</li><li><div class="fn" />void <b><a href="qnetworkreply.html#error-2">error</a></b> (QNetworkReply::NetworkError)</li><li><div class="fn" />void <b><a href="qnetworkreply.html#finished">finished</a></b> ()</li><li><div class="fn" />void <b><a href="qnetworkreply.html#metaDataChanged">metaDataChanged</a></b> ()</li><li><div class="fn" />void <b><a href="qnetworkreply.html#sslErrors">sslErrors</a></b> (const QList&lt;QSslError&gt;&amp;)</li><li><div class="fn" />void <b><a href="qnetworkreply.html#uploadProgress">uploadProgress</a></b> (qint64,qint64)</li></ul><a name="details" /><hr /><h2>Detailed Description</h2><p>The QNetworkReply class contains the data and headers for a
request sent with <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a></p>
<p>The QNetworkReply class contains the data and meta data related
to a request posted with <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>. Like
<a href="qnetworkrequest.html">QNetworkRequest</a>, it contains a
URL and headers (both in parsed and raw form), some information
about the reply's state and the contents of the reply itself.</p>
<p>QNetworkReply is a sequential-access <a href="qiodevice.html">QIODevice</a>, which means that once data is read
from the object, it no longer kept by the device. It is therefore
the application's responsibility to keep this data if it needs to.
Whenever more data is received from the network and processed, the
<a href="qiodevice.html#readyRead">readyRead</a>() signal is
emitted.</p>
<p>The <a href="qnetworkreply.html#downloadProgress">downloadProgress</a>() signal
is also emitted when data is received, but the number of bytes
contained in it may not represent the actual bytes received, if any
transformation is done to the contents (for example, decompressing
and removing the protocol overhead).</p>
<p>Even though QNetworkReply is a <a href="qiodevice.html">QIODevice</a> connected to the contents of the
reply, it also emits the <a href="qnetworkreply.html#uploadProgress">uploadProgress</a>() signal,
which indicates the progress of the upload for operations that have
such content.</p>
<p><b>Note:</b> Do not delete the object in the slot connected to
the <a href="qnetworkreply.html#error">error</a>() or <a href="qnetworkreply.html#finished">finished</a>() signal. Use <a href="qobject.html#deleteLater">deleteLater</a>().</p>
<hr /><h2>Type Documentation</h2><h3 class="fn"><a name="NetworkError-enum" />QNetworkReply.NetworkError</h3><p>Indicates all possible error conditions found during the
processing of the request.</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QNetworkReply.NoError</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">no error condition. <b>Note:</b> When the HTTP
protocol returns a redirect no error will be reported. You can
check if there is a redirect with the <a href="qnetworkrequest.html#Attribute-enum">QNetworkRequest.RedirectionTargetAttribute</a>
attribute.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.ConnectionRefusedError</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">the remote server refused the connection (the
server is not accepting requests)</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.RemoteHostClosedError</tt></td>
<td class="topAlign"><tt>2</tt></td>
<td class="topAlign">the remote server closed the connection
prematurely, before the entire reply was received and
processed</td>
</tr>
<tr>
<td class="topAlign"><tt>QNetworkReply.HostNotFoundError</tt></td>
<td class="topAlign"><tt>3</tt></td>
<td class="topAlign">the remote host name was not found (invalid
hostname)</td>
</tr>
<tr>
<td class="topAlign"><tt>QNetworkReply.TimeoutError</tt></td>
<td class="topAlign"><tt>4</tt></td>
<td class="topAlign">the connection to the remote server timed
out</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.OperationCanceledError</tt></td>
<td class="topAlign"><tt>5</tt></td>
<td class="topAlign">the operation was canceled via calls to
<a href="qnetworkreply.html#abort">abort</a>() or <a href="qnetworkreply.html#close">close</a>() before it was finished.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.SslHandshakeFailedError</tt></td>
<td class="topAlign"><tt>6</tt></td>
<td class="topAlign">the SSL/TLS handshake failed and the encrypted
channel could not be established. The <a href="qnetworkreply.html#sslErrors">sslErrors</a>() signal should have
been emitted.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.TemporaryNetworkFailureError</tt></td>
<td class="topAlign"><tt>7</tt></td>
<td class="topAlign">the connection was broken due to disconnection
from the network, however the system has initiated roaming to
another access point. The request should be resubmitted and will be
processed as soon as the connection is re-established.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.ProxyConnectionRefusedError</tt></td>
<td class="topAlign"><tt>101</tt></td>
<td class="topAlign">the connection to the proxy server was refused
(the proxy server is not accepting requests)</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.ProxyConnectionClosedError</tt></td>
<td class="topAlign"><tt>102</tt></td>
<td class="topAlign">the proxy server closed the connection
prematurely, before the entire reply was received and
processed</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.ProxyNotFoundError</tt></td>
<td class="topAlign"><tt>103</tt></td>
<td class="topAlign">the proxy host name was not found (invalid
proxy hostname)</td>
</tr>
<tr>
<td class="topAlign"><tt>QNetworkReply.ProxyTimeoutError</tt></td>
<td class="topAlign"><tt>104</tt></td>
<td class="topAlign">the connection to the proxy timed out or the
proxy did not reply in time to the request sent</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.ProxyAuthenticationRequiredError</tt></td>
<td class="topAlign"><tt>105</tt></td>
<td class="topAlign">the proxy requires authentication in order to
honour the request but did not accept any credentials offered (if
any)</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.ContentAccessDenied</tt></td>
<td class="topAlign"><tt>201</tt></td>
<td class="topAlign">the access to the remote content was denied
(similar to HTTP error 401)</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.ContentOperationNotPermittedError</tt></td>
<td class="topAlign"><tt>202</tt></td>
<td class="topAlign">the operation requested on the remote content
is not permitted</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.ContentNotFoundError</tt></td>
<td class="topAlign"><tt>203</tt></td>
<td class="topAlign">the remote content was not found at the server
(similar to HTTP error 404)</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.AuthenticationRequiredError</tt></td>
<td class="topAlign"><tt>204</tt></td>
<td class="topAlign">the remote server requires authentication to
serve the content but the credentials provided were not accepted
(if any)</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.ContentReSendError</tt></td>
<td class="topAlign"><tt>205</tt></td>
<td class="topAlign">the request needed to be sent again, but this
failed for example because the upload data could not be read a
second time.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.ProtocolUnknownError</tt></td>
<td class="topAlign"><tt>301</tt></td>
<td class="topAlign">the Network Access API cannot honor the
request because the protocol is not known</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.ProtocolInvalidOperationError</tt></td>
<td class="topAlign"><tt>302</tt></td>
<td class="topAlign">the requested operation is invalid for this
protocol</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.UnknownNetworkError</tt></td>
<td class="topAlign"><tt>99</tt></td>
<td class="topAlign">an unknown network-related error was
detected</td>
</tr>
<tr>
<td class="topAlign"><tt>QNetworkReply.UnknownProxyError</tt></td>
<td class="topAlign"><tt>199</tt></td>
<td class="topAlign">an unknown proxy-related error was
detected</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.UnknownContentError</tt></td>
<td class="topAlign"><tt>299</tt></td>
<td class="topAlign">an unknown error related to the remote content
was detected</td>
</tr>
<tr>
<td class="topAlign"><tt>QNetworkReply.ProtocolFailure</tt></td>
<td class="topAlign"><tt>399</tt></td>
<td class="topAlign">a breakdown in protocol was detected (parsing
error, invalid or unexpected responses, etc.)</td>
</tr>
</table>
<p><b>See also</b> <a href="qnetworkreply.html#error">error</a>().</p>


<hr /><h2>Method Documentation</h2><h3 class="fn"><a name="QNetworkReply" />QNetworkReply.__init__ (<i>self</i>, <a href="qobject.html">QObject</a>&#160;<i>parent</i>&#160;=&#160;None)</h3><p>The <i>parent</i> argument, if not None, causes <i>self</i> to be owned by Qt instead of PyQt.</p><p>Creates a <a href="qnetworkreply.html">QNetworkReply</a> object
with parent <i>parent</i>.</p>
<p>You cannot directly instantiate <a href="qnetworkreply.html">QNetworkReply</a> objects. Use <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> functions to
do that.</p>


<h3 class="fn"><a name="abort" />QNetworkReply.abort (<i>self</i>)</h3><p>This method is abstract and should be reimplemented in any sub-class.</p><p>Aborts the operation immediately and close down any network
connections still open. Uploads still in progress are also
aborted.</p>
<p><b>See also</b> <a href="qnetworkreply.html#close">close</a>().</p>


<h3 class="fn"><a name="attribute" />QVariant QNetworkReply.attribute (<i>self</i>, <a href="qnetworkrequest.html#Attribute-enum">QNetworkRequest.Attribute</a>&#160;<i>code</i>)</h3><p>Returns the attribute associated with the code <i>code</i>. If
the attribute has not been set, it returns an invalid <a href="qvariant.html">QVariant</a> (type QVariant.Null).</p>
<p>You can expect the default values listed in <a href="qnetworkrequest.html#Attribute-enum">QNetworkRequest.Attribute</a>
to be applied to the values returned by this function.</p>
<p><b>See also</b> <a href="qnetworkreply.html#setAttribute">setAttribute</a>() and <a href="qnetworkrequest.html#Attribute-enum">QNetworkRequest.Attribute</a>.</p>


<h3 class="fn"><a name="close" />QNetworkReply.close (<i>self</i>)</h3><p>Reimplemented from <a href="qiodevice.html#close">QIODevice.close</a>().</p>
<p>Closes this device for reading. Unread data is discarded, but
the network resources are not discarded until they are finished. In
particular, if any upload is in progress, it will continue until it
is done.</p>
<p>The <a href="qnetworkreply.html#finished">finished</a>() signal
is emitted when all operations are over and the network resources
are freed.</p>
<p><b>See also</b> <a href="qnetworkreply.html#abort">abort</a>()
and <a href="qnetworkreply.html#finished">finished</a>().</p>


<h3 class="fn"><a name="error" /><a href="qnetworkreply.html#NetworkError-enum">NetworkError</a> QNetworkReply.error (<i>self</i>)</h3><p>Returns the error that was found during the processing of this
request. If no error was found, returns <a href="qnetworkreply.html#NetworkError-enum">NoError</a>.</p>
<p><b>See also</b> <a href="qnetworkreply.html#setError">setError</a>().</p>


<h3 class="fn"><a name="hasRawHeader" />bool QNetworkReply.hasRawHeader (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>headerName</i>)</h3><p>Returns true if the raw header of name <i>headerName</i> was
sent by the remote server</p>
<p><b>See also</b> <a href="qnetworkreply.html#rawHeader">rawHeader</a>().</p>


<h3 class="fn"><a name="header" />QVariant QNetworkReply.header (<i>self</i>, <a href="qnetworkrequest.html#KnownHeaders-enum">QNetworkRequest.KnownHeaders</a>&#160;<i>header</i>)</h3><p>Returns the value of the known header <i>header</i>, if that
header was sent by the remote server. If the header was not sent,
returns an invalid <a href="qvariant.html">QVariant</a>.</p>
<p><b>See also</b> <a href="qnetworkreply.html#rawHeader">rawHeader</a>(), <a href="qnetworkreply.html#setHeader">setHeader</a>(), and <a href="qnetworkrequest.html#header">QNetworkRequest.header</a>().</p>


<h3 class="fn"><a name="ignoreSslErrors" />QNetworkReply.ignoreSslErrors (<i>self</i>)</h3><p>This method is also a Qt slot with the C++ signature <tt>void ignoreSslErrors()</tt>.</p><p>If this function is called, SSL errors related to network
connection will be ignored, including certificate validation
errors.</p>
<p>Note that calling this function without restraint may pose a
security risk for your application. Use it with care.</p>
<p>This function can be called from the slot connected to the
<a href="qnetworkreply.html#sslErrors">sslErrors</a>() signal,
which indicates which errors were found.</p>
<p><b>See also</b> <a href="qnetworkreply.html#sslConfiguration">sslConfiguration</a>(),
<a href="qnetworkreply.html#sslErrors">sslErrors</a>(), and
<a href="qsslsocket.html#ignoreSslErrors">QSslSocket.ignoreSslErrors</a>().</p>


<h3 class="fn"><a name="ignoreSslErrors-2" />QNetworkReply.ignoreSslErrors (<i>self</i>, list-of-QSslError&#160;<i>errors</i>)</h3><p>This is an overloaded function.</p>
<p>If this function is called, the SSL errors given in
<i>errors</i> will be ignored.</p>
<p>Note that you can set the expected certificate in the SSL error:
If, for instance, you want to issue a request to a server that uses
a self-signed certificate, consider the following snippet:</p>
<pre class="cpp">
 <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qsslcertificate.html">QSslCertificate</a></span><span class="operator">&gt;</span> cert <span class="operator">=</span> <span class="type"><a href="qsslcertificate.html">QSslCertificate</a></span><span class="operator">.</span>fromPath(QLatin1String(<span class="string">"server-certificate.pem"</span>));
 <span class="type"><a href="qsslerror.html">QSslError</a></span> <a href="qnetworkreply.html#error">error</a>(<span class="type"><a href="qsslerror.html">QSslError</a></span><span class="operator">.</span>SelfSignedCertificate<span class="operator">,</span> cert<span class="operator">.</span>at(<span class="number">0</span>));
 <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qsslerror.html">QSslError</a></span><span class="operator">&gt;</span> expectedSslErrors;
 expectedSslErrors<span class="operator">.</span>append(error);

 <span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span> <span class="operator">*</span>reply <span class="operator">=</span> manager<span class="operator">.</span>get(<span class="type"><a href="qnetworkrequest.html">QNetworkRequest</a></span>(<span class="type"><a href="qurl.html">QUrl</a></span>(<span class="string">"https://server.tld/index.html"</span>)));
 reply<span class="operator">-</span><span class="operator">&gt;</span><a href="qnetworkreply.html#ignoreSslErrors">ignoreSslErrors</a>(expectedSslErrors);
 <span class="comment">// here connect signals etc.</span>
</pre>
<p>Multiple calls to this function will replace the list of errors
that were passed in previous calls. You can clear the list of
errors you want to ignore by calling this function with an empty
list.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also</b> <a href="qnetworkreply.html#sslConfiguration">sslConfiguration</a>(),
<a href="qnetworkreply.html#sslErrors">sslErrors</a>(), and
<a href="qsslsocket.html#ignoreSslErrors">QSslSocket.ignoreSslErrors</a>().</p>


<h3 class="fn"><a name="isFinished" />bool QNetworkReply.isFinished (<i>self</i>)</h3><p>Returns true when the reply has finished or was aborted.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also</b> <a href="qnetworkreply.html#isRunning">isRunning</a>().</p>


<h3 class="fn"><a name="isRunning" />bool QNetworkReply.isRunning (<i>self</i>)</h3><p>Returns true when the request is still processing and the reply
has not finished or was aborted yet.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also</b> <a href="qnetworkreply.html#isFinished">isFinished</a>().</p>


<h3 class="fn"><a name="isSequential" />bool QNetworkReply.isSequential (<i>self</i>)</h3><h3 class="fn"><a name="manager" /><a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> QNetworkReply.manager (<i>self</i>)</h3><p>Returns the <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> that was
used to create this <a href="qnetworkreply.html">QNetworkReply</a>
object. Initially, it is also the parent object.</p>


<h3 class="fn"><a name="operation" /><a href="qnetworkaccessmanager.html#Operation-enum">QNetworkAccessManager.Operation</a> QNetworkReply.operation (<i>self</i>)</h3><p>Returns the operation that was posted for this reply.</p>
<p><b>See also</b> <a href="qnetworkreply.html#setOperation">setOperation</a>().</p>


<h3 class="fn"><a name="rawHeader" /><a href="qbytearray.html">QByteArray</a> QNetworkReply.rawHeader (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>headerName</i>)</h3><p>Returns the raw contents of the header <i>headerName</i> as sent
by the remote server. If there is no such header, returns an empty
byte array, which may be indistinguishable from an empty header.
Use <a href="qnetworkreply.html#hasRawHeader">hasRawHeader</a>() to
verify if the server sent such header field.</p>
<p><b>See also</b> <a href="qnetworkreply.html#setRawHeader">setRawHeader</a>(), <a href="qnetworkreply.html#hasRawHeader">hasRawHeader</a>(), and <a href="qnetworkreply.html#header">header</a>().</p>


<h3 class="fn"><a name="rawHeaderList" />list-of-QByteArray QNetworkReply.rawHeaderList (<i>self</i>)</h3><p>Returns a list of headers fields that were sent by the remote
server, in the order that they were sent. Duplicate headers are
merged together and take place of the latter duplicate.</p>


<h3 class="fn"><a name="rawHeaderPairs" />list-of-tuple-of-QByteArray-QByteArray QNetworkReply.rawHeaderPairs (<i>self</i>)</h3><p>Returns a list of raw header pairs.</p>


<h3 class="fn"><a name="readBufferSize" />int QNetworkReply.readBufferSize (<i>self</i>)</h3><p>Returns the size of the read buffer, in bytes.</p>
<p><b>See also</b> <a href="qnetworkreply.html#setReadBufferSize">setReadBufferSize</a>().</p>


<h3 class="fn"><a name="request" /><a href="qnetworkrequest.html">QNetworkRequest</a> QNetworkReply.request (<i>self</i>)</h3><p>Returns the request that was posted for this reply. In special,
note that the URL for the request may be different than that of the
reply.</p>
<p><b>See also</b> <a href="qnetworkrequest.html#url">QNetworkRequest.url</a>(), <a href="qnetworkreply.html#url">url</a>(), and <a href="qnetworkreply.html#setRequest">setRequest</a>().</p>


<h3 class="fn"><a name="setAttribute" />QNetworkReply.setAttribute (<i>self</i>, <a href="qnetworkrequest.html#Attribute-enum">QNetworkRequest.Attribute</a>&#160;<i>code</i>, QVariant&#160;<i>value</i>)</h3><p>Sets the attribute <i>code</i> to have value <i>value</i>. If
<i>code</i> was previously set, it will be overridden. If
<i>value</i> is an invalid <a href="qvariant.html">QVariant</a>,
the attribute will be unset.</p>
<p><b>See also</b> <a href="qnetworkreply.html#attribute">attribute</a>() and <a href="qnetworkrequest.html#setAttribute">QNetworkRequest.setAttribute</a>().</p>


<h3 class="fn"><a name="setError" />QNetworkReply.setError (<i>self</i>, <a href="qnetworkreply.html#NetworkError-enum">NetworkError</a>&#160;<i>errorCode</i>, QString&#160;<i>errorString</i>)</h3><p>Sets the error condition to be <i>errorCode</i>. The
human-readable message is set with <i>errorString</i>.</p>
<p>Calling setError() does not emit the error(<a href="qnetworkreply.html#NetworkError-enum">QNetworkReply.NetworkError</a>)
signal.</p>
<p><b>See also</b> <a href="qnetworkreply.html#error">error</a>()
and <a href="qiodevice.html#errorString">errorString</a>().</p>


<h3 class="fn"><a name="setFinished" />QNetworkReply.setFinished (<i>self</i>, bool&#160;<i>finished</i>)</h3><p>Sets the reply as <i>finished</i>.</p>
<p>After having this set the replies data must not change.</p>
<p>This function was introduced in Qt 4.8.</p>
<p><b>See also</b> <a href="qnetworkreply.html#finished">finished</a>() and <a href="qnetworkreply.html#isFinished">isFinished</a>().</p>


<h3 class="fn"><a name="setHeader" />QNetworkReply.setHeader (<i>self</i>, <a href="qnetworkrequest.html#KnownHeaders-enum">QNetworkRequest.KnownHeaders</a>&#160;<i>header</i>, QVariant&#160;<i>value</i>)</h3><p>Sets the known header <i>header</i> to be of value <i>value</i>.
The corresponding raw form of the header will be set as well.</p>
<p><b>See also</b> <a href="qnetworkreply.html#header">header</a>(), <a href="qnetworkreply.html#setRawHeader">setRawHeader</a>(), and <a href="qnetworkrequest.html#setHeader">QNetworkRequest.setHeader</a>().</p>


<h3 class="fn"><a name="setOperation" />QNetworkReply.setOperation (<i>self</i>, <a href="qnetworkaccessmanager.html#Operation-enum">QNetworkAccessManager.Operation</a>&#160;<i>operation</i>)</h3><p>Sets the associated operation for this object to be
<i>operation</i>. This value will be returned by <a href="qnetworkreply.html#operation">operation</a>().</p>
<p>Note: the operation should be set when this object is created
and not changed again.</p>
<p><b>See also</b> <a href="qnetworkreply.html#operation">operation</a>() and <a href="qnetworkreply.html#setRequest">setRequest</a>().</p>


<h3 class="fn"><a name="setRawHeader" />QNetworkReply.setRawHeader (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>headerName</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>value</i>)</h3><p>Sets the raw header <i>headerName</i> to be of value
<i>value</i>. If <i>headerName</i> was previously set, it is
overridden. Multiple HTTP headers of the same name are functionally
equivalent to one single header with the values concatenated,
separated by commas.</p>
<p>If <i>headerName</i> matches a known header, the value
<i>value</i> will be parsed and the corresponding parsed form will
also be set.</p>
<p><b>See also</b> <a href="qnetworkreply.html#rawHeader">rawHeader</a>(), <a href="qnetworkreply.html#header">header</a>(), <a href="qnetworkreply.html#setHeader">setHeader</a>(), and <a href="qnetworkrequest.html#setRawHeader">QNetworkRequest.setRawHeader</a>().</p>


<h3 class="fn"><a name="setReadBufferSize" />QNetworkReply.setReadBufferSize (<i>self</i>, int&#160;<i>size</i>)</h3><p>Sets the size of the read buffer to be <i>size</i> bytes. The
read buffer is the buffer that holds data that is being downloaded
off the network, before it is read with <a href="qiodevice.html#read">QIODevice.read</a>(). Setting the buffer
size to 0 will make the buffer unlimited in size.</p>
<p><a href="qnetworkreply.html">QNetworkReply</a> will try to stop
reading from the network once this buffer is full (i.e., <a href="qiodevice.html#bytesAvailable">bytesAvailable</a>() returns
<i>size</i> or more), thus causing the download to throttle down as
well. If the buffer is not limited in size, <a href="qnetworkreply.html">QNetworkReply</a> will try to download as fast
as possible from the network.</p>
<p>Unlike <a href="qabstractsocket.html#setReadBufferSize">QAbstractSocket.setReadBufferSize</a>(),
<a href="qnetworkreply.html">QNetworkReply</a> cannot guarantee
precision in the read buffer size. That is, <a href="qiodevice.html#bytesAvailable">bytesAvailable</a>() can return
more than <i>size</i>.</p>
<p><b>See also</b> <a href="qnetworkreply.html#readBufferSize">readBufferSize</a>().</p>


<h3 class="fn"><a name="setRequest" />QNetworkReply.setRequest (<i>self</i>, <a href="qnetworkrequest.html">QNetworkRequest</a>&#160;<i>request</i>)</h3><p>Sets the associated request for this object to be
<i>request</i>. This value will be returned by <a href="qnetworkreply.html#request">request</a>().</p>
<p>Note: the request should be set when this object is created and
not changed again.</p>
<p><b>See also</b> <a href="qnetworkreply.html#request">request</a>() and <a href="qnetworkreply.html#setOperation">setOperation</a>().</p>


<h3 class="fn"><a name="setSslConfiguration" />QNetworkReply.setSslConfiguration (<i>self</i>, <a href="qsslconfiguration.html">QSslConfiguration</a>&#160;<i>configuration</i>)</h3><p>Sets the SSL configuration for the network connection associated
with this request, if possible, to be that of <i>config</i>.</p>
<p><b>See also</b> <a href="qnetworkreply.html#sslConfiguration">sslConfiguration</a>().</p>


<h3 class="fn"><a name="setUrl" />QNetworkReply.setUrl (<i>self</i>, <a href="qurl.html">QUrl</a>&#160;<i>url</i>)</h3><p>Sets the URL being processed to be <i>url</i>. Normally, the URL
matches that of the request that was posted, but for a variety of
reasons it can be different (for example, a file path being made
absolute or canonical).</p>
<p><b>See also</b> <a href="qnetworkreply.html#url">url</a>(),
<a href="qnetworkreply.html#request">request</a>(), and <a href="qnetworkrequest.html#url">QNetworkRequest.url</a>().</p>


<h3 class="fn"><a name="sslConfiguration" /><a href="qsslconfiguration.html">QSslConfiguration</a> QNetworkReply.sslConfiguration (<i>self</i>)</h3><p>Returns the SSL configuration and state associated with this
reply, if SSL was used. It will contain the remote server's
certificate, its certificate chain leading to the Certificate
Authority as well as the encryption ciphers in use.</p>
<p>The peer's certificate and its certificate chain will be known
by the time <a href="qnetworkreply.html#sslErrors">sslErrors</a>()
is emitted, if it's emitted.</p>
<p><b>See also</b> <a href="qnetworkreply.html#setSslConfiguration">setSslConfiguration</a>().</p>


<h3 class="fn"><a name="url" /><a href="qurl.html">QUrl</a> QNetworkReply.url (<i>self</i>)</h3><p>Returns the URL of the content downloaded or uploaded. Note that
the URL may be different from that of the original request.</p>
<p><b>See also</b> <a href="qnetworkreply.html#request">request</a>(), <a href="qnetworkreply.html#setUrl">setUrl</a>(), and <a href="qnetworkrequest.html#url">QNetworkRequest.url</a>().</p>
<h3 class="fn"><a name="writeData" />int QNetworkReply.writeData (<i>self</i>, str&#160;<i>data</i>)</h3><hr /><h2>Qt Signal Documentation</h2><h3 class="fn"><a name="downloadProgress" />void downloadProgress (qint64,qint64)</h3><p>This is the default overload of this signal.</p><p>This signal is emitted to indicate the progress of the download
part of this network request, if there's any. If there's no
download associated with this request, this signal will be emitted
once with 0 as the value of both <i>bytesReceived</i> and
<i>bytesTotal</i>.</p>
<p>The <i>bytesReceived</i> parameter indicates the number of bytes
received, while <i>bytesTotal</i> indicates the total number of
bytes expected to be downloaded. If the number of bytes to be
downloaded is not known, <i>bytesTotal</i> will be -1.</p>
<p>The download is finished when <i>bytesReceived</i> is equal to
<i>bytesTotal</i>. At that time, <i>bytesTotal</i> will not be
-1.</p>
<p>Note that the values of both <i>bytesReceived</i> and
<i>bytesTotal</i> may be different from <a href="qiodevice.html#size">size</a>(), the total number of bytes
obtained through <a href="qiodevice.html#read">read</a>() or
<a href="qiodevice.html#readAll">readAll</a>(), or the value of the
header(ContentLengthHeader). The reason for that is that there may
be protocol overhead or the data may be compressed during the
download.</p>
<p><b>See also</b> <a href="qnetworkreply.html#uploadProgress">uploadProgress</a>() and
<a href="qiodevice.html#bytesAvailable">bytesAvailable</a>().</p>


<h3 class="fn"><a name="error-2" />void error (QNetworkReply::NetworkError)</h3><p>This is the default overload of this signal.</p><p>This signal is emitted when the reply detects an error in
processing. The <a href="qnetworkreply.html#finished">finished</a>() signal will probably
follow, indicating that the connection is over.</p>
<p>The <i>code</i> parameter contains the code of the error that
was detected. Call <a href="qiodevice.html#errorString">errorString</a>() to obtain a textual
representation of the error condition.</p>
<p><b>Note:</b> Do not delete the object in the slot connected to
this signal. Use <a href="qobject.html#deleteLater">deleteLater</a>().</p>
<p><b>See also</b> <a href="qnetworkreply.html#error">error</a>()
and <a href="qiodevice.html#errorString">errorString</a>().</p>


<h3 class="fn"><a name="finished" />void finished ()</h3><p>This is the default overload of this signal.</p><p>This signal is emitted when the reply has finished processing.
After this signal is emitted, there will be no more updates to the
reply's data or metadata.</p>
<p>Unless <a href="qnetworkreply.html#close">close</a>() has been
called, the reply will be still be opened for reading, so the data
can be retrieved by calls to <a href="qiodevice.html#read">read</a>() or <a href="qiodevice.html#readAll">readAll</a>(). In particular, if no calls
to <a href="qiodevice.html#read">read</a>() were made as a result
of <a href="qiodevice.html#readyRead">readyRead</a>(), a call to
<a href="qiodevice.html#readAll">readAll</a>() will retrieve the
full contents in a <a href="qbytearray.html">QByteArray</a>.</p>
<p>This signal is emitted in tandem with <a href="qnetworkaccessmanager.html#finished">QNetworkAccessManager.finished</a>()
where that signal's reply parameter is this object.</p>
<p><b>Note:</b> Do not delete the object in the slot connected to
this signal. Use <a href="qobject.html#deleteLater">deleteLater</a>().</p>
<p>You can also use <a href="qnetworkreply.html#isFinished">isFinished</a>() to check if a
<a href="qnetworkreply.html">QNetworkReply</a> has finished even
before you receive the finished() signal.</p>
<p><b>See also</b> <a href="qnetworkreply.html#setFinished">setFinished</a>(), <a href="qnetworkaccessmanager.html#finished">QNetworkAccessManager.finished</a>(),
and <a href="qnetworkreply.html#isFinished">isFinished</a>().</p>


<h3 class="fn"><a name="metaDataChanged" />void metaDataChanged ()</h3><p>This is the default overload of this signal.</p><p>This signal is emitted whenever the metadata in this reply
changes. metadata is any information that is not the content (data)
itself, including the network headers. In the majority of cases,
the metadata will be known fully by the time the first byte of data
is received. However, it is possible to receive updates of headers
or other metadata during the processing of the data.</p>
<p><b>See also</b> <a href="qnetworkreply.html#header">header</a>(), <a href="qnetworkreply.html#rawHeaderList">rawHeaderList</a>(), <a href="qnetworkreply.html#rawHeader">rawHeader</a>(), and <a href="qnetworkreply.html#hasRawHeader">hasRawHeader</a>().</p>


<h3 class="fn"><a name="sslErrors" />void sslErrors (const QList&lt;QSslError&gt;&amp;)</h3><p>This is the default overload of this signal.</p><p>This signal is emitted if the SSL/TLS session encountered errors
during the set up, including certificate verification errors. The
<i>errors</i> parameter contains the list of errors.</p>
<p>To indicate that the errors are not fatal and that the
connection should proceed, the <a href="qnetworkreply.html#ignoreSslErrors">ignoreSslErrors</a>() function
should be called from the slot connected to this signal. If it is
not called, the SSL session will be torn down before any data is
exchanged (including the URL).</p>
<p>This signal can be used to display an error message to the user
indicating that security may be compromised and display the SSL
settings (see <a href="qnetworkreply.html#sslConfiguration">sslConfiguration</a>() to
obtain it). If the user decides to proceed after analyzing the
remote certificate, the slot should call <a href="qnetworkreply.html#ignoreSslErrors">ignoreSslErrors</a>().</p>
<p><b>See also</b> <a href="qsslsocket.html#sslErrors">QSslSocket.sslErrors</a>(), <a href="qnetworkaccessmanager.html#sslErrors">QNetworkAccessManager.sslErrors</a>(),
<a href="qnetworkreply.html#sslConfiguration">sslConfiguration</a>(), and
<a href="qnetworkreply.html#ignoreSslErrors">ignoreSslErrors</a>().</p>


<h3 class="fn"><a name="uploadProgress" />void uploadProgress (qint64,qint64)</h3><p>This is the default overload of this signal.</p><p>This signal is emitted to indicate the progress of the upload
part of this network request, if there's any. If there's no upload
associated with this request, this signal will not be emitted.</p>
<p>The <i>bytesSent</i> parameter indicates the number of bytes
uploaded, while <i>bytesTotal</i> indicates the total number of
bytes to be uploaded. If the number of bytes to be uploaded could
not be determined, <i>bytesTotal</i> will be -1.</p>
<p>The upload is finished when <i>bytesSent</i> is equal to
<i>bytesTotal</i>. At that time, <i>bytesTotal</i> will not be
-1.</p>
<p><b>See also</b> <a href="qnetworkreply.html#downloadProgress">downloadProgress</a>().</p>


<address><hr /><div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address"><td align="left" width="25%">PyQt&#160;4.10 for Windows</td><td align="center" width="50%">Copyright &#169; <a href="http://www.riverbankcomputing.com">Riverbank&#160;Computing&#160;Ltd</a> and <a href="http://www.qtsoftware.com">Nokia</a> 2012</td><td align="right" width="25%">Qt&#160;4.8.4</td></tr></table></div></address></body></html>