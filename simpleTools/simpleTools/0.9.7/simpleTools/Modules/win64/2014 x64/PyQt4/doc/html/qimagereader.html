<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html><head><title>QImageReader Class Reference</title><style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style></head><body><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr /><td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" width="32" /></td><td width="1">&#160;&#160;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&#160;&#183; <a href="classes.html"><font color="#004faf">All Classes</font></a>&#160;&#183; <a href="modules.html"><font color="#004faf">Modules</font></a></td></table><h1 align="center">QImageReader Class Reference<br /><sup><sup>[<a href="qtgui.html">QtGui</a> module]</sup></sup></h1><p>The QImageReader class provides a format independent interface
for reading images from files or other devices. <a href="#details">More...</a></p>

<h3>Types</h3><ul><li><div class="fn" />enum <b><a href="qimagereader.html#ImageReaderError-enum">ImageReaderError</a></b> { UnknownError, FileNotFoundError, DeviceError, UnsupportedFormatError, InvalidDataError }</li></ul><h3>Methods</h3><ul><li><div class="fn" /><b><a href="qimagereader.html#QImageReader">__init__</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qimagereader.html#QImageReader-2">__init__</a></b> (<i>self</i>, QIODevice&#160;<i>device</i>, QByteArray&#160;<i>format</i>&#160;=&#160;QByteArray())</li><li><div class="fn" /><b><a href="qimagereader.html#QImageReader-3">__init__</a></b> (<i>self</i>, QString&#160;<i>fileName</i>, QByteArray&#160;<i>format</i>&#160;=&#160;QByteArray())</li><li><div class="fn" />bool <b><a href="qimagereader.html#autoDetectImageFormat">autoDetectImageFormat</a></b> (<i>self</i>)</li><li><div class="fn" />QColor <b><a href="qimagereader.html#backgroundColor">backgroundColor</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qimagereader.html#canRead">canRead</a></b> (<i>self</i>)</li><li><div class="fn" />QRect <b><a href="qimagereader.html#clipRect">clipRect</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qimagereader.html#currentImageNumber">currentImageNumber</a></b> (<i>self</i>)</li><li><div class="fn" />QRect <b><a href="qimagereader.html#currentImageRect">currentImageRect</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qimagereader.html#decideFormatFromContent">decideFormatFromContent</a></b> (<i>self</i>)</li><li><div class="fn" />QIODevice <b><a href="qimagereader.html#device">device</a></b> (<i>self</i>)</li><li><div class="fn" />ImageReaderError <b><a href="qimagereader.html#error">error</a></b> (<i>self</i>)</li><li><div class="fn" />QString <b><a href="qimagereader.html#errorString">errorString</a></b> (<i>self</i>)</li><li><div class="fn" />QString <b><a href="qimagereader.html#fileName">fileName</a></b> (<i>self</i>)</li><li><div class="fn" />QByteArray <b><a href="qimagereader.html#format">format</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qimagereader.html#imageCount">imageCount</a></b> (<i>self</i>)</li><li><div class="fn" />QImage.Format <b><a href="qimagereader.html#imageFormat-3">imageFormat</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qimagereader.html#jumpToImage">jumpToImage</a></b> (<i>self</i>, int&#160;<i>imageNumber</i>)</li><li><div class="fn" />bool <b><a href="qimagereader.html#jumpToNextImage">jumpToNextImage</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qimagereader.html#loopCount">loopCount</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qimagereader.html#nextImageDelay">nextImageDelay</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qimagereader.html#quality">quality</a></b> (<i>self</i>)</li><li><div class="fn" />QImage <b><a href="qimagereader.html#read">read</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qimagereader.html#read-2">read</a></b> (<i>self</i>, QImage&#160;<i>image</i>)</li><li><div class="fn" />QRect <b><a href="qimagereader.html#scaledClipRect">scaledClipRect</a></b> (<i>self</i>)</li><li><div class="fn" />QSize <b><a href="qimagereader.html#scaledSize">scaledSize</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qimagereader.html#setAutoDetectImageFormat">setAutoDetectImageFormat</a></b> (<i>self</i>, bool&#160;<i>enabled</i>)</li><li><div class="fn" /><b><a href="qimagereader.html#setBackgroundColor">setBackgroundColor</a></b> (<i>self</i>, QColor&#160;<i>color</i>)</li><li><div class="fn" /><b><a href="qimagereader.html#setClipRect">setClipRect</a></b> (<i>self</i>, QRect&#160;<i>rect</i>)</li><li><div class="fn" /><b><a href="qimagereader.html#setDecideFormatFromContent">setDecideFormatFromContent</a></b> (<i>self</i>, bool&#160;<i>ignored</i>)</li><li><div class="fn" /><b><a href="qimagereader.html#setDevice">setDevice</a></b> (<i>self</i>, QIODevice&#160;<i>device</i>)</li><li><div class="fn" /><b><a href="qimagereader.html#setFileName">setFileName</a></b> (<i>self</i>, QString&#160;<i>fileName</i>)</li><li><div class="fn" /><b><a href="qimagereader.html#setFormat">setFormat</a></b> (<i>self</i>, QByteArray&#160;<i>format</i>)</li><li><div class="fn" /><b><a href="qimagereader.html#setQuality">setQuality</a></b> (<i>self</i>, int&#160;<i>quality</i>)</li><li><div class="fn" /><b><a href="qimagereader.html#setScaledClipRect">setScaledClipRect</a></b> (<i>self</i>, QRect&#160;<i>rect</i>)</li><li><div class="fn" /><b><a href="qimagereader.html#setScaledSize">setScaledSize</a></b> (<i>self</i>, QSize&#160;<i>size</i>)</li><li><div class="fn" />QSize <b><a href="qimagereader.html#size">size</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qimagereader.html#supportsAnimation">supportsAnimation</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qimagereader.html#supportsOption">supportsOption</a></b> (<i>self</i>, QImageIOHandler.ImageOption&#160;<i>option</i>)</li><li><div class="fn" />QString <b><a href="qimagereader.html#text">text</a></b> (<i>self</i>, QString&#160;<i>key</i>)</li><li><div class="fn" />QStringList <b><a href="qimagereader.html#textKeys">textKeys</a></b> (<i>self</i>)</li></ul><h3>Static Methods</h3><ul><li><div class="fn" />QByteArray <b><a href="qimagereader.html#imageFormat">imageFormat</a></b> (QString&#160;<i>fileName</i>)</li><li><div class="fn" />QByteArray <b><a href="qimagereader.html#imageFormat-2">imageFormat</a></b> (QIODevice&#160;<i>device</i>)</li><li><div class="fn" />list-of-QByteArray <b><a href="qimagereader.html#supportedImageFormats">supportedImageFormats</a></b> ()</li></ul><a name="details" /><hr /><h2>Detailed Description</h2><p>The QImageReader class provides a format independent interface
for reading images from files or other devices.</p>
<p>The most common way to read images is through <a href="qimage.html">QImage</a> and <a href="qpixmap.html">QPixmap</a>'s
constructors, or by calling <a href="qimage.html#load">QImage.load</a>() and <a href="qpixmap.html#load">QPixmap.load</a>(). QImageReader is a
specialized class which gives you more control when reading images.
For example, you can read an image into a specific size by calling
<a href="qimagereader.html#setScaledSize">setScaledSize</a>(), and
you can select a clip rect, effectively loading only parts of an
image, by calling <a href="qimagereader.html#setClipRect">setClipRect</a>(). Depending on the
underlying support in the image format, this can save memory and
speed up loading of images.</p>
<p>To read an image, you start by constructing a QImageReader
object. Pass either a file name or a device pointer, and the image
format to QImageReader's constructor. You can then set several
options, such as the clip rect (by calling <a href="qimagereader.html#setClipRect">setClipRect</a>()) and scaled size
(by calling <a href="qimagereader.html#setScaledSize">setScaledSize</a>()). <a href="qimagereader.html#canRead">canRead</a>() returns the image if the
QImageReader can read the image (i.e., the image format is
supported and the device is open for reading). Call <a href="qimagereader.html#read">read</a>() to read the image.</p>
<p>If any error occurs when reading the image, <a href="qimagereader.html#read">read</a>() will return a null <a href="qimage.html">QImage</a>. You can then call <a href="qimagereader.html#error">error</a>() to find the type of error
that occurred, or <a href="qimagereader.html#errorString">errorString</a>() to get a human
readable description of what went wrong.</p>
<p>Call <a href="qimagereader.html#supportedImageFormats">supportedImageFormats</a>()
for a list of formats that QImageReader can read. QImageReader
supports all built-in image formats, in addition to any image
format plugins that support reading.</p>
<p>QImageReader autodetects the image format by default, by looking
at the provided (optional) format string, the file name suffix, and
the data stream contents. You can enable or disable this feature,
by calling <a href="qimagereader.html#setAutoDetectImageFormat">setAutoDetectImageFormat</a>().</p>
<hr /><h2>Type Documentation</h2><h3 class="fn"><a name="ImageReaderError-enum" />QImageReader.ImageReaderError</h3><p>This enum describes the different types of errors that can occur
when reading images with <a href="qimagereader.html">QImageReader</a>.</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QImageReader.FileNotFoundError</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign"><a href="qimagereader.html">QImageReader</a>
was used with a file name, but not file was found with that name.
This can also happen if the file name contained no extension, and
the file with the correct extension is not supported by Qt.</td>
</tr>
<tr>
<td class="topAlign"><tt>QImageReader.DeviceError</tt></td>
<td class="topAlign"><tt>2</tt></td>
<td class="topAlign"><a href="qimagereader.html">QImageReader</a>
encountered a device error when reading the image. You can consult
your particular device for more details on what went wrong.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QImageReader.UnsupportedFormatError</tt></td>
<td class="topAlign"><tt>3</tt></td>
<td class="topAlign">Qt does not support the requested image
format.</td>
</tr>
<tr>
<td class="topAlign"><tt>QImageReader.InvalidDataError</tt></td>
<td class="topAlign"><tt>4</tt></td>
<td class="topAlign">The image data was invalid, and <a href="qimagereader.html">QImageReader</a> was unable to read an image
from it. The can happen if the image file is damaged.</td>
</tr>
<tr>
<td class="topAlign"><tt>QImageReader.UnknownError</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">An unknown error occurred. If you get this
value after calling <a href="qimagereader.html#read">read</a>(), it
is most likely caused by a bug in <a href="qimagereader.html">QImageReader</a>.</td>
</tr>
</table>
<hr /><h2>Method Documentation</h2><h3 class="fn"><a name="QImageReader" />QImageReader.__init__ (<i>self</i>)</h3><p>Constructs an empty <a href="qimagereader.html">QImageReader</a>
object. Before reading an image, call <a href="qimagereader.html#setDevice">setDevice</a>() or <a href="qimagereader.html#setFileName">setFileName</a>().</p>


<h3 class="fn"><a name="QImageReader-2" />QImageReader.__init__ (<i>self</i>, <a href="qiodevice.html">QIODevice</a>&#160;<i>device</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>format</i>&#160;=&#160;QByteArray())</h3><p>Constructs a <a href="qimagereader.html">QImageReader</a> object
with the device <i>device</i> and the image format
<i>format</i>.</p>


<h3 class="fn"><a name="QImageReader-3" />QImageReader.__init__ (<i>self</i>, QString&#160;<i>fileName</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>format</i>&#160;=&#160;QByteArray())</h3><p>Constructs a <a href="qimagereader.html">QImageReader</a> object
with the file name <i>fileName</i> and the image format
<i>format</i>.</p>
<p><b>See also</b> <a href="qimagereader.html#setFileName">setFileName</a>().</p>


<h3 class="fn"><a name="autoDetectImageFormat" />bool QImageReader.autoDetectImageFormat (<i>self</i>)</h3><p>Returns true if image format autodetection is enabled on this
image reader; otherwise returns false. By default, autodetection is
enabled.</p>
<p><b>See also</b> <a href="qimagereader.html#setAutoDetectImageFormat">setAutoDetectImageFormat</a>().</p>


<h3 class="fn"><a name="backgroundColor" /><a href="qcolor.html">QColor</a> QImageReader.backgroundColor (<i>self</i>)</h3><p>Returns the background color that's used when reading an image.
If the image format does not support setting the background color
an invalid color is returned.</p>
<p>This function was introduced in Qt 4.1.</p>
<p><b>See also</b> <a href="qimagereader.html#setBackgroundColor">setBackgroundColor</a>() and
<a href="qimagereader.html#read">read</a>().</p>


<h3 class="fn"><a name="canRead" />bool QImageReader.canRead (<i>self</i>)</h3><p>Returns true if an image can be read for the device (i.e., the
image format is supported, and the device seems to contain valid
data); otherwise returns false.</p>
<p>canRead() is a lightweight function that only does a quick test
to see if the image data is valid. <a href="qimagereader.html#read">read</a>() may still return false after
canRead() returns true, if the image data is corrupt.</p>
<p>For images that support animation, canRead() returns false when
all frames have been read.</p>
<p><b>See also</b> <a href="qimagereader.html#read">read</a>() and
<a href="qimagereader.html#supportedImageFormats">supportedImageFormats</a>().</p>


<h3 class="fn"><a name="clipRect" /><a href="qrect.html">QRect</a> QImageReader.clipRect (<i>self</i>)</h3><p>Returns the clip rect (also known as the ROI, or Region Of
Interest) of the image. If no clip rect has been set, an invalid
<a href="qrect.html">QRect</a> is returned.</p>
<p><b>See also</b> <a href="qimagereader.html#setClipRect">setClipRect</a>().</p>


<h3 class="fn"><a name="currentImageNumber" />int QImageReader.currentImageNumber (<i>self</i>)</h3><p>For image formats that support animation, this function returns
the sequence number of the current frame. If the image format
doesn't support animation, 0 is returned.</p>
<p>This function returns -1 if an error occurred.</p>
<p><b>See also</b> <a href="qimagereader.html#supportsAnimation">supportsAnimation</a>(),
<a href="qimageiohandler.html#currentImageNumber">QImageIOHandler.currentImageNumber</a>(),
and <a href="qimagereader.html#canRead">canRead</a>().</p>


<h3 class="fn"><a name="currentImageRect" /><a href="qrect.html">QRect</a> QImageReader.currentImageRect (<i>self</i>)</h3><p>For image formats that support animation, this function returns
the rect for the current frame. Otherwise, a null rect is
returned.</p>
<p><b>See also</b> <a href="qimagereader.html#supportsAnimation">supportsAnimation</a>() and
<a href="qimageiohandler.html#currentImageRect">QImageIOHandler.currentImageRect</a>().</p>


<h3 class="fn"><a name="decideFormatFromContent" />bool QImageReader.decideFormatFromContent (<i>self</i>)</h3><p>Returns whether the image reader should decide which plugin to
use only based on the contents of the datastream rather than on the
file extension.</p>
<p><b>See also</b> <a href="qimagereader.html#setDecideFormatFromContent">setDecideFormatFromContent</a>().</p>


<h3 class="fn"><a name="device" /><a href="qiodevice.html">QIODevice</a> QImageReader.device (<i>self</i>)</h3><p>Returns the device currently assigned to <a href="qimagereader.html">QImageReader</a>, or 0 if no device has been
assigned.</p>
<p><b>See also</b> <a href="qimagereader.html#setDevice">setDevice</a>().</p>


<h3 class="fn"><a name="error" /><a href="qimagereader.html#ImageReaderError-enum">ImageReaderError</a> QImageReader.error (<i>self</i>)</h3><p>Returns the type of error that occurred last.</p>
<p><b>See also</b> <a href="qimagereader.html#ImageReaderError-enum">ImageReaderError</a> and
<a href="qimagereader.html#errorString">errorString</a>().</p>


<h3 class="fn"><a name="errorString" />QString QImageReader.errorString (<i>self</i>)</h3><p>Returns a human readable description of the last error that
occurred.</p>
<p><b>See also</b> <a href="qimagereader.html#error">error</a>().</p>


<h3 class="fn"><a name="fileName" />QString QImageReader.fileName (<i>self</i>)</h3><p>If the currently assigned device is a <a href="qfile.html">QFile</a>, or if <a href="qimagereader.html#setFileName">setFileName</a>() has been called,
this function returns the name of the file <a href="qimagereader.html">QImageReader</a> reads from. Otherwise (i.e.,
if no device has been assigned or the device is not a <a href="qfile.html">QFile</a>), an empty <a href="qstring.html">QString</a> is returned.</p>
<p><b>See also</b> <a href="qimagereader.html#setFileName">setFileName</a>() and <a href="qimagereader.html#setDevice">setDevice</a>().</p>


<h3 class="fn"><a name="format" /><a href="qbytearray.html">QByteArray</a> QImageReader.format (<i>self</i>)</h3><p>Returns the format <a href="qimagereader.html">QImageReader</a>
uses for reading images.</p>
<p>You can call this function after assigning a device to the
reader to determine the format of the device. For example:</p>
<pre class="cpp">
 <span class="type"><a href="qimagereader.html">QImageReader</a></span> reader(<span class="string">"image.png"</span>);
 <span class="comment">// reader.format() == "png"</span>
</pre>
<p>If the reader cannot read any image from the device (e.g., there
is no image there, or the image has already been read), or if the
format is unsupported, this function returns an empty
QByteArray().</p>
<p><b>See also</b> <a href="qimagereader.html#setFormat">setFormat</a>() and <a href="qimagereader.html#supportedImageFormats">supportedImageFormats</a>().</p>


<h3 class="fn"><a name="imageCount" />int QImageReader.imageCount (<i>self</i>)</h3><p>For image formats that support animation, this function returns
the total number of images in the animation. If the format does not
support animation, 0 is returned.</p>
<p>This function returns -1 if an error occurred.</p>
<p><b>See also</b> <a href="qimagereader.html#supportsAnimation">supportsAnimation</a>(),
<a href="qimageiohandler.html#imageCount">QImageIOHandler.imageCount</a>(),
and <a href="qimagereader.html#canRead">canRead</a>().</p>


<h3 class="fn"><a name="imageFormat" /><a href="qbytearray.html">QByteArray</a> QImageReader.imageFormat (QString&#160;<i>fileName</i>)</h3><p>Returns the format of the image, without actually reading the
image contents. The format describes the image format <a href="qimagereader.html#read">QImageReader.read</a>() returns, not the
format of the actual image.</p>
<p>If the image format does not support this feature, this function
returns an invalid format.</p>
<p>This function was introduced in Qt 4.5.</p>
<p><b>See also</b> <a href="qimageiohandler.html#ImageOption-enum">QImageIOHandler.ImageOption</a>,
<a href="qimageiohandler.html#option">QImageIOHandler.option</a>(), and
<a href="qimageiohandler.html#supportsOption">QImageIOHandler.supportsOption</a>().</p>


<h3 class="fn"><a name="imageFormat-2" /><a href="qbytearray.html">QByteArray</a> QImageReader.imageFormat (<a href="qiodevice.html">QIODevice</a>&#160;<i>device</i>)</h3><p>If supported, this function returns the image format of the file
<i>fileName</i>. Otherwise, an empty string is returned.</p>


<h3 class="fn"><a name="imageFormat-3" /><a href="qimage.html#Format-enum">QImage.Format</a> QImageReader.imageFormat (<i>self</i>)</h3><p>If supported, this function returns the image format of the
device <i>device</i>. Otherwise, an empty string is returned.</p>
<p><b>See also</b> <a href="qimagereader.html#autoDetectImageFormat">QImageReader.autoDetectImageFormat</a>().</p>


<h3 class="fn"><a name="jumpToImage" />bool QImageReader.jumpToImage (<i>self</i>, int&#160;<i>imageNumber</i>)</h3><p>For image formats that support animation, this function skips to
the image whose sequence number is <i>imageNumber</i>, returning
true if successful or false if the corresponding image cannot be
found.</p>
<p>The next call to <a href="qimagereader.html#read">read</a>()
will attempt to read this image.</p>
<p><b>See also</b> <a href="qimagereader.html#jumpToNextImage">jumpToNextImage</a>() and
<a href="qimageiohandler.html#jumpToImage">QImageIOHandler.jumpToImage</a>().</p>


<h3 class="fn"><a name="jumpToNextImage" />bool QImageReader.jumpToNextImage (<i>self</i>)</h3><p>For image formats that support animation, this function steps
over the current image, returning true if successful or false if
there is no following image in the animation.</p>
<p>The default implementation calls <a href="qimagereader.html#read">read</a>(), then discards the resulting
image, but the image handler may have a more efficient way of
implementing this operation.</p>
<p><b>See also</b> <a href="qimagereader.html#jumpToImage">jumpToImage</a>() and <a href="qimageiohandler.html#jumpToNextImage">QImageIOHandler.jumpToNextImage</a>().</p>


<h3 class="fn"><a name="loopCount" />int QImageReader.loopCount (<i>self</i>)</h3><p>For image formats that support animation, this function returns
the number of times the animation should loop. If this function
returns -1, it can either mean the animation should loop forever,
or that an error occurred. If an error occurred, <a href="qimagereader.html#canRead">canRead</a>() will return false.</p>
<p><b>See also</b> <a href="qimagereader.html#supportsAnimation">supportsAnimation</a>(),
<a href="qimageiohandler.html#loopCount">QImageIOHandler.loopCount</a>(),
and <a href="qimagereader.html#canRead">canRead</a>().</p>


<h3 class="fn"><a name="nextImageDelay" />int QImageReader.nextImageDelay (<i>self</i>)</h3><p>For image formats that support animation, this function returns
the number of milliseconds to wait until displaying the next frame
in the animation. If the image format doesn't support animation, 0
is returned.</p>
<p>This function returns -1 if an error occurred.</p>
<p><b>See also</b> <a href="qimagereader.html#supportsAnimation">supportsAnimation</a>(),
<a href="qimageiohandler.html#nextImageDelay">QImageIOHandler.nextImageDelay</a>(),
and <a href="qimagereader.html#canRead">canRead</a>().</p>


<h3 class="fn"><a name="quality" />int QImageReader.quality (<i>self</i>)</h3><p>Returns the quality level of the image.</p>
<p>This function was introduced in Qt 4.2.</p>
<p><b>See also</b> <a href="qimagereader.html#setQuality">setQuality</a>().</p>


<h3 class="fn"><a name="read" /><a href="qimage.html">QImage</a> QImageReader.read (<i>self</i>)</h3><p>Reads an image from the device. On success, the image that was
read is returned; otherwise, a null <a href="qimage.html">QImage</a> is returned. You can then call <a href="qimagereader.html#error">error</a>() to find the type of error
that occurred, or <a href="qimagereader.html#errorString">errorString</a>() to get a human
readable description of the error.</p>
<p>For image formats that support animation, calling read()
repeatedly will return the next frame. When all frames have been
read, a null image will be returned.</p>
<p><b>See also</b> <a href="qimagereader.html#canRead">canRead</a>(), <a href="qimagereader.html#supportedImageFormats">supportedImageFormats</a>(),
<a href="qimagereader.html#supportsAnimation">supportsAnimation</a>(), and
<a href="qmovie.html">QMovie</a>.</p>


<h3 class="fn"><a name="read-2" />bool QImageReader.read (<i>self</i>, <a href="qimage.html">QImage</a>&#160;<i>image</i>)</h3><p>This is an overloaded function.</p>
<p>Reads an image from the device into <i>image</i>, which must
point to a <a href="qimage.html">QImage</a>. Returns true on
success; otherwise, returns false.</p>
<p>If <i>image</i> has same format and size as the image data that
is about to be read, this function may not need to allocate a new
image before reading. Because of this, it can be faster than the
other <a href="qimagereader.html#read">read</a>() overload, which
always constructs a new image; especially when reading several
images with the same format and size.</p>
<pre class="cpp">
 <span class="type"><a href="qimage.html">QImage</a></span> icon(<span class="number">64</span><span class="operator">,</span> <span class="number">64</span><span class="operator">,</span> <span class="type"><a href="qimage.html">QImage</a></span><span class="operator">.</span>Format_RGB32);
 <span class="type"><a href="qimagereader.html">QImageReader</a></span> reader(<span class="string">"icon_64x64.bmp"</span>);
 <span class="keyword">if</span> (reader<span class="operator">.</span>read(<span class="operator">&amp;</span>icon)) {
     <span class="comment">// Display icon</span>
 }
</pre>
<p>For image formats that support animation, calling <a href="qimagereader.html#read">read</a>() repeatedly will return the next
frame. When all frames have been read, a null image will be
returned.</p>
<p><b>See also</b> <a href="qimagereader.html#canRead">canRead</a>(), <a href="qimagereader.html#supportedImageFormats">supportedImageFormats</a>(),
<a href="qimagereader.html#supportsAnimation">supportsAnimation</a>(), and
<a href="qmovie.html">QMovie</a>.</p>


<h3 class="fn"><a name="scaledClipRect" /><a href="qrect.html">QRect</a> QImageReader.scaledClipRect (<i>self</i>)</h3><p>Returns the scaled clip rect of the image.</p>
<p><b>See also</b> <a href="qimagereader.html#setScaledClipRect">setScaledClipRect</a>().</p>


<h3 class="fn"><a name="scaledSize" /><a href="qsize.html">QSize</a> QImageReader.scaledSize (<i>self</i>)</h3><p>Returns the scaled size of the image.</p>
<p><b>See also</b> <a href="qimagereader.html#setScaledSize">setScaledSize</a>().</p>


<h3 class="fn"><a name="setAutoDetectImageFormat" />QImageReader.setAutoDetectImageFormat (<i>self</i>, bool&#160;<i>enabled</i>)</h3><p>If <i>enabled</i> is true, image format autodetection is
enabled; otherwise, it is disabled. By default, autodetection is
enabled.</p>
<p><a href="qimagereader.html">QImageReader</a> uses an extensive
approach to detecting the image format; firstly, if you pass a file
name to <a href="qimagereader.html">QImageReader</a>, it will
attempt to detect the file extension if the given file name does
not point to an existing file, by appending supported default
extensions to the given file name, one at a time. It then uses the
following approach to detect the image format:</p>
<ul>
<li>Image plugins are queried first, based on either the optional
format string, or the file name suffix (if the source device is a
file). No content detection is done at this stage. <a href="qimagereader.html">QImageReader</a> will choose the first plugin
that supports reading for this format.</li>
<li>If no plugin supports the image format, Qt's built-in handlers
are checked based on either the optional format string, or the file
name suffix.</li>
<li>If no capable plugins or built-in handlers are found, each
plugin is tested by inspecting the content of the data stream.</li>
<li>If no plugins could detect the image format based on data
contents, each built-in image handler is tested by inspecting the
contents.</li>
<li>Finally, if all above approaches fail, <a href="qimagereader.html">QImageReader</a> will report failure when
trying to read the image.</li>
</ul>
<p>By disabling image format autodetection, <a href="qimagereader.html">QImageReader</a> will only query the plugins
and built-in handlers based on the format string (i.e., no file
name extensions are tested).</p>
<p><b>See also</b> <a href="qimagereader.html#autoDetectImageFormat">autoDetectImageFormat</a>(),
<a href="qimageiohandler.html#canRead">QImageIOHandler.canRead</a>(), and
<a href="qimageioplugin.html#capabilities">QImageIOPlugin.capabilities</a>().</p>


<h3 class="fn"><a name="setBackgroundColor" />QImageReader.setBackgroundColor (<i>self</i>, <a href="qcolor.html">QColor</a>&#160;<i>color</i>)</h3><p>Sets the background color to <i>color</i>. Image formats that
support this operation are expected to initialize the background to
<i>color</i> before reading an image.</p>
<p>This function was introduced in Qt 4.1.</p>
<p><b>See also</b> <a href="qimagereader.html#backgroundColor">backgroundColor</a>() and
<a href="qimagereader.html#read">read</a>().</p>


<h3 class="fn"><a name="setClipRect" />QImageReader.setClipRect (<i>self</i>, <a href="qrect.html">QRect</a>&#160;<i>rect</i>)</h3><p>Sets the image clip rect (also known as the ROI, or Region Of
Interest) to <i>rect</i>. The coordinates of <i>rect</i> are
relative to the untransformed image size, as returned by <a href="qimagereader.html#size">size</a>().</p>
<p><b>See also</b> <a href="qimagereader.html#clipRect">clipRect</a>(), <a href="qimagereader.html#setScaledSize">setScaledSize</a>(), and <a href="qimagereader.html#setScaledClipRect">setScaledClipRect</a>().</p>


<h3 class="fn"><a name="setDecideFormatFromContent" />QImageReader.setDecideFormatFromContent (<i>self</i>, bool&#160;<i>ignored</i>)</h3><p>If <i>ignored</i> is set to true, then the image reader will
ignore specified formats or file extensions and decide which plugin
to use only based on the contents in the datastream.</p>
<p>Setting this flag means that all image plugins gets loaded. Each
plugin will read the first bytes in the image data and decide if
the plugin is compatible or not.</p>
<p>This also disables auto detecting the image format.</p>
<p><b>See also</b> <a href="qimagereader.html#decideFormatFromContent">decideFormatFromContent</a>().</p>


<h3 class="fn"><a name="setDevice" />QImageReader.setDevice (<i>self</i>, <a href="qiodevice.html">QIODevice</a>&#160;<i>device</i>)</h3><p>Sets <a href="qimagereader.html">QImageReader</a>'s device to
<i>device</i>. If a device has already been set, the old device is
removed from <a href="qimagereader.html">QImageReader</a> and is
otherwise left unchanged.</p>
<p>If the device is not already open, <a href="qimagereader.html">QImageReader</a> will attempt to open the
device in <a href="qiodevice.html#OpenModeFlag-enum">QIODevice.ReadOnly</a> mode by
calling open(). Note that this does not work for certain devices,
such as <a href="qprocess.html">QProcess</a>, <a href="qtcpsocket.html">QTcpSocket</a> and <a href="qudpsocket.html">QUdpSocket</a>, where more logic is required to
open the device.</p>
<p><b>See also</b> <a href="qimagereader.html#device">device</a>()
and <a href="qimagereader.html#setFileName">setFileName</a>().</p>


<h3 class="fn"><a name="setFileName" />QImageReader.setFileName (<i>self</i>, QString&#160;<i>fileName</i>)</h3><p>Sets the file name of <a href="qimagereader.html">QImageReader</a> to <i>fileName</i>.
Internally, <a href="qimagereader.html">QImageReader</a> will
create a <a href="qfile.html">QFile</a> object and open it in
<a href="qiodevice.html#OpenModeFlag-enum">QIODevice.ReadOnly</a>
mode, and use this when reading images.</p>
<p>If <i>fileName</i> does not include a file extension (e.g., .png
or .bmp), <a href="qimagereader.html">QImageReader</a> will cycle
through all supported extensions until it finds a matching
file.</p>
<p><b>See also</b> <a href="qimagereader.html#fileName">fileName</a>(), <a href="qimagereader.html#setDevice">setDevice</a>(), and <a href="qimagereader.html#supportedImageFormats">supportedImageFormats</a>().</p>


<h3 class="fn"><a name="setFormat" />QImageReader.setFormat (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>format</i>)</h3><p>Sets the format <a href="qimagereader.html">QImageReader</a>
will use when reading images, to <i>format</i>. <i>format</i> is a
case insensitive text string. Example:</p>
<pre class="cpp">
 <span class="type"><a href="qimagereader.html">QImageReader</a></span> reader;
 reader<span class="operator">.</span>setFormat(<span class="string">"png"</span>); <span class="comment">// same as reader.setFormat("PNG");</span>
</pre>
<p>You can call <a href="qimagereader.html#supportedImageFormats">supportedImageFormats</a>()
for the full list of formats <a href="qimagereader.html">QImageReader</a> supports.</p>
<p><b>See also</b> <a href="qimagereader.html#format">format</a>().</p>


<h3 class="fn"><a name="setQuality" />QImageReader.setQuality (<i>self</i>, int&#160;<i>quality</i>)</h3><p>This is an image format specific function that sets the quality
level of the image to <i>quality</i>. For image formats that do not
support setting the quality, this value is ignored.</p>
<p>The value range of <i>quality</i> depends on the image format.
For example, the "jpeg" format supports a quality range from 0 (low
quality, high compression) to 100 (high quality, low
compression).</p>
<p>This function was introduced in Qt 4.2.</p>
<p><b>See also</b> <a href="qimagereader.html#quality">quality</a>().</p>


<h3 class="fn"><a name="setScaledClipRect" />QImageReader.setScaledClipRect (<i>self</i>, <a href="qrect.html">QRect</a>&#160;<i>rect</i>)</h3><p>Sets the scaled clip rect to <i>rect</i>. The scaled clip rect
is the clip rect (also known as ROI, or Region Of Interest) that is
applied after the image has been scaled.</p>
<p><b>See also</b> <a href="qimagereader.html#scaledClipRect">scaledClipRect</a>() and
<a href="qimagereader.html#setScaledSize">setScaledSize</a>().</p>


<h3 class="fn"><a name="setScaledSize" />QImageReader.setScaledSize (<i>self</i>, <a href="qsize.html">QSize</a>&#160;<i>size</i>)</h3><p>Sets the scaled size of the image to <i>size</i>. The scaling is
performed after the initial clip rect, but before the scaled clip
rect is applied. The algorithm used for scaling depends on the
image format. By default (i.e., if the image format does not
support scaling), <a href="qimagereader.html">QImageReader</a> will
use QImage.scale() with Qt.SmoothScaling.</p>
<p><b>See also</b> <a href="qimagereader.html#scaledSize">scaledSize</a>(), <a href="qimagereader.html#setClipRect">setClipRect</a>(), and <a href="qimagereader.html#setScaledClipRect">setScaledClipRect</a>().</p>


<h3 class="fn"><a name="size" /><a href="qsize.html">QSize</a> QImageReader.size (<i>self</i>)</h3><p>Returns the size of the image, without actually reading the
image contents.</p>
<p>If the image format does not support this feature, this function
returns an invalid size. Qt's built-in image handlers all support
this feature, but custom image format plugins are not required to
do so.</p>
<p><b>See also</b> <a href="qimageiohandler.html#ImageOption-enum">QImageIOHandler.ImageOption</a>,
<a href="qimageiohandler.html#option">QImageIOHandler.option</a>(), and
<a href="qimageiohandler.html#supportsOption">QImageIOHandler.supportsOption</a>().</p>


<h3 class="fn"><a name="supportedImageFormats" />list-of-QByteArray QImageReader.supportedImageFormats ()</h3><p>Returns the list of image formats supported by <a href="qimagereader.html">QImageReader</a>.</p>
<p>By default, Qt can read the following formats:</p>
<table class="generic">
<thead>
<tr class="qt-style">
<th>Format</th>
<th>Description</th>
</tr>
</thead>
<tr class="odd" valign="top">
<td>BMP</td>
<td>Windows Bitmap</td>
</tr>
<tr class="even" valign="top">
<td>GIF</td>
<td>Graphic Interchange Format (optional)</td>
</tr>
<tr class="odd" valign="top">
<td>JPG</td>
<td>Joint Photographic Experts Group</td>
</tr>
<tr class="even" valign="top">
<td>JPEG</td>
<td>Joint Photographic Experts Group</td>
</tr>
<tr class="odd" valign="top">
<td>MNG</td>
<td>Multiple-image Network Graphics</td>
</tr>
<tr class="even" valign="top">
<td>PNG</td>
<td>Portable Network Graphics</td>
</tr>
<tr class="odd" valign="top">
<td>PBM</td>
<td>Portable Bitmap</td>
</tr>
<tr class="even" valign="top">
<td>PGM</td>
<td>Portable Graymap</td>
</tr>
<tr class="odd" valign="top">
<td>PPM</td>
<td>Portable Pixmap</td>
</tr>
<tr class="even" valign="top">
<td>TIFF</td>
<td>Tagged Image File Format</td>
</tr>
<tr class="odd" valign="top">
<td>XBM</td>
<td>X11 Bitmap</td>
</tr>
<tr class="even" valign="top">
<td>XPM</td>
<td>X11 Pixmap</td>
</tr>
<tr class="odd" valign="top">
<td>SVG</td>
<td>Scalable Vector Graphics</td>
</tr>
<tr class="even" valign="top">
<td>TGA</td>
<td>Targa Image Format</td>
</tr>
</table>
<p>Reading and writing SVG files is supported through Qt's <a href="qtsvg.html">SVG Module</a>.</p>
<p>TGA support only extends to reading non-RLE compressed files. In
particular calls to <a href="http://doc.qt.nokia.com/4.7-snapshot/qimageioplugin.html#capabilities">
capabilities</a> for the tga plugin returns only <a href="qimageioplugin.html#Capability-enum">QImageIOPlugin.CanRead</a>,
not <a href="qimageioplugin.html#Capability-enum">QImageIOPlugin.CanWrite</a>.</p>
<p>To configure Qt with GIF support, pass <tt>-qt-gif</tt> to the
<tt>configure</tt> script or check the appropriate option in the
graphical installer.</p>
<p>Note that the <a href="qapplication.html">QApplication</a>
instance must be created before this function is called.</p>
<p><b>See also</b> <a href="qimagereader.html#setFormat">setFormat</a>(), <a href="qimagewriter.html#supportedImageFormats">QImageWriter.supportedImageFormats</a>(),
and <a href="qimageioplugin.html">QImageIOPlugin</a>.</p>


<h3 class="fn"><a name="supportsAnimation" />bool QImageReader.supportsAnimation (<i>self</i>)</h3><p>Returns true if the image format supports animation; otherwise,
false is returned.</p>
<p>This function was introduced in Qt 4.1.</p>
<p><b>See also</b> <a href="qmovie.html#supportedFormats">QMovie.supportedFormats</a>().</p>


<h3 class="fn"><a name="supportsOption" />bool QImageReader.supportsOption (<i>self</i>, <a href="qimageiohandler.html#ImageOption-enum">QImageIOHandler.ImageOption</a>&#160;<i>option</i>)</h3><p>Returns true if the reader supports <i>option</i>; otherwise
returns false.</p>
<p>Different image formats support different options. Call this
function to determine whether a certain option is supported by the
current format. For example, the PNG format allows you to embed
text into the image's metadata (see <a href="qimagereader.html#text">text</a>()), and the BMP format allows you
to determine the image's size without loading the whole image into
memory (see <a href="qimagereader.html#size">size</a>()).</p>
<pre class="cpp">
 <span class="type"><a href="qimagereader.html">QImageReader</a></span> reader(<span class="string">":/image.png"</span>);
 <span class="keyword">if</span> (reader<span class="operator">.</span>supportsOption(<span class="type"><a href="qimageiohandler.html">QImageIOHandler</a></span><span class="operator">.</span>Size))
     <a href="qtcore.html#qDebug">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"Size:"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> reader<span class="operator">.</span><a href="qimagereader.html#size">size</a>();
</pre>
<p>This function was introduced in Qt 4.2.</p>
<p><b>See also</b> <a href="qimagewriter.html#supportsOption">QImageWriter.supportsOption</a>().</p>


<h3 class="fn"><a name="text" />QString QImageReader.text (<i>self</i>, QString&#160;<i>key</i>)</h3><p>Returns the image text associated with <i>key</i>.</p>
<p>Support for this option is implemented through <a href="qimageiohandler.html#ImageOption-enum">QImageIOHandler.Description</a>.</p>
<p>This function was introduced in Qt 4.1.</p>
<p><b>See also</b> <a href="qimagereader.html#textKeys">textKeys</a>() and <a href="qimagewriter.html#setText">QImageWriter.setText</a>().</p>


<h3 class="fn"><a name="textKeys" />QStringList QImageReader.textKeys (<i>self</i>)</h3><p>Returns the text keys for this image. You can use these keys
with <a href="qimagereader.html#text">text</a>() to list the image
text for a certain key.</p>
<p>Support for this option is implemented through <a href="qimageiohandler.html#ImageOption-enum">QImageIOHandler.Description</a>.</p>
<p>This function was introduced in Qt 4.1.</p>
<p><b>See also</b> <a href="qimagereader.html#text">text</a>(),
<a href="qimagewriter.html#setText">QImageWriter.setText</a>(),
and <a href="qimage.html#textKeys">QImage.textKeys</a>().</p>
<address><hr /><div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address"><td align="left" width="25%">PyQt&#160;4.10 for Windows</td><td align="center" width="50%">Copyright &#169; <a href="http://www.riverbankcomputing.com">Riverbank&#160;Computing&#160;Ltd</a> and <a href="http://www.qtsoftware.com">Nokia</a> 2012</td><td align="right" width="25%">Qt&#160;4.8.4</td></tr></table></div></address></body></html>