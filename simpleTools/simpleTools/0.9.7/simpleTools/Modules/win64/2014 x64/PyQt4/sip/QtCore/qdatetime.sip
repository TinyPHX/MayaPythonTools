// qdatetime.sip generated by MetaSIP on Fri Mar  1 21:45:57 2013
//
// This file is part of the QtCore Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// If you are unsure which license is appropriate for your use, please
// contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%ModuleCode
#include <qdatetime.h>
%End

class QDate
{
%TypeHeaderCode
#include <qdatetime.h>
%End

%TypeCode
#include <QHash>

#if PY_VERSION_HEX >= 0x02040000
#include <datetime.h>
#endif
%End

%ConvertToTypeCode
#if PY_VERSION_HEX >= 0x02040000
    if (!PyDateTimeAPI)
        PyDateTime_IMPORT;
#endif

// Allow a Python date object whenever a QDate is expected.

if (sipIsErr == NULL)
    return (
#if PY_VERSION_HEX >= 0x02040000
            PyDate_Check(sipPy) ||
#endif
            sipCanConvertToType(sipPy, sipType_QDate, SIP_NO_CONVERTORS));

#if PY_VERSION_HEX >= 0x02040000
if (PyDate_Check(sipPy))
{
    *sipCppPtr = new QDate(PyDateTime_GET_YEAR(sipPy),
                           PyDateTime_GET_MONTH(sipPy),
                           PyDateTime_GET_DAY(sipPy));

    return sipGetState(sipTransferObj);
}
#endif

*sipCppPtr = reinterpret_cast<QDate *>(sipConvertToType(sipPy, sipType_QDate, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));

return 0;
%End

%PickleCode
    sipRes = Py_BuildValue((char *)"iii", sipCpp->year(), sipCpp->month(), sipCpp->day());
%End

public:
    QDate();
    QDate(int y, int m, int d);
    SIP_PYOBJECT __repr__() const /DocType="str"/;
%MethodCode
        if (sipCpp->isNull())
        {
        #if PY_MAJOR_VERSION >= 3
            sipRes = PyUnicode_FromString("PyQt4.QtCore.QDate()");
        #else
            sipRes = PyString_FromString("PyQt4.QtCore.QDate()");
        #endif
        }
        else
        {
            sipRes =
        #if PY_MAJOR_VERSION >= 3
                PyUnicode_FromFormat
        #else
                PyString_FromFormat
        #endif
                    ("PyQt4.QtCore.QDate(%i, %i, %i)", sipCpp->year(),
                    sipCpp->month(), sipCpp->day());
        }
%End

    long __hash__() const;
%MethodCode
        if (sipIsAPIEnabled("QDate", 2, 0))
        {
            sipRes = qHash(sipCpp->toString(Qt::ISODate));
        }
        else
        {
            // Mimic Python's default behavour.
            sipRes = _Py_HashPointer(sipSelf);
        }
%End

%If (Py_DateTime)
    SIP_PYOBJECT toPyDate() const /DocType="datetime.date"/;
%MethodCode
        if (!PyDateTimeAPI)
            PyDateTime_IMPORT;
        
        // Convert to a Python date object.
        sipRes = PyDate_FromDate(sipCpp->year(), sipCpp->month(), sipCpp->day());
%End

%End
    bool isNull() const;
    int __bool__() const;
%MethodCode
        sipRes = !sipCpp->isNull();
%End

    bool isValid() const;
    int year() const;
    int month() const;
    int day() const;
    int dayOfWeek() const;
    int dayOfYear() const;
    int daysInMonth() const;
    int daysInYear() const;
    int weekNumber(int *yearNumber = 0) const;
%If (Qt_5_0_0 -)
    static QString shortMonthName(int month, QDate::MonthNameType type = QDate::DateFormat);
%End
%If (- Qt_5_0_0)
    static QString shortMonthName(int month);
%End
%If (Qt_4_5_0 - Qt_5_0_0)
    static QString shortMonthName(int month, QDate::MonthNameType type);
%End
%If (Qt_5_0_0 -)
    static QString shortDayName(int weekday, QDate::MonthNameType type = QDate::DateFormat);
%End
%If (- Qt_5_0_0)
    static QString shortDayName(int weekday);
%End
%If (Qt_4_5_0 - Qt_5_0_0)
    static QString shortDayName(int weekday, QDate::MonthNameType type);
%End
%If (Qt_5_0_0 -)
    static QString longMonthName(int month, QDate::MonthNameType type = QDate::DateFormat);
%End
%If (- Qt_5_0_0)
    static QString longMonthName(int month);
%End
%If (Qt_4_5_0 - Qt_5_0_0)
    static QString longMonthName(int month, QDate::MonthNameType type);
%End
%If (Qt_5_0_0 -)
    static QString longDayName(int weekday, QDate::MonthNameType type = QDate::DateFormat);
%End
%If (- Qt_5_0_0)
    static QString longDayName(int weekday);
%End
%If (Qt_4_5_0 - Qt_5_0_0)
    static QString longDayName(int weekday, QDate::MonthNameType type);
%End
    QString toString(Qt::DateFormat format = Qt::TextDate) const;
    QString toString(const QString &format) const;
%If (PyQt_Deprecated_5_0)
    bool setYMD(int y, int m, int d);
%End
%If (Qt_5_0_0 -)
    QDate addDays(qint64 days) const;
%End
%If (- Qt_5_0_0)
    QDate addDays(int days) const;
%End
    QDate addMonths(int months) const;
    QDate addYears(int years) const;
%If (Qt_5_0_0 -)
    qint64 daysTo(const QDate &) const;
%End
%If (- Qt_5_0_0)
    int daysTo(const QDate &) const;
%End
    bool operator==(const QDate &other) const;
    bool operator!=(const QDate &other) const;
    bool operator<(const QDate &other) const;
    bool operator<=(const QDate &other) const;
    bool operator>(const QDate &other) const;
    bool operator>=(const QDate &other) const;
    static QDate currentDate();
    static QDate fromString(const QString &string, Qt::DateFormat format = Qt::TextDate);
    static QDate fromString(const QString &s, const QString &format);
    static bool isValid(int y, int m, int d);
    static bool isLeapYear(int year);
%If (- Qt_5_0_0)
    static uint gregorianToJulian(int y, int m, int d);
%End
%If (- Qt_5_0_0)
    static void julianToGregorian(uint jd, int &y, int &m, int &d);
%End
%If (Qt_5_0_0 -)
    static QDate fromJulianDay(qint64 jd);
%End
%If (- Qt_5_0_0)
    static QDate fromJulianDay(int jd);
%End
%If (Qt_5_0_0 -)
    qint64 toJulianDay() const;
%End
%If (- Qt_5_0_0)
    int toJulianDay() const;
%End
%If (Qt_4_2_0 -)
    bool setDate(int year, int month, int date);
%End
%If (Qt_4_5_0 -)
    void getDate(int *year, int *month, int *day);
%End
%If (Qt_4_5_0 -)

    enum MonthNameType
    {
        DateFormat,
        StandaloneFormat,
    };

%End
};

class QTime
{
%TypeHeaderCode
#include <qdatetime.h>
%End

%TypeCode
#include <QHash>

#if PY_VERSION_HEX >= 0x02040000
#include <datetime.h>
#endif
%End

%ConvertToTypeCode
#if PY_VERSION_HEX >= 0x02040000
    if (!PyDateTimeAPI)
        PyDateTime_IMPORT;
#endif

// Allow a Python time object whenever a QTime is expected.

if (sipIsErr == NULL)
    return (
#if PY_VERSION_HEX >= 0x02040000
            PyTime_Check(sipPy) ||
#endif
            sipCanConvertToType(sipPy, sipType_QTime, SIP_NO_CONVERTORS));

#if PY_VERSION_HEX >= 0x02040000
if (PyTime_Check(sipPy))
{
    *sipCppPtr = new QTime(PyDateTime_TIME_GET_HOUR(sipPy),
                           PyDateTime_TIME_GET_MINUTE(sipPy),
                           PyDateTime_TIME_GET_SECOND(sipPy),
                           PyDateTime_TIME_GET_MICROSECOND(sipPy) / 1000);

    return sipGetState(sipTransferObj);
}
#endif

*sipCppPtr = reinterpret_cast<QTime *>(sipConvertToType(sipPy, sipType_QTime, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));

return 0;
%End

%PickleCode
    sipRes = Py_BuildValue((char *)"iiii", sipCpp->hour(), sipCpp->minute(), sipCpp->second(), sipCpp->msec());
%End

public:
    QTime();
    QTime(int h, int m, int second = 0, int msec = 0);
    SIP_PYOBJECT __repr__() const /DocType="str"/;
%MethodCode
        if (sipCpp->isNull())
        {
        #if PY_MAJOR_VERSION >= 3
            sipRes = PyUnicode_FromString("PyQt4.QtCore.QTime()");
        #else
            sipRes = PyString_FromString("PyQt4.QtCore.QTime()");
        #endif
        }
        else
        {
        #if PY_MAJOR_VERSION >= 3
            sipRes = PyUnicode_FromFormat("PyQt4.QtCore.QTime(%i, %i", sipCpp->hour(),
                    sipCpp->minute());
        
            if (sipCpp->second() || sipCpp->msec())
            {
                qpycore_Unicode_ConcatAndDel(&sipRes,
                        PyUnicode_FromFormat(", %i", sipCpp->second()));
        
                if (sipCpp->msec())
                    qpycore_Unicode_ConcatAndDel(&sipRes,
                            PyUnicode_FromFormat(", %i", sipCpp->msec()));
            }
        
            qpycore_Unicode_ConcatAndDel(&sipRes, PyUnicode_FromString(")"));
        #else
            sipRes = PyString_FromFormat("PyQt4.QtCore.QTime(%i, %i", sipCpp->hour(),
                    sipCpp->minute());
        
            if (sipCpp->second() || sipCpp->msec())
            {
                PyString_ConcatAndDel(&sipRes,
                        PyString_FromFormat(", %i", sipCpp->second()));
        
                if (sipCpp->msec())
                    PyString_ConcatAndDel(&sipRes,
                            PyString_FromFormat(", %i", sipCpp->msec()));
            }
        
            PyString_ConcatAndDel(&sipRes, PyString_FromString(")"));
        #endif
        }
%End

    long __hash__() const;
%MethodCode
        if (sipIsAPIEnabled("QTime", 2, 0))
        {
            sipRes = qHash(sipCpp->toString(Qt::ISODate));
        }
        else
        {
            // Mimic Python's default behavour.
            sipRes = _Py_HashPointer(sipSelf);
        }
%End

%If (Py_DateTime)
    SIP_PYOBJECT toPyTime() const /DocType="datetime.time"/;
%MethodCode
        if (!PyDateTimeAPI)
            PyDateTime_IMPORT;
        
        // Convert to a Python time object.
        sipRes = PyTime_FromTime(sipCpp->hour(), sipCpp->minute(), sipCpp->second(), sipCpp->msec() * 1000);
%End

%End
    bool isNull() const;
    int __bool__() const;
%MethodCode
        sipRes = !sipCpp->isNull();
%End

    bool isValid() const;
    int hour() const;
    int minute() const;
    int second() const;
    int msec() const;
    QString toString(Qt::DateFormat format = Qt::TextDate) const;
    QString toString(const QString &format) const;
    bool setHMS(int h, int m, int s, int msec = 0);
    QTime addSecs(int secs) const;
    int secsTo(const QTime &) const;
    QTime addMSecs(int ms) const;
    int msecsTo(const QTime &) const;
    bool operator==(const QTime &other) const;
    bool operator!=(const QTime &other) const;
    bool operator<(const QTime &other) const;
    bool operator<=(const QTime &other) const;
    bool operator>(const QTime &other) const;
    bool operator>=(const QTime &other) const;
    static QTime currentTime();
    static QTime fromString(const QString &string, Qt::DateFormat format = Qt::TextDate);
    static QTime fromString(const QString &s, const QString &format);
    static bool isValid(int h, int m, int s, int msec = 0);
    void start();
    int restart();
    int elapsed() const;
};

class QDateTime
{
%TypeHeaderCode
#include <qdatetime.h>
%End

%TypeCode
#include <QHash>

#if PY_VERSION_HEX >= 0x02040000
#include <datetime.h>
#endif
%End

%ConvertToTypeCode
#if PY_VERSION_HEX >= 0x02040000
    if (!PyDateTimeAPI)
        PyDateTime_IMPORT;
#endif

// Allow a Python datetime object whenever a QDateTime is expected.

if (sipIsErr == NULL)
    return (
#if PY_VERSION_HEX >= 0x02040000
            PyDateTime_Check(sipPy) ||
#endif
            sipCanConvertToType(sipPy, sipType_QDateTime, SIP_NO_CONVERTORS));

#if PY_VERSION_HEX >= 0x02040000
if (PyDateTime_Check(sipPy))
{
    QDate qdate(PyDateTime_GET_YEAR(sipPy),
                PyDateTime_GET_MONTH(sipPy),
                PyDateTime_GET_DAY(sipPy));

    QTime qtime(PyDateTime_DATE_GET_HOUR(sipPy),
                PyDateTime_DATE_GET_MINUTE(sipPy),
                PyDateTime_DATE_GET_SECOND(sipPy),
                PyDateTime_DATE_GET_MICROSECOND(sipPy) / 1000);

    QDateTime *qdt = new QDateTime(qdate, qtime);

    *sipCppPtr = qdt;

    return sipGetState(sipTransferObj);
}
#endif

*sipCppPtr = reinterpret_cast<QDateTime *>(sipConvertToType(sipPy, sipType_QDateTime, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));

return 0;
%End

%PickleCode
    QDate qd = sipCpp->date();
    QTime qt = sipCpp->time();
    
    sipRes = Py_BuildValue((char *)"iiiiiiii", qd.year(), qd.month(), qd.day(),
            qt.hour(), qt.minute(), qt.second(), qt.msec(),
            (int)sipCpp->timeSpec());
%End

public:
    QDateTime();
    QDateTime(const QDateTime &other);
    explicit QDateTime(const QDate &);
    QDateTime(const QDate &date, const QTime &time, Qt::TimeSpec timeSpec = Qt::LocalTime);
    QDateTime(int y, int m, int d, int h, int m, int s = 0, int msec = 0, int timeSpec = 0) /NoDerived/;
%MethodCode
        // This ctor is mainly supplied to allow pickling.
        QDate qd(a0, a1, a2);
        QTime qt(a3, a4, a5, a6);
        
        sipCpp = new QDateTime(qd, qt, (Qt::TimeSpec)a7);
%End

    ~QDateTime();
    SIP_PYOBJECT __repr__() const /DocType="str"/;
%MethodCode
        if (sipCpp->isNull())
        {
        #if PY_MAJOR_VERSION >= 3
            sipRes = PyUnicode_FromString("PyQt4.QtCore.QDateTime()");
        #else
            sipRes = PyString_FromString("PyQt4.QtCore.QDateTime()");
        #endif
        }
        else
        {
            QDate qd = sipCpp->date();
            QTime qt = sipCpp->time();
        
        #if PY_MAJOR_VERSION >= 3
            sipRes = PyUnicode_FromFormat("PyQt4.QtCore.QDateTime(%i, %i, %i, %i, %i",
                    qd.year(), qd.month(), qd.day(), qt.hour(), qt.minute());
        
            if (qt.second() || qt.msec() || sipCpp->timeSpec() != Qt::LocalTime)
            {
                qpycore_Unicode_ConcatAndDel(&sipRes,
                        PyUnicode_FromFormat(", %i", qt.second()));
        
                if (qt.msec() || sipCpp->timeSpec() != Qt::LocalTime)
                {
                    qpycore_Unicode_ConcatAndDel(&sipRes,
                            PyUnicode_FromFormat(", %i", qt.msec()));
        
                    if (sipCpp->timeSpec() != Qt::LocalTime)
                        qpycore_Unicode_ConcatAndDel(&sipRes,
                                PyUnicode_FromFormat(", PyQt4.QtCore.Qt.TimeSpec(%i)",
                                        (int)sipCpp->timeSpec()));
                }
            }
        
            qpycore_Unicode_ConcatAndDel(&sipRes, PyUnicode_FromString(")"));
        #else
            sipRes = PyString_FromFormat("PyQt4.QtCore.QDateTime(%i, %i, %i, %i, %i",
                    qd.year(), qd.month(), qd.day(), qt.hour(), qt.minute());
        
            if (qt.second() || qt.msec() || sipCpp->timeSpec() != Qt::LocalTime)
            {
                PyString_ConcatAndDel(&sipRes,
                        PyString_FromFormat(", %i", qt.second()));
        
                if (qt.msec() || sipCpp->timeSpec() != Qt::LocalTime)
                {
                    PyString_ConcatAndDel(&sipRes,
                            PyString_FromFormat(", %i", qt.msec()));
        
                    if (sipCpp->timeSpec() != Qt::LocalTime)
                        PyString_ConcatAndDel(&sipRes,
                                PyString_FromFormat(", PyQt4.QtCore.Qt.TimeSpec(%i)",
                                        (int)sipCpp->timeSpec()));
                }
            }
        
            PyString_ConcatAndDel(&sipRes, PyString_FromString(")"));
        #endif
        }
%End

    long __hash__() const;
%MethodCode
        if (sipIsAPIEnabled("QDateTime", 2, 0))
        {
            sipRes = qHash(sipCpp->toString(Qt::ISODate));
        }
        else
        {
            // Mimic Python's default behavour.
            sipRes = _Py_HashPointer(sipSelf);
        }
%End

%If (Py_DateTime)
    SIP_PYOBJECT toPyDateTime() const /DocType="datetime.datetime"/;
%MethodCode
        if (!PyDateTimeAPI)
            PyDateTime_IMPORT;
        
        // Convert to a Python datetime object.
        QDate qd = sipCpp->date();
        QTime qt = sipCpp->time();
        
        sipRes = PyDateTime_FromDateAndTime(qd.year(), qd.month(), qd.day(),
                                            qt.hour(), qt.minute(), qt.second(), qt.msec() * 1000);
%End

%End
    bool isNull() const;
    int __bool__() const;
%MethodCode
        sipRes = !sipCpp->isNull();
%End

    bool isValid() const;
    QDate date() const;
    QTime time() const;
    Qt::TimeSpec timeSpec() const;
    uint toTime_t() const;
    void setDate(const QDate &date);
    void setTime(const QTime &time);
    void setTimeSpec(Qt::TimeSpec spec);
    void setTime_t(uint secsSince1Jan1970UTC);
    QString toString(Qt::DateFormat format = Qt::TextDate) const;
    QString toString(const QString &format) const;
%If (Qt_5_0_0 -)
    QDateTime addDays(qint64 days) const;
%End
%If (- Qt_5_0_0)
    QDateTime addDays(int days) const;
%End
    QDateTime addMonths(int months) const;
    QDateTime addYears(int years) const;
%If (Qt_5_0_0 -)
    QDateTime addSecs(qint64 secs) const;
%End
%If (- Qt_5_0_0)
    QDateTime addSecs(int secs) const;
%End
    QDateTime addMSecs(qint64 msecs) const;
    QDateTime toTimeSpec(Qt::TimeSpec spec) const;
    QDateTime toLocalTime() const;
    QDateTime toUTC() const;
%If (Qt_5_0_0 -)
    qint64 daysTo(const QDateTime &) const;
%End
%If (- Qt_5_0_0)
    int daysTo(const QDateTime &) const;
%End
%If (Qt_5_0_0 -)
    qint64 secsTo(const QDateTime &) const;
%End
%If (- Qt_5_0_0)
    int secsTo(const QDateTime &) const;
%End
    bool operator==(const QDateTime &other) const;
    bool operator!=(const QDateTime &other) const;
    bool operator<(const QDateTime &other) const;
    bool operator<=(const QDateTime &other) const;
    bool operator>(const QDateTime &other) const;
    bool operator>=(const QDateTime &other) const;
    static QDateTime currentDateTime();
    static QDateTime fromString(const QString &string, Qt::DateFormat format = Qt::TextDate);
    static QDateTime fromString(const QString &s, const QString &format);
%If (Qt_4_2_0 -)
    static QDateTime fromTime_t(uint secsSince1Jan1970UTC);
%End
%If (Qt_4_7_0 -)
    qint64 toMSecsSinceEpoch() const;
%End
%If (Qt_4_7_0 -)
    void setMSecsSinceEpoch(qint64 msecs);
%End
%If (Qt_4_7_0 -)
    qint64 msecsTo(const QDateTime &) const;
%End
%If (Qt_4_7_0 -)
    static QDateTime currentDateTimeUtc();
%End
%If (Qt_4_7_0 -)
    static QDateTime fromMSecsSinceEpoch(qint64 msecs);
%End
%If (Qt_4_7_0 -)
    static qint64 currentMSecsSinceEpoch();
%End
%If (Qt_5_0_0 -)
    void swap(QDateTime &other);
%End
};

QDataStream &operator<<(QDataStream &, const QDate & /Constrained/);
QDataStream &operator>>(QDataStream &, QDate & /Constrained/);
QDataStream &operator<<(QDataStream &, const QTime & /Constrained/);
QDataStream &operator>>(QDataStream &, QTime & /Constrained/);
QDataStream &operator<<(QDataStream &, const QDateTime & /Constrained/);
QDataStream &operator>>(QDataStream &, QDateTime & /Constrained/);
