<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html><head><title>QGLPixelBuffer Class Reference</title><style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style></head><body><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr /><td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" width="32" /></td><td width="1">&#160;&#160;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&#160;&#183; <a href="classes.html"><font color="#004faf">All Classes</font></a>&#160;&#183; <a href="modules.html"><font color="#004faf">Modules</font></a></td></table><h1 align="center">QGLPixelBuffer Class Reference<br /><sup><sup>[<a href="qtopengl.html">QtOpenGL</a> module]</sup></sup></h1><p>The QGLPixelBuffer class encapsulates an OpenGL pbuffer.
<a href="#details">More...</a></p>

<p>Inherits <a href="qpaintdevice.html">QPaintDevice</a>.</p><h3>Methods</h3><ul><li><div class="fn" /><b><a href="qglpixelbuffer.html#QGLPixelBuffer">__init__</a></b> (<i>self</i>, QSize&#160;<i>size</i>, QGLFormat&#160;<i>format</i>&#160;=&#160;QGLFormat.defaultFormat(), QGLWidget&#160;<i>shareWidget</i>&#160;=&#160;None)</li><li><div class="fn" /><b><a href="qglpixelbuffer.html#QGLPixelBuffer-2">__init__</a></b> (<i>self</i>, int&#160;<i>width</i>, int&#160;<i>height</i>, QGLFormat&#160;<i>format</i>&#160;=&#160;QGLFormat.defaultFormat(), QGLWidget&#160;<i>shareWidget</i>&#160;=&#160;None)</li><li><div class="fn" />int <b><a href="qglpixelbuffer.html#bindTexture">bindTexture</a></b> (<i>self</i>, QImage&#160;<i>image</i>, int&#160;<i>target</i>&#160;=&#160;GL_TEXTURE_2D)</li><li><div class="fn" />int <b><a href="qglpixelbuffer.html#bindTexture-2">bindTexture</a></b> (<i>self</i>, QPixmap&#160;<i>pixmap</i>, int&#160;<i>target</i>&#160;=&#160;GL_TEXTURE_2D)</li><li><div class="fn" />int <b><a href="qglpixelbuffer.html#bindTexture-3">bindTexture</a></b> (<i>self</i>, QString&#160;<i>fileName</i>)</li><li><div class="fn" />bool <b><a href="qglpixelbuffer.html#bindToDynamicTexture">bindToDynamicTexture</a></b> (<i>self</i>, int&#160;<i>texture</i>)</li><li><div class="fn" /><b><a href="qglpixelbuffer.html#deleteTexture">deleteTexture</a></b> (<i>self</i>, int&#160;<i>texture_id</i>)</li><li><div class="fn" />int <b><a href="qglpixelbuffer.html#devType">devType</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qglpixelbuffer.html#doneCurrent">doneCurrent</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qglpixelbuffer.html#drawTexture">drawTexture</a></b> (<i>self</i>, QRectF&#160;<i>target</i>, int&#160;<i>textureId</i>, int&#160;<i>textureTarget</i>&#160;=&#160;GL_TEXTURE_2D)</li><li><div class="fn" /><b><a href="qglpixelbuffer.html#drawTexture-2">drawTexture</a></b> (<i>self</i>, QPointF&#160;<i>point</i>, int&#160;<i>textureId</i>, int&#160;<i>textureTarget</i>&#160;=&#160;GL_TEXTURE_2D)</li><li><div class="fn" />QGLFormat <b><a href="qglpixelbuffer.html#format">format</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qglpixelbuffer.html#generateDynamicTexture">generateDynamicTexture</a></b> (<i>self</i>)</li><li><div class="fn" />sip.voidptr <b><a href="qglpixelbuffer.html#handle">handle</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qglpixelbuffer.html#isValid">isValid</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qglpixelbuffer.html#makeCurrent">makeCurrent</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qglpixelbuffer.html#metric">metric</a></b> (<i>self</i>, QPaintDevice.PaintDeviceMetric&#160;<i>metric</i>)</li><li><div class="fn" />QPaintEngine <b><a href="qglpixelbuffer.html#paintEngine">paintEngine</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qglpixelbuffer.html#releaseFromDynamicTexture">releaseFromDynamicTexture</a></b> (<i>self</i>)</li><li><div class="fn" />QSize <b><a href="qglpixelbuffer.html#size">size</a></b> (<i>self</i>)</li><li><div class="fn" />QImage <b><a href="qglpixelbuffer.html#toImage">toImage</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qglpixelbuffer.html#updateDynamicTexture">updateDynamicTexture</a></b> (<i>self</i>, int&#160;<i>texture_id</i>)</li></ul><h3>Static Methods</h3><ul><li><div class="fn" />bool <b><a href="qglpixelbuffer.html#hasOpenGLPbuffers">hasOpenGLPbuffers</a></b> ()</li></ul><a name="details" /><hr /><h2>Detailed Description</h2><p>The QGLPixelBuffer class encapsulates an OpenGL pbuffer.</p>
<p>Rendering into a pbuffer is normally done using full hardware
acceleration. This can be significantly faster than rendering into
a <a href="qpixmap.html">QPixmap</a>.</p>
<p>There are three approaches to using this class:</p>
<ol class="1">
<li><b>We can draw into the pbuffer and convert it to a <a href="qimage.html">QImage</a> using <a href="qglpixelbuffer.html#toImage">toImage</a>().</b> This is normally
much faster than calling <a href="qglwidget.html#renderPixmap">QGLWidget.renderPixmap</a>().</li>
<li><b>We can draw into the pbuffer and copy the contents into an
OpenGL texture using <a href="qglpixelbuffer.html#updateDynamicTexture">updateDynamicTexture</a>().</b>
This allows us to create dynamic textures and works on all systems
with pbuffer support.</li>
<li><b>On systems that support it, we can bind the pbuffer to an
OpenGL texture.</b> The texture is then updated automatically when
the pbuffer contents change, eliminating the need for additional
copy operations. This is supported only on Windows and Mac OS X
systems that provide the <tt>render_texture</tt> extension. Note
that under Windows, a multi-sampled pbuffer can't be used in
conjunction with the <tt>render_texture</tt> extension. If a
multi-sampled pbuffer is requested under Windows, the
<tt>render_texture</tt> extension is turned off for that
pbuffer.</li>
</ol>
<a id="threading" name="threading" />
<h3>Threading</h3>
<p>As of Qt 4.8, it's possible to render into a QGLPixelBuffer
using a <a href="qpainter.html">QPainter</a> in a separate thread.
Note that OpenGL 2.0 or OpenGL ES 2.0 is required for this to work.
Also, under X11, it's necessary to set the <a href="qt.html#ApplicationAttribute-enum">Qt.AA_X11InitThreads</a>
application attribute.</p>
<p>Pbuffers are provided by the OpenGL <tt>pbuffer</tt> extension;
call hasOpenGLPbuffer() to find out if the system provides
pbuffers.</p>
<hr /><h2>Method Documentation</h2><h3 class="fn"><a name="QGLPixelBuffer" />QGLPixelBuffer.__init__ (<i>self</i>, <a href="qsize.html">QSize</a>&#160;<i>size</i>, <a href="qglformat.html">QGLFormat</a>&#160;<i>format</i>&#160;=&#160;QGLFormat.defaultFormat(), <a href="qglwidget.html">QGLWidget</a>&#160;<i>shareWidget</i>&#160;=&#160;None)</h3><p>Constructs an OpenGL pbuffer of the given <i>size</i>. If no
<i>format</i> is specified, the <a href="qglformat.html#defaultFormat">default format</a> is used. If the
<i>shareWidget</i> parameter points to a valid <a href="qglwidget.html">QGLWidget</a>, the pbuffer will share its context
with <i>shareWidget</i>.</p>
<p>If you intend to bind this pbuffer as a dynamic texture, the
width and height components of <tt>size</tt> must be powers of two
(e.g., 512 x 128).</p>
<p><b>See also</b> <a href="qglpixelbuffer.html#size">size</a>()
and <a href="qglpixelbuffer.html#format">format</a>().</p>


<h3 class="fn"><a name="QGLPixelBuffer-2" />QGLPixelBuffer.__init__ (<i>self</i>, int&#160;<i>width</i>, int&#160;<i>height</i>, <a href="qglformat.html">QGLFormat</a>&#160;<i>format</i>&#160;=&#160;QGLFormat.defaultFormat(), <a href="qglwidget.html">QGLWidget</a>&#160;<i>shareWidget</i>&#160;=&#160;None)</h3><p>This is an overloaded function.</p>
<p>Constructs an OpenGL pbuffer with the <i>width</i> and
<i>height</i>. If no <i>format</i> is specified, the <a href="qglformat.html#defaultFormat">default format</a> is used. If the
<i>shareWidget</i> parameter points to a valid <a href="qglwidget.html">QGLWidget</a>, the pbuffer will share its context
with <i>shareWidget</i>.</p>
<p>If you intend to bind this pbuffer as a dynamic texture, the
width and height components of <tt>size</tt> must be powers of two
(e.g., 512 x 128).</p>
<p><b>See also</b> <a href="qglpixelbuffer.html#size">size</a>()
and <a href="qglpixelbuffer.html#format">format</a>().</p>


<h3 class="fn"><a name="bindTexture" />int QGLPixelBuffer.bindTexture (<i>self</i>, <a href="qimage.html">QImage</a>&#160;<i>image</i>, int&#160;<i>target</i>&#160;=&#160;GL_TEXTURE_2D)</h3><p>Generates and binds a 2D GL texture to the current context,
based on <i>image</i>. The generated texture id is returned and can
be used in later glBindTexture() calls.</p>
<p>The <i>target</i> parameter specifies the texture target.</p>
<p>Equivalent to calling <a href="qglcontext.html#bindTexture">QGLContext.bindTexture</a>().</p>
<p><b>See also</b> <a href="qglpixelbuffer.html#deleteTexture">deleteTexture</a>().</p>


<h3 class="fn"><a name="bindTexture-2" />int QGLPixelBuffer.bindTexture (<i>self</i>, <a href="qpixmap.html">QPixmap</a>&#160;<i>pixmap</i>, int&#160;<i>target</i>&#160;=&#160;GL_TEXTURE_2D)</h3><p>This is an overloaded function.</p>
<p>Generates and binds a 2D GL texture based on <i>pixmap</i>.</p>
<p>Equivalent to calling <a href="qglcontext.html#bindTexture">QGLContext.bindTexture</a>().</p>
<p><b>See also</b> <a href="qglpixelbuffer.html#deleteTexture">deleteTexture</a>().</p>


<h3 class="fn"><a name="bindTexture-3" />int QGLPixelBuffer.bindTexture (<i>self</i>, QString&#160;<i>fileName</i>)</h3><p>This is an overloaded function.</p>
<p>Reads the DirectDrawSurface (DDS) compressed file
<i>fileName</i> and generates a 2D GL texture from it.</p>
<p>Equivalent to calling <a href="qglcontext.html#bindTexture">QGLContext.bindTexture</a>().</p>
<p><b>See also</b> <a href="qglpixelbuffer.html#deleteTexture">deleteTexture</a>().</p>


<h3 class="fn"><a name="bindToDynamicTexture" />bool QGLPixelBuffer.bindToDynamicTexture (<i>self</i>, int&#160;<i>texture</i>)</h3><p>Binds the texture specified by <i>texture_id</i> to this
pbuffer. Returns true on success; otherwise returns false.</p>
<p>The texture must be of the same size and format as the
pbuffer.</p>
<p>To unbind the texture, call <a href="qglpixelbuffer.html#releaseFromDynamicTexture">releaseFromDynamicTexture</a>().
While the texture is bound, it is updated automatically when the
pbuffer contents change, eliminating the need for additional copy
operations.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qglpixelbuffer.html">QGLPixelBuffer</a></span> pbuffer(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 pbuffer<span class="operator">.</span><a href="qglpixelbuffer.html#makeCurrent">makeCurrent</a>();
 GLuint dynamicTexture <span class="operator">=</span> pbuffer<span class="operator">.</span><a href="qglpixelbuffer.html#generateDynamicTexture">generateDynamicTexture</a>();
 pbuffer<span class="operator">.</span>bindToDynamicTexture(dynamicTexture);
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 pbuffer<span class="operator">.</span><a href="qglpixelbuffer.html#releaseFromDynamicTexture">releaseFromDynamicTexture</a>();
</pre>
<p><b>Warning:</b> This function uses the <tt>render_texture</tt>
extension, which is currently not supported under X11. An
alternative that works on all systems (including X11) is to
manually copy the pbuffer contents to a texture using <a href="qglpixelbuffer.html#updateDynamicTexture">updateDynamicTexture</a>().</p>
<p><b>Warning:</b> For the bindToDynamicTexture() call to succeed
on the Mac OS X, the pbuffer needs a shared context, i.e. the
<a href="qglpixelbuffer.html">QGLPixelBuffer</a> must be created
with a share widget.</p>
<p><b>See also</b> <a href="qglpixelbuffer.html#generateDynamicTexture">generateDynamicTexture</a>()
and <a href="qglpixelbuffer.html#releaseFromDynamicTexture">releaseFromDynamicTexture</a>().</p>


<h3 class="fn"><a name="deleteTexture" />QGLPixelBuffer.deleteTexture (<i>self</i>, int&#160;<i>texture_id</i>)</h3><p>Removes the texture identified by <i>texture_id</i> from the
texture cache.</p>
<p>Equivalent to calling <a href="qglcontext.html#deleteTexture">QGLContext.deleteTexture</a>().</p>


<h3 class="fn"><a name="devType" />int QGLPixelBuffer.devType (<i>self</i>)</h3><h3 class="fn"><a name="doneCurrent" />bool QGLPixelBuffer.doneCurrent (<i>self</i>)</h3><p>Makes no context the current OpenGL context. Returns true on
success; otherwise returns false.</p>


<h3 class="fn"><a name="drawTexture" />QGLPixelBuffer.drawTexture (<i>self</i>, <a href="qrectf.html">QRectF</a>&#160;<i>target</i>, int&#160;<i>textureId</i>, int&#160;<i>textureTarget</i>&#160;=&#160;GL_TEXTURE_2D)</h3><p>Draws the given texture, <i>textureId</i>, to the given target
rectangle, <i>target</i>, in OpenGL model space. The
<i>textureTarget</i> should be a 2D texture target.</p>
<p>Equivalent to the corresponding <a href="qglcontext.html#drawTexture">QGLContext.drawTexture</a>().</p>
<p>This function was introduced in Qt 4.4.</p>


<h3 class="fn"><a name="drawTexture-2" />QGLPixelBuffer.drawTexture (<i>self</i>, <a href="qpointf.html">QPointF</a>&#160;<i>point</i>, int&#160;<i>textureId</i>, int&#160;<i>textureTarget</i>&#160;=&#160;GL_TEXTURE_2D)</h3><p>Draws the given texture, <i>textureId</i>, at the given
<i>point</i> in OpenGL model space. The textureTarget parameter
should be a 2D texture target.</p>
<p>Equivalent to the corresponding <a href="qglcontext.html#drawTexture">QGLContext.drawTexture</a>().</p>
<p>This function was introduced in Qt 4.4.</p>


<h3 class="fn"><a name="format" /><a href="qglformat.html">QGLFormat</a> QGLPixelBuffer.format (<i>self</i>)</h3><p>Returns the format of the pbuffer. The format may be different
from the one that was requested.</p>


<h3 class="fn"><a name="generateDynamicTexture" />int QGLPixelBuffer.generateDynamicTexture (<i>self</i>)</h3><p>Generates and binds a 2D GL texture that is the same size as the
pbuffer, and returns the texture's ID. This can be used in
conjunction with <a href="qglpixelbuffer.html#bindToDynamicTexture">bindToDynamicTexture</a>()
and <a href="qglpixelbuffer.html#updateDynamicTexture">updateDynamicTexture</a>().</p>
<p><b>See also</b> <a href="qglpixelbuffer.html#size">size</a>().</p>


<h3 class="fn"><a name="handle" />sip.voidptr QGLPixelBuffer.handle (<i>self</i>)</h3><p>Returns the native pbuffer handle.</p>


<h3 class="fn"><a name="hasOpenGLPbuffers" />bool QGLPixelBuffer.hasOpenGLPbuffers ()</h3><p>Returns true if the OpenGL <tt>pbuffer</tt> extension is present
on this system; otherwise returns false.</p>


<h3 class="fn"><a name="isValid" />bool QGLPixelBuffer.isValid (<i>self</i>)</h3><p>Returns true if this pbuffer is valid; otherwise returns
false.</p>


<h3 class="fn"><a name="makeCurrent" />bool QGLPixelBuffer.makeCurrent (<i>self</i>)</h3><p>Makes this pbuffer the current OpenGL rendering context. Returns
true on success; otherwise returns false.</p>
<p><b>See also</b> <a href="qglcontext.html#makeCurrent">QGLContext.makeCurrent</a>() and
<a href="qglpixelbuffer.html#doneCurrent">doneCurrent</a>().</p>


<h3 class="fn"><a name="metric" />int QGLPixelBuffer.metric (<i>self</i>, <a href="qpaintdevice.html#PaintDeviceMetric-enum">QPaintDevice.PaintDeviceMetric</a>&#160;<i>metric</i>)</h3><p>Reimplemented from <a href="qpaintdevice.html#metric">QPaintDevice.metric</a>().</p>


<h3 class="fn"><a name="paintEngine" /><a href="qpaintengine.html">QPaintEngine</a> QGLPixelBuffer.paintEngine (<i>self</i>)</h3><p>Reimplemented from <a href="qpaintdevice.html#paintEngine">QPaintDevice.paintEngine</a>().</p>


<h3 class="fn"><a name="releaseFromDynamicTexture" />QGLPixelBuffer.releaseFromDynamicTexture (<i>self</i>)</h3><p>Releases the pbuffer from any previously bound texture.</p>
<p><b>See also</b> <a href="qglpixelbuffer.html#bindToDynamicTexture">bindToDynamicTexture</a>().</p>


<h3 class="fn"><a name="size" /><a href="qsize.html">QSize</a> QGLPixelBuffer.size (<i>self</i>)</h3><p>Returns the size of the pbuffer.</p>


<h3 class="fn"><a name="toImage" /><a href="qimage.html">QImage</a> QGLPixelBuffer.toImage (<i>self</i>)</h3><p>Returns the contents of the pbuffer as a <a href="qimage.html">QImage</a>.</p>


<h3 class="fn"><a name="updateDynamicTexture" />QGLPixelBuffer.updateDynamicTexture (<i>self</i>, int&#160;<i>texture_id</i>)</h3><p>Copies the pbuffer contents into the texture specified with
<i>texture_id</i>.</p>
<p>The texture must be of the same size and format as the
pbuffer.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qglpixelbuffer.html">QGLPixelBuffer</a></span> pbuffer(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 pbuffer<span class="operator">.</span><a href="qglpixelbuffer.html#makeCurrent">makeCurrent</a>();
 GLuint dynamicTexture <span class="operator">=</span> pbuffer<span class="operator">.</span><a href="qglpixelbuffer.html#generateDynamicTexture">generateDynamicTexture</a>();
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 pbuffer<span class="operator">.</span>updateDynamicTexture(dynamicTexture);
</pre>
<p>An alternative on Windows and Mac OS X systems that support the
<tt>render_texture</tt> extension is to use <a href="qglpixelbuffer.html#bindToDynamicTexture">bindToDynamicTexture</a>()
to get dynamic updates of the texture.</p>
<p><b>See also</b> <a href="qglpixelbuffer.html#generateDynamicTexture">generateDynamicTexture</a>()
and <a href="qglpixelbuffer.html#bindToDynamicTexture">bindToDynamicTexture</a>().</p>
<address><hr /><div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address"><td align="left" width="25%">PyQt&#160;4.10 for Windows</td><td align="center" width="50%">Copyright &#169; <a href="http://www.riverbankcomputing.com">Riverbank&#160;Computing&#160;Ltd</a> and <a href="http://www.qtsoftware.com">Nokia</a> 2012</td><td align="right" width="25%">Qt&#160;4.8.4</td></tr></table></div></address></body></html>