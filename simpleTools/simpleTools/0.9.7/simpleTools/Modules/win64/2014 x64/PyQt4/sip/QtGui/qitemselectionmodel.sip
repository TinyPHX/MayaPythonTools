// qitemselectionmodel.sip generated by MetaSIP on Fri Mar  1 21:45:59 2013
//
// This file is part of the QtGui Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// If you are unsure which license is appropriate for your use, please
// contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%ModuleCode
#include <qitemselectionmodel.h>
%End

class QItemSelectionRange
{
%TypeHeaderCode
#include <qitemselectionmodel.h>
%End

public:
    QItemSelectionRange();
    QItemSelectionRange(const QItemSelectionRange &other);
    QItemSelectionRange(const QModelIndex &atopLeft, const QModelIndex &abottomRight);
    explicit QItemSelectionRange(const QModelIndex &index);
    int top() const;
    int left() const;
    int bottom() const;
    int right() const;
    int width() const;
    int height() const;
%If (Qt_5_0_0 -)
    const QPersistentModelIndex &topLeft() const;
%End
%If (- Qt_5_0_0)
    QModelIndex topLeft() const;
%End
%If (Qt_5_0_0 -)
    const QPersistentModelIndex &bottomRight() const;
%End
%If (- Qt_5_0_0)
    QModelIndex bottomRight() const;
%End
    QModelIndex parent() const;
    const QAbstractItemModel *model() const;
    bool contains(const QModelIndex &index) const;
%If (Qt_4_2_0 -)
    bool contains(int row, int column, const QModelIndex &parentIndex) const;
%End
    bool intersects(const QItemSelectionRange &other) const;
%If (PyQt_Deprecated_5_0)
    QItemSelectionRange intersect(const QItemSelectionRange &other) const;
%End
    bool operator==(const QItemSelectionRange &other) const;
    bool operator!=(const QItemSelectionRange &other) const;
    bool isValid() const;
    QModelIndexList indexes() const;
%If (Qt_4_2_0 -)
    QItemSelectionRange intersected(const QItemSelectionRange &other) const;
%End
    long __hash__() const;
%MethodCode
        sipRes = qHash(*sipCpp);
%End

%If (Qt_4_7_0 -)
    bool isEmpty() const;
%End
%If (Qt_4_8_0 -)
    bool operator<(const QItemSelectionRange &other) const;
%End
};

class QItemSelectionModel : QObject
{
%TypeHeaderCode
#include <qitemselectionmodel.h>
%End

public:
    enum SelectionFlag
    {
        NoUpdate,
        Clear,
        Select,
        Deselect,
        Toggle,
        Current,
        Rows,
        Columns,
        SelectCurrent,
        ToggleCurrent,
        ClearAndSelect,
    };

    typedef QFlags<QItemSelectionModel::SelectionFlag> SelectionFlags;
    explicit QItemSelectionModel(QAbstractItemModel *model);
    QItemSelectionModel(QAbstractItemModel *model, QObject *parent /TransferThis/);
    virtual ~QItemSelectionModel();
    QModelIndex currentIndex() const;
    bool isSelected(const QModelIndex &index) const;
    bool isRowSelected(int row, const QModelIndex &parent) const;
    bool isColumnSelected(int column, const QModelIndex &parent) const;
    bool rowIntersectsSelection(int row, const QModelIndex &parent) const;
    bool columnIntersectsSelection(int column, const QModelIndex &parent) const;
    QModelIndexList selectedIndexes() const;
    const QItemSelection selection() const;
    const QAbstractItemModel *model() const;

public slots:
    virtual void clear();
%If (Qt_4_2_0 -)
    void clearSelection();
%End
    virtual void reset();
    virtual void select(const QModelIndex &index, QFlags<QItemSelectionModel::SelectionFlag> command);
    virtual void select(const QItemSelection &selection, QFlags<QItemSelectionModel::SelectionFlag> command);
%If (Qt_5_0_0 -)
    virtual void setCurrentIndex(const QModelIndex &index, QFlags<QItemSelectionModel::SelectionFlag> command);
%End
%If (- Qt_5_0_0)
    void setCurrentIndex(const QModelIndex &index, QFlags<QItemSelectionModel::SelectionFlag> command);
%End
%If (Qt_5_0_0 -)
    virtual void clearCurrentIndex();
%End

signals:
    void selectionChanged(const QItemSelection &selected, const QItemSelection &deselected);
    void currentChanged(const QModelIndex &current, const QModelIndex &previous);
    void currentRowChanged(const QModelIndex &current, const QModelIndex &previous);
    void currentColumnChanged(const QModelIndex &current, const QModelIndex &previous);

protected:
    void emitSelectionChanged(const QItemSelection &newSelection, const QItemSelection &oldSelection);

public:
%If (Qt_4_2_0 -)
    bool hasSelection() const;
%End
%If (Qt_4_2_0 -)
    QModelIndexList selectedRows(int column = 0) const;
%End
%If (Qt_4_2_0 -)
    QModelIndexList selectedColumns(int row = 0) const;
%End

private:
    QItemSelectionModel(const QItemSelectionModel &);
};

QFlags<QItemSelectionModel::SelectionFlag> operator|(QItemSelectionModel::SelectionFlag f1, QFlags<QItemSelectionModel::SelectionFlag> f2);

class QItemSelection
{
%TypeHeaderCode
#include <qitemselectionmodel.h>
%End

public:
    QItemSelection();
    QItemSelection(const QModelIndex &topLeft, const QModelIndex &bottomRight);
    void select(const QModelIndex &topLeft, const QModelIndex &bottomRight);
    bool contains(const QModelIndex &index) const;
    int __contains__(const QModelIndex &index);
%MethodCode
        // It looks like you can't assign QBool to int.
        sipRes = bool(sipCpp->contains(*a0));
%End

    QModelIndexList indexes() const;
    void merge(const QItemSelection &other, QFlags<QItemSelectionModel::SelectionFlag> command);
    static void split(const QItemSelectionRange &range, const QItemSelectionRange &other, QItemSelection *result);
    void __setitem__(int i, const QItemSelectionRange &range);
%MethodCode
        int len;
        
        len = sipCpp->count();
        
        if ((a0 = (int)sipConvertFromSequenceIndex(a0, len)) < 0)
            sipIsErr = 1;
        else
            (*sipCpp)[a0] = *a1;
%End

    void __setitem__(SIP_PYSLICE slice, const QItemSelection &list);
%MethodCode
        SIP_SSIZE_T len, start, stop, step, slicelength, i;
        
        len = sipCpp->count();
        
        #if PY_VERSION_HEX >= 0x03020000
        if (PySlice_GetIndicesEx(a0, len, &start, &stop, &step, &slicelength) < 0)
        #else
        if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
        #endif
            sipIsErr = 1;
        else
        {
            int vlen = a1->count();
        
            if (vlen != slicelength)
            {
                sipBadLengthForSlice(vlen, slicelength);
                sipIsErr = 1;
            }
            else
            {
                QItemSelection::const_iterator it = a1->begin();
        
                for (i = 0; i < slicelength; ++i)
                {
                    (*sipCpp)[start] = *it;
                    start += step;
                    ++it;
                }
            }
        }
%End

    void __delitem__(int i);
%MethodCode
        int len;
        
        len = sipCpp->count();
        
        if ((a0 = (int)sipConvertFromSequenceIndex(a0, len)) < 0)
            sipIsErr = 1;
        else
            sipCpp->removeAt(a0);
%End

    void __delitem__(SIP_PYSLICE slice);
%MethodCode
        SIP_SSIZE_T len, start, stop, step, slicelength, i;
        
        len = sipCpp->count();
        
        #if PY_VERSION_HEX >= 0x03020000
        if (PySlice_GetIndicesEx(a0, len, &start, &stop, &step, &slicelength) < 0)
        #else
        if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
        #endif
            sipIsErr = 1;
        else
            for (i = 0; i < slicelength; ++i)
            {
                sipCpp->removeAt(start);
                start += step - 1;
            }
%End

    QItemSelectionRange operator[](int i);
%MethodCode
        SIP_SSIZE_T idx = sipConvertFromSequenceIndex(a0, sipCpp->count());
        
        if (idx < 0)
            sipIsErr = 1;
        else
            sipRes = new QItemSelectionRange(sipCpp->operator[]((int)idx));
%End

    QItemSelection operator[](SIP_PYSLICE slice);
%MethodCode
        SIP_SSIZE_T len, start, stop, step, slicelength, i;
        
        len = sipCpp->count();
        
        #if PY_VERSION_HEX >= 0x03020000
        if (PySlice_GetIndicesEx(a0, len, &start, &stop, &step, &slicelength) < 0)
        #else
        if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
        #endif
            sipIsErr = 1;
        else
        {
            sipRes = new QItemSelection();
        
            for (i = 0; i < slicelength; ++i)
            {
                (*sipRes) += (*sipCpp)[start];
                start += step;
            }
        }
%End

// Methods inherited from QList<QItemSelectionRange>.
bool operator!=(const QItemSelection &other) const;
bool operator==(const QItemSelection &other) const;

// Keep the following in sync with QStringList (except for mid()).
void clear();
bool isEmpty() const;
void append(const QItemSelectionRange &range);
void prepend(const QItemSelectionRange &range);
void insert(int i, const QItemSelectionRange &range);
void replace(int i, const QItemSelectionRange &range);
void removeAt(int i);
int removeAll(const QItemSelectionRange &range);
QItemSelectionRange takeAt(int i);
QItemSelectionRange takeFirst();
QItemSelectionRange takeLast();
void move(int from, int to);
void swap(int i, int j);
int count(const QItemSelectionRange &range) const;
int count() const /__len__/;
QItemSelectionRange &first();
QItemSelectionRange &last();
int indexOf(const QItemSelectionRange &value, int from = 0) const;
int lastIndexOf(const QItemSelectionRange &value, int from = -1) const;
QItemSelection &operator+=(const QItemSelection &other);
QItemSelection &operator+=(const QItemSelectionRange &value);
};
