<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html><head><title>QHttp Class Reference</title><style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style></head><body><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr /><td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" width="32" /></td><td width="1">&#160;&#160;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&#160;&#183; <a href="classes.html"><font color="#004faf">All Classes</font></a>&#160;&#183; <a href="modules.html"><font color="#004faf">Modules</font></a></td></table><h1 align="center">QHttp Class Reference<br /><sup><sup>[<a href="qtnetwork.html">QtNetwork</a> module]</sup></sup></h1><p>The QHttp class provides an implementation of the HTTP protocol.
<a href="#details">More...</a></p>

<p>Inherits <a href="qobject.html">QObject</a>.</p><h3>Types</h3><ul><li><div class="fn" />enum <b><a href="qhttp.html#ConnectionMode-enum">ConnectionMode</a></b> { ConnectionModeHttp, ConnectionModeHttps }</li><li><div class="fn" />enum <b><a href="qhttp.html#Error-enum">Error</a></b> { NoError, UnknownError, HostNotFound, ConnectionRefused, ..., ProxyAuthenticationRequiredError }</li><li><div class="fn" />enum <b><a href="qhttp.html#State-enum">State</a></b> { Unconnected, HostLookup, Connecting, Sending, ..., Closing }</li></ul><h3>Methods</h3><ul><li><div class="fn" /><b><a href="qhttp.html#QHttp">__init__</a></b> (<i>self</i>, QObject&#160;<i>parent</i>&#160;=&#160;None)</li><li><div class="fn" /><b><a href="qhttp.html#QHttp-2">__init__</a></b> (<i>self</i>, QString&#160;<i>hostName</i>, int&#160;<i>port</i>&#160;=&#160;80, QObject&#160;<i>parent</i>&#160;=&#160;None)</li><li><div class="fn" /><b><a href="qhttp.html#QHttp-3">__init__</a></b> (<i>self</i>, QString&#160;<i>hostname</i>, ConnectionMode&#160;<i>mode</i>, int&#160;<i>port</i>&#160;=&#160;0, QObject&#160;<i>parent</i>&#160;=&#160;None)</li><li><div class="fn" /><b><a href="qhttp.html#abort">abort</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qhttp.html#bytesAvailable">bytesAvailable</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qhttp.html#clearPendingRequests">clearPendingRequests</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qhttp.html#close">close</a></b> (<i>self</i>)</li><li><div class="fn" />QIODevice <b><a href="qhttp.html#currentDestinationDevice">currentDestinationDevice</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qhttp.html#currentId">currentId</a></b> (<i>self</i>)</li><li><div class="fn" />QHttpRequestHeader <b><a href="qhttp.html#currentRequest">currentRequest</a></b> (<i>self</i>)</li><li><div class="fn" />QIODevice <b><a href="qhttp.html#currentSourceDevice">currentSourceDevice</a></b> (<i>self</i>)</li><li><div class="fn" />Error <b><a href="qhttp.html#error">error</a></b> (<i>self</i>)</li><li><div class="fn" />QString <b><a href="qhttp.html#errorString">errorString</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qhttp.html#get">get</a></b> (<i>self</i>, QString&#160;<i>path</i>, QIODevice&#160;<i>to</i>&#160;=&#160;None)</li><li><div class="fn" />bool <b><a href="qhttp.html#hasPendingRequests">hasPendingRequests</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qhttp.html#head">head</a></b> (<i>self</i>, QString&#160;<i>path</i>)</li><li><div class="fn" /><b><a href="qhttp.html#ignoreSslErrors">ignoreSslErrors</a></b> (<i>self</i>)</li><li><div class="fn" />QHttpResponseHeader <b><a href="qhttp.html#lastResponse">lastResponse</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qhttp.html#post">post</a></b> (<i>self</i>, QString&#160;<i>path</i>, QIODevice&#160;<i>data</i>, QIODevice&#160;<i>to</i>&#160;=&#160;None)</li><li><div class="fn" />int <b><a href="qhttp.html#post-2">post</a></b> (<i>self</i>, QString&#160;<i>path</i>, QByteArray&#160;<i>data</i>, QIODevice&#160;<i>to</i>&#160;=&#160;None)</li><li><div class="fn" />str <b><a href="qhttp.html#read">read</a></b> (<i>self</i>, int&#160;<i>maxlen</i>)</li><li><div class="fn" />QByteArray <b><a href="qhttp.html#readAll">readAll</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qhttp.html#request">request</a></b> (<i>self</i>, QHttpRequestHeader&#160;<i>header</i>, QIODevice&#160;<i>data</i>&#160;=&#160;None, QIODevice&#160;<i>to</i>&#160;=&#160;None)</li><li><div class="fn" />int <b><a href="qhttp.html#request-2">request</a></b> (<i>self</i>, QHttpRequestHeader&#160;<i>header</i>, QByteArray&#160;<i>data</i>, QIODevice&#160;<i>to</i>&#160;=&#160;None)</li><li><div class="fn" />int <b><a href="qhttp.html#setHost">setHost</a></b> (<i>self</i>, QString&#160;<i>hostName</i>, int&#160;<i>port</i>&#160;=&#160;80)</li><li><div class="fn" />int <b><a href="qhttp.html#setHost-2">setHost</a></b> (<i>self</i>, QString&#160;<i>hostname</i>, ConnectionMode&#160;<i>mode</i>, int&#160;<i>port</i>&#160;=&#160;0)</li><li><div class="fn" />int <b><a href="qhttp.html#setProxy">setProxy</a></b> (<i>self</i>, QString&#160;<i>host</i>, int&#160;<i>port</i>, QString&#160;<i>user</i>&#160;=&#160;QString(), QString&#160;<i>password</i>&#160;=&#160;QString())</li><li><div class="fn" />int <b><a href="qhttp.html#setProxy-2">setProxy</a></b> (<i>self</i>, QNetworkProxy&#160;<i>proxy</i>)</li><li><div class="fn" />int <b><a href="qhttp.html#setSocket">setSocket</a></b> (<i>self</i>, QTcpSocket&#160;<i>socket</i>)</li><li><div class="fn" />int <b><a href="qhttp.html#setUser">setUser</a></b> (<i>self</i>, QString&#160;<i>userName</i>, QString&#160;<i>password</i>&#160;=&#160;QString())</li><li><div class="fn" />State <b><a href="qhttp.html#state">state</a></b> (<i>self</i>)</li></ul><h3>Qt Signals</h3><ul><li><div class="fn" />void <b><a href="qhttp.html#authenticationRequired">authenticationRequired</a></b> (const QString&amp;,quint16,QAuthenticator *)</li><li><div class="fn" />void <b><a href="qhttp.html#dataReadProgress">dataReadProgress</a></b> (int,int)</li><li><div class="fn" />void <b><a href="qhttp.html#dataSendProgress">dataSendProgress</a></b> (int,int)</li><li><div class="fn" />void <b><a href="qhttp.html#done">done</a></b> (bool)</li><li><div class="fn" />void <b><a href="qhttp.html#proxyAuthenticationRequired">proxyAuthenticationRequired</a></b> (const QNetworkProxy&amp;,QAuthenticator *)</li><li><div class="fn" />void <b><a href="qhttp.html#readyRead">readyRead</a></b> (const QHttpResponseHeader&amp;)</li><li><div class="fn" />void <b><a href="qhttp.html#requestFinished">requestFinished</a></b> (int,bool)</li><li><div class="fn" />void <b><a href="qhttp.html#requestStarted">requestStarted</a></b> (int)</li><li><div class="fn" />void <b><a href="qhttp.html#responseHeaderReceived">responseHeaderReceived</a></b> (const QHttpResponseHeader&amp;)</li><li><div class="fn" />void <b><a href="qhttp.html#sslErrors">sslErrors</a></b> (const QList&lt;QSslError&gt;&amp;)</li><li><div class="fn" />void <b><a href="qhttp.html#stateChanged">stateChanged</a></b> (int)</li></ul><a name="details" /><hr /><h2>Detailed Description</h2><p>The QHttp class provides an implementation of the HTTP
protocol.</p>
<p>This class provides a direct interface to HTTP that allows you
to download and upload data with the HTTP protocol. However, for
new applications, it is recommended to use <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> and <a href="qnetworkreply.html">QNetworkReply</a>, as those classes possess a
simpler, yet more powerful API and a more modern protocol
implementation.</p>
<p>The class works asynchronously, so there are no blocking
functions. If an operation cannot be executed immediately, the
function will still return straight away and the operation will be
scheduled for later execution. The results of scheduled operations
are reported via signals. This approach depends on the event loop
being in operation.</p>
<p>The operations that can be scheduled (they are called "requests"
in the rest of the documentation) are the following: <a href="qhttp.html#setHost">setHost</a>(), <a href="qhttp.html#get">get</a>(), <a href="qhttp.html#post">post</a>(),
<a href="qhttp.html#head">head</a>() and <a href="qhttp.html#request">request</a>().</p>
<p>All of these requests return a unique identifier that allows you
to keep track of the request that is currently executed. When the
execution of a request starts, the <a href="qhttp.html#requestStarted">requestStarted</a>() signal with the
identifier is emitted and when the request is finished, the
<a href="qhttp.html#requestFinished">requestFinished</a>() signal
is emitted with the identifier and a bool that indicates if the
request finished with an error.</p>
<p>To make an HTTP request you must set up suitable HTTP headers.
The following example demonstrates how to request the main HTML
page from the Qt website (i.e., the URL
<tt>http://qt.nokia.com/index.html</tt>):</p>
<pre class="cpp">
 <span class="type"><a href="qhttprequestheader.html">QHttpRequestHeader</a></span> header(<span class="string">"GET"</span><span class="operator">,</span> <span class="type"><a href="qurl.html">QUrl</a></span><span class="operator">.</span>toPercentEncoding(<span class="string">"/index.html"</span>));
 header<span class="operator">.</span>setValue(<span class="string">"Host"</span><span class="operator">,</span> <span class="string">"qt.nokia.com"</span>);
 http<span class="operator">-</span><span class="operator">&gt;</span><a href="qhttp.html#setHost">setHost</a>(<span class="string">"qt.nokia.com"</span>);
 http<span class="operator">-</span><span class="operator">&gt;</span><a href="qhttp.html#request">request</a>(header);
</pre>
<p>For the common HTTP requests <tt>GET</tt>, <tt>POST</tt> and
<tt>HEAD</tt>, QHttp provides the convenience functions <a href="qhttp.html#get">get</a>(), <a href="qhttp.html#post">post</a>()
and <a href="qhttp.html#head">head</a>(). They already use a
reasonable header and if you don't have to set special header
fields, they are easier to use. The above example can also be
written as:</p>
<pre class="cpp">
 http<span class="operator">-</span><span class="operator">&gt;</span><a href="qhttp.html#setHost">setHost</a>(<span class="string">"qt.nokia.com"</span>);                <span class="comment">// id == 1</span>
 http<span class="operator">-</span><span class="operator">&gt;</span><a href="qhttp.html#get">get</a>(<span class="type"><a href="qurl.html">QUrl</a></span><span class="operator">.</span>toPercentEncoding(<span class="string">"/index.html"</span>)); <span class="comment">// id == 2</span>
</pre>
<p>For this example the following sequence of signals is emitted
(with small variations, depending on network traffic, etc.):</p>
<pre class="cpp">
 <a href="qhttp.html#requestStarted">requestStarted</a>(<span class="number">1</span>)
 <a href="qhttp.html#requestFinished">requestFinished</a>(<span class="number">1</span><span class="operator">,</span> <span class="keyword">false</span>)

 <a href="qhttp.html#requestStarted">requestStarted</a>(<span class="number">2</span>)
 <a href="qhttp.html#stateChanged">stateChanged</a>(Connecting)
 <a href="qhttp.html#stateChanged">stateChanged</a>(Sending)
 <a href="qhttp.html#dataSendProgress">dataSendProgress</a>(<span class="number">77</span><span class="operator">,</span> <span class="number">77</span>)
 <a href="qhttp.html#stateChanged">stateChanged</a>(Reading)
 <a href="qhttp.html#responseHeaderReceived">responseHeaderReceived</a>(responseheader)
 <a href="qhttp.html#dataReadProgress">dataReadProgress</a>(<span class="number">5388</span><span class="operator">,</span> <span class="number">0</span>)
 <a href="qhttp.html#readyRead">readyRead</a>(responseheader)
 <a href="qhttp.html#dataReadProgress">dataReadProgress</a>(<span class="number">18300</span><span class="operator">,</span> <span class="number">0</span>)
 <a href="qhttp.html#readyRead">readyRead</a>(responseheader)
 <a href="qhttp.html#stateChanged">stateChanged</a>(Connected)
 <a href="qhttp.html#requestFinished">requestFinished</a>(<span class="number">2</span><span class="operator">,</span> <span class="keyword">false</span>)

 <a href="qhttp.html#done">done</a>(<span class="keyword">false</span>)

 <a href="qhttp.html#stateChanged">stateChanged</a>(Closing)
 <a href="qhttp.html#stateChanged">stateChanged</a>(Unconnected)
</pre>
<p>The <a href="qhttp.html#dataSendProgress">dataSendProgress</a>()
and <a href="qhttp.html#dataReadProgress">dataReadProgress</a>()
signals in the above example are useful if you want to show a
<a href="qprogressbar.html">progress bar</a> to inform the user
about the progress of the download. The second argument is the
total size of data. In certain cases it is not possible to know the
total amount in advance, in which case the second argument is 0.
(If you connect to a <a href="qprogressbar.html">QProgressBar</a> a
total of 0 results in a busy indicator.)</p>
<p>When the response header is read, it is reported with the
<a href="qhttp.html#responseHeaderReceived">responseHeaderReceived</a>()
signal.</p>
<p>The <a href="qhttp.html#readyRead">readyRead</a>() signal tells
you that there is data ready to be read. The amount of data can
then be queried with the <a href="qhttp.html#bytesAvailable">bytesAvailable</a>() function and it
can be read with the <a href="qhttp.html#read">read</a>() or
<a href="qhttp.html#readAll">readAll</a>() functions.</p>
<p>If an error occurs during the execution of one of the commands
in a sequence of commands, all the pending commands (i.e.
scheduled, but not yet executed commands) are cleared and no
signals are emitted for them.</p>
<p>For example, if you have the following sequence of requests</p>
<pre class="cpp">
 http<span class="operator">-</span><span class="operator">&gt;</span><a href="qhttp.html#setHost">setHost</a>(<span class="string">"www.foo.bar"</span>);       <span class="comment">// id == 1</span>
 http<span class="operator">-</span><span class="operator">&gt;</span><a href="qhttp.html#get">get</a>(<span class="string">"/index.html"</span>);           <span class="comment">// id == 2</span>
 http<span class="operator">-</span><span class="operator">&gt;</span><a href="qhttp.html#post">post</a>(<span class="string">"register.html"</span><span class="operator">,</span> data);  <span class="comment">// id == 3</span>
</pre>
<p>and the <a href="qhttp.html#get">get</a>() request fails because
the host lookup fails, then the <a href="qhttp.html#post">post</a>() request is never executed and the
signals would look like this:</p>
<pre class="cpp">
 <a href="qhttp.html#requestStarted">requestStarted</a>(<span class="number">1</span>)
 <a href="qhttp.html#requestFinished">requestFinished</a>(<span class="number">1</span><span class="operator">,</span> <span class="keyword">false</span>)

 <a href="qhttp.html#requestStarted">requestStarted</a>(<span class="number">2</span>)
 <a href="qhttp.html#stateChanged">stateChanged</a>(HostLookup)
 <a href="qhttp.html#requestFinished">requestFinished</a>(<span class="number">2</span><span class="operator">,</span> <span class="keyword">true</span>)

 <a href="qhttp.html#done">done</a>(<span class="keyword">true</span>)

 <a href="qhttp.html#stateChanged">stateChanged</a>(Unconnected)
</pre>
<p>You can then get details about the error with the <a href="qhttp.html#error">error</a>() and <a href="qhttp.html#errorString">errorString</a>() functions. Note that
only unexpected behavior, like network failure is considered as an
error. If the server response contains an error status, like a 404
response, this is reported as a normal response case. So you should
always check the <a href="qhttpresponseheader.html#statusCode">status code</a> of the
response header.</p>
<p>The functions <a href="qhttp.html#currentId">currentId</a>() and
<a href="qhttp.html#currentRequest">currentRequest</a>() provide
more information about the currently executing request.</p>
<p>The functions <a href="qhttp.html#hasPendingRequests">hasPendingRequests</a>() and
<a href="qhttp.html#clearPendingRequests">clearPendingRequests</a>() allow
you to query and clear the list of pending requests.</p>
<hr /><h2>Type Documentation</h2><h3 class="fn"><a name="ConnectionMode-enum" />QHttp.ConnectionMode</h3><p>This enum is used to specify the mode of connection to use:</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QHttp.ConnectionModeHttp</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">The connection is a regular HTTP connection to
the server</td>
</tr>
<tr>
<td class="topAlign"><tt>QHttp.ConnectionModeHttps</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">The HTTPS protocol is used and the connection
is encrypted using SSL.</td>
</tr>
</table>
<p>When using the HTTPS mode, care should be taken to connect to
the sslErrors signal, and handle possible SSL errors.</p>
<p>This enum was introduced or modified in Qt 4.3.</p>
<p><b>See also</b> <a href="qsslsocket.html">QSslSocket</a>.</p>


<h3 class="fn"><a name="Error-enum" />QHttp.Error</h3><p>This enum identifies the error that occurred.</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QHttp.NoError</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">No error occurred.</td>
</tr>
<tr>
<td class="topAlign"><tt>QHttp.HostNotFound</tt></td>
<td class="topAlign"><tt>2</tt></td>
<td class="topAlign">The host name lookup failed.</td>
</tr>
<tr>
<td class="topAlign"><tt>QHttp.ConnectionRefused</tt></td>
<td class="topAlign"><tt>3</tt></td>
<td class="topAlign">The server refused the connection.</td>
</tr>
<tr>
<td class="topAlign"><tt>QHttp.UnexpectedClose</tt></td>
<td class="topAlign"><tt>4</tt></td>
<td class="topAlign">The server closed the connection
unexpectedly.</td>
</tr>
<tr>
<td class="topAlign"><tt>QHttp.InvalidResponseHeader</tt></td>
<td class="topAlign"><tt>5</tt></td>
<td class="topAlign">The server sent an invalid response
header.</td>
</tr>
<tr>
<td class="topAlign"><tt>QHttp.WrongContentLength</tt></td>
<td class="topAlign"><tt>6</tt></td>
<td class="topAlign">The client could not read the content
correctly because an error with respect to the content length
occurred.</td>
</tr>
<tr>
<td class="topAlign"><tt>QHttp.Aborted</tt></td>
<td class="topAlign"><tt>7</tt></td>
<td class="topAlign">The request was aborted with <a href="qhttp.html#abort">abort</a>().</td>
</tr>
<tr>
<td class="topAlign">
<tt>QHttp.ProxyAuthenticationRequiredError</tt></td>
<td class="topAlign"><tt>9</tt></td>
<td class="topAlign"><a class="obsolete" href="qhttp.html">QHttp</a> is using a proxy, and the proxy server
requires authentication to establish a connection.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QHttp.AuthenticationRequiredError</tt></td>
<td class="topAlign"><tt>8</tt></td>
<td class="topAlign">The web server requires authentication to
complete the request.</td>
</tr>
<tr>
<td class="topAlign"><tt>QHttp.UnknownError</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">An error other than those specified above
occurred.</td>
</tr>
</table>
<p><b>See also</b> <a href="qhttp.html#error">error</a>().</p>


<h3 class="fn"><a name="State-enum" />QHttp.State</h3><p>This enum is used to specify the state the client is in:</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QHttp.Unconnected</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">There is no connection to the host.</td>
</tr>
<tr>
<td class="topAlign"><tt>QHttp.HostLookup</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">A host name lookup is in progress.</td>
</tr>
<tr>
<td class="topAlign"><tt>QHttp.Connecting</tt></td>
<td class="topAlign"><tt>2</tt></td>
<td class="topAlign">An attempt to connect to the host is in
progress.</td>
</tr>
<tr>
<td class="topAlign"><tt>QHttp.Sending</tt></td>
<td class="topAlign"><tt>3</tt></td>
<td class="topAlign">The client is sending its request to the
server.</td>
</tr>
<tr>
<td class="topAlign"><tt>QHttp.Reading</tt></td>
<td class="topAlign"><tt>4</tt></td>
<td class="topAlign">The client's request has been sent and the
client is reading the server's response.</td>
</tr>
<tr>
<td class="topAlign"><tt>QHttp.Connected</tt></td>
<td class="topAlign"><tt>5</tt></td>
<td class="topAlign">The connection to the host is open, but the
client is neither sending a request, nor waiting for a
response.</td>
</tr>
<tr>
<td class="topAlign"><tt>QHttp.Closing</tt></td>
<td class="topAlign"><tt>6</tt></td>
<td class="topAlign">The connection is closing down, but is not yet
closed. (The state will be <tt>Unconnected</tt> when the connection
is closed.)</td>
</tr>
</table>
<p><b>See also</b> <a href="qhttp.html#stateChanged">stateChanged</a>() and <a href="qhttp.html#state">state</a>().</p>
<hr /><h2>Method Documentation</h2><h3 class="fn"><a name="QHttp" />QHttp.__init__ (<i>self</i>, <a href="qobject.html">QObject</a>&#160;<i>parent</i>&#160;=&#160;None)</h3><p>The <i>parent</i> argument, if not None, causes <i>self</i> to be owned by Qt instead of PyQt.</p><p>Constructs a <a class="obsolete" href="qhttp.html">QHttp</a>
object. The <i>parent</i> parameter is passed on to the <a href="qobject.html">QObject</a> constructor.</p>


<h3 class="fn"><a name="QHttp-2" />QHttp.__init__ (<i>self</i>, QString&#160;<i>hostName</i>, int&#160;<i>port</i>&#160;=&#160;80, <a href="qobject.html">QObject</a>&#160;<i>parent</i>&#160;=&#160;None)</h3><p>The <i>parent</i> argument, if not None, causes <i>self</i> to be owned by Qt instead of PyQt.</p><p>Constructs a <a class="obsolete" href="qhttp.html">QHttp</a>
object. Subsequent requests are done by connecting to the server
<i>hostName</i> on port <i>port</i>.</p>
<p>The <i>parent</i> parameter is passed on to the <a href="qobject.html">QObject</a> constructor.</p>
<p><b>See also</b> <a href="qhttp.html#setHost">setHost</a>().</p>


<h3 class="fn"><a name="QHttp-3" />QHttp.__init__ (<i>self</i>, QString&#160;<i>hostname</i>, <a href="qhttp.html#ConnectionMode-enum">ConnectionMode</a>&#160;<i>mode</i>, int&#160;<i>port</i>&#160;=&#160;0, <a href="qobject.html">QObject</a>&#160;<i>parent</i>&#160;=&#160;None)</h3><p>The <i>parent</i> argument, if not None, causes <i>self</i> to be owned by Qt instead of PyQt.</p><p>Constructs a <a class="obsolete" href="qhttp.html">QHttp</a>
object. Subsequent requests are done by connecting to the server
<i>hostName</i> on port <i>port</i> using the connection mode
<i>mode</i>.</p>
<p>If port is 0, it will use the default port for the <i>mode</i>
used (80 for Http and 443 for Https).</p>
<p>The <i>parent</i> parameter is passed on to the <a href="qobject.html">QObject</a> constructor.</p>
<p><b>See also</b> <a href="qhttp.html#setHost">setHost</a>().</p>


<h3 class="fn"><a name="abort" />QHttp.abort (<i>self</i>)</h3><p>This method is also a Qt slot with the C++ signature <tt>void abort()</tt>.</p><p>Aborts the current request and deletes all scheduled
requests.</p>
<p>For the current request, the <a href="qhttp.html#requestFinished">requestFinished</a>() signal with the
<tt>error</tt> argument <tt>true</tt> is emitted. For all other
requests that are affected by the abort(), no signals are
emitted.</p>
<p>Since this slot also deletes the scheduled requests, there are
no requests left and the <a href="qhttp.html#done">done</a>()
signal is emitted (with the <tt>error</tt> argument
<tt>true</tt>).</p>
<p><b>See also</b> <a href="qhttp.html#clearPendingRequests">clearPendingRequests</a>().</p>


<h3 class="fn"><a name="bytesAvailable" />int QHttp.bytesAvailable (<i>self</i>)</h3><p>Returns the number of bytes that can be read from the response
content at the moment.</p>
<p><b>See also</b> <a href="qhttp.html#get">get</a>(), <a href="qhttp.html#post">post</a>(), <a href="qhttp.html#request">request</a>(), <a href="qhttp.html#readyRead">readyRead</a>(), <a href="qhttp.html#read">read</a>(), and <a href="qhttp.html#readAll">readAll</a>().</p>


<h3 class="fn"><a name="clearPendingRequests" />QHttp.clearPendingRequests (<i>self</i>)</h3><p>Deletes all pending requests from the list of scheduled
requests. This does not affect the request that is being executed.
If you want to stop this as well, use <a href="qhttp.html#abort">abort</a>().</p>
<p><b>See also</b> <a href="qhttp.html#hasPendingRequests">hasPendingRequests</a>() and
<a href="qhttp.html#abort">abort</a>().</p>


<h3 class="fn"><a name="close" />int QHttp.close (<i>self</i>)</h3><p>Closes the connection; this is useful if you have a keep-alive
connection and want to close it.</p>
<p>For the requests issued with <a href="qhttp.html#get">get</a>(),
<a href="qhttp.html#post">post</a>() and <a href="qhttp.html#head">head</a>(), <a class="obsolete" href="qhttp.html">QHttp</a> sets the connection to be keep-alive. You can
also do this using the header you pass to the <a href="qhttp.html#request">request</a>() function. <a class="obsolete" href="qhttp.html">QHttp</a> only closes the connection to the HTTP
server if the response header requires it to do so.</p>
<p>The function does not block; instead, it returns immediately.
The request is scheduled, and its execution is performed
asynchronously. The function returns a unique identifier which is
passed by <a href="qhttp.html#requestStarted">requestStarted</a>()
and <a href="qhttp.html#requestFinished">requestFinished</a>().</p>
<p>When the request is started the <a href="qhttp.html#requestStarted">requestStarted</a>() signal is emitted.
When it is finished the <a href="qhttp.html#requestFinished">requestFinished</a>() signal is
emitted.</p>
<p>If you want to close the connection immediately, you have to use
<a href="qhttp.html#abort">abort</a>() instead.</p>
<p><b>See also</b> <a href="qhttp.html#stateChanged">stateChanged</a>(), <a href="qhttp.html#abort">abort</a>(), <a href="qhttp.html#requestStarted">requestStarted</a>(), <a href="qhttp.html#requestFinished">requestFinished</a>(), and <a href="qhttp.html#done">done</a>().</p>


<h3 class="fn"><a name="currentDestinationDevice" /><a href="qiodevice.html">QIODevice</a> QHttp.currentDestinationDevice (<i>self</i>)</h3><p>Returns the <a href="qiodevice.html">QIODevice</a> pointer that
is used as to store the data of the HTTP request being executed. If
there is no current request or if the request does not store the
data to an IO device, this function returns 0.</p>
<p>This function can be used to delete the <a href="qiodevice.html">QIODevice</a> in the slot connected to the
<a href="qhttp.html#requestFinished">requestFinished</a>()
signal.</p>
<p><b>See also</b> <a href="qhttp.html#currentSourceDevice">currentSourceDevice</a>(),
<a href="qhttp.html#get">get</a>(), <a href="qhttp.html#post">post</a>(), and <a href="qhttp.html#request">request</a>().</p>


<h3 class="fn"><a name="currentId" />int QHttp.currentId (<i>self</i>)</h3><p>Returns the identifier of the HTTP request being executed or 0
if there is no request being executed (i.e. they've all
finished).</p>
<p><b>See also</b> <a href="qhttp.html#currentRequest">currentRequest</a>().</p>


<h3 class="fn"><a name="currentRequest" /><a href="qhttprequestheader.html">QHttpRequestHeader</a> QHttp.currentRequest (<i>self</i>)</h3><p>Returns the request header of the HTTP request being executed.
If the request is one issued by <a href="qhttp.html#setHost">setHost</a>() or <a href="qhttp.html#close">close</a>(), it returns an invalid request
header, i.e. <a href="qhttpheader.html#isValid">QHttpRequestHeader.isValid</a>()
returns false.</p>
<p><b>See also</b> <a href="qhttp.html#currentId">currentId</a>().</p>


<h3 class="fn"><a name="currentSourceDevice" /><a href="qiodevice.html">QIODevice</a> QHttp.currentSourceDevice (<i>self</i>)</h3><p>Returns the <a href="qiodevice.html">QIODevice</a> pointer that
is used as the data source of the HTTP request being executed. If
there is no current request or if the request does not use an IO
device as the data source, this function returns 0.</p>
<p>This function can be used to delete the <a href="qiodevice.html">QIODevice</a> in the slot connected to the
<a href="qhttp.html#requestFinished">requestFinished</a>()
signal.</p>
<p><b>See also</b> <a href="qhttp.html#currentDestinationDevice">currentDestinationDevice</a>(),
<a href="qhttp.html#post">post</a>(), and <a href="qhttp.html#request">request</a>().</p>


<h3 class="fn"><a name="error" /><a href="qhttp.html#Error-enum">Error</a> QHttp.error (<i>self</i>)</h3><p>Returns the last error that occurred. This is useful to find out
what happened when receiving a <a href="qhttp.html#requestFinished">requestFinished</a>() or a <a href="qhttp.html#done">done</a>() signal with the <tt>error</tt>
argument <tt>true</tt>.</p>
<p>If you start a new request, the error status is reset to
<tt>NoError</tt>.</p>


<h3 class="fn"><a name="errorString" />QString QHttp.errorString (<i>self</i>)</h3><p>Returns a human-readable description of the last error that
occurred. This is useful to present a error message to the user
when receiving a <a href="qhttp.html#requestFinished">requestFinished</a>() or a <a href="qhttp.html#done">done</a>() signal with the <tt>error</tt>
argument <tt>true</tt>.</p>


<h3 class="fn"><a name="get" />int QHttp.get (<i>self</i>, QString&#160;<i>path</i>, <a href="qiodevice.html">QIODevice</a>&#160;<i>to</i>&#160;=&#160;None)</h3><p>Sends a get request for <i>path</i> to the server set by
<a href="qhttp.html#setHost">setHost</a>() or as specified in the
constructor.</p>
<p><i>path</i> must be a absolute path like <tt>/index.html</tt> or
an absolute URI like <tt>http://example.com/index.html</tt> and
must be encoded with either <a href="qurl.html#toPercentEncoding">QUrl.toPercentEncoding</a>() or
<a href="qurl.html#encodedPath">QUrl.encodedPath</a>().</p>
<p>If the IO device <i>to</i> is 0 the <a href="qhttp.html#readyRead">readyRead</a>() signal is emitted every time
new content data is available to read.</p>
<p>If the IO device <i>to</i> is not 0, the content data of the
response is written directly to the device. Make sure that the
<i>to</i> pointer is valid for the duration of the operation (it is
safe to delete it when the <a href="qhttp.html#requestFinished">requestFinished</a>() signal is
emitted).</p>
<a id="request-processing" name="request-processing" />
<h4>Request Processing</h4>
<p>The function does not block; instead, it returns immediately.
The request is scheduled, and its execution is performed
asynchronously. The function returns a unique identifier which is
passed by <a href="qhttp.html#requestStarted">requestStarted</a>()
and <a href="qhttp.html#requestFinished">requestFinished</a>().</p>
<p>When the request is started the <a href="qhttp.html#requestStarted">requestStarted</a>() signal is emitted.
When it is finished the <a href="qhttp.html#requestFinished">requestFinished</a>() signal is
emitted.</p>
<p><b>See also</b> <a href="qhttp.html#setHost">setHost</a>(),
<a href="qhttp.html#post">post</a>(), <a href="qhttp.html#head">head</a>(), <a href="qhttp.html#request">request</a>(), <a href="qhttp.html#requestStarted">requestStarted</a>(), <a href="qhttp.html#requestFinished">requestFinished</a>(), and <a href="qhttp.html#done">done</a>().</p>


<h3 class="fn"><a name="hasPendingRequests" />bool QHttp.hasPendingRequests (<i>self</i>)</h3><p>Returns true if there are any requests scheduled that have not
yet been executed; otherwise returns false.</p>
<p>The request that is being executed is <i>not</i> considered as a
scheduled request.</p>
<p><b>See also</b> <a href="qhttp.html#clearPendingRequests">clearPendingRequests</a>(),
<a href="qhttp.html#currentId">currentId</a>(), and <a href="qhttp.html#currentRequest">currentRequest</a>().</p>


<h3 class="fn"><a name="head" />int QHttp.head (<i>self</i>, QString&#160;<i>path</i>)</h3><p>Sends a header request for <i>path</i> to the server set by
<a href="qhttp.html#setHost">setHost</a>() or as specified in the
constructor.</p>
<p><i>path</i> must be an absolute path like <tt>/index.html</tt>
or an absolute URI like <tt>http://example.com/index.html</tt>.</p>
<p>The function does not block; instead, it returns immediately.
The request is scheduled, and its execution is performed
asynchronously. The function returns a unique identifier which is
passed by <a href="qhttp.html#requestStarted">requestStarted</a>()
and <a href="qhttp.html#requestFinished">requestFinished</a>().</p>
<p>When the request is started the <a href="qhttp.html#requestStarted">requestStarted</a>() signal is emitted.
When it is finished the <a href="qhttp.html#requestFinished">requestFinished</a>() signal is
emitted.</p>
<p><b>See also</b> <a href="qhttp.html#setHost">setHost</a>(),
<a href="qhttp.html#get">get</a>(), <a href="qhttp.html#post">post</a>(), <a href="qhttp.html#request">request</a>(), <a href="qhttp.html#requestStarted">requestStarted</a>(), <a href="qhttp.html#requestFinished">requestFinished</a>(), and <a href="qhttp.html#done">done</a>().</p>


<h3 class="fn"><a name="ignoreSslErrors" />QHttp.ignoreSslErrors (<i>self</i>)</h3><p>This method is also a Qt slot with the C++ signature <tt>void ignoreSslErrors()</tt>.</p><p>Tells the <a href="qsslsocket.html">QSslSocket</a> used for the
Http connection to ignore the errors reported in the <a href="qhttp.html#sslErrors">sslErrors</a>() signal.</p>
<p>Note that this function must be called from within a slot
connected to the <a href="qhttp.html#sslErrors">sslErrors</a>()
signal to have any effect.</p>
<p><b>See also</b> <a href="qsslsocket.html">QSslSocket</a> and
<a href="qsslsocket.html#sslErrors">QSslSocket.sslErrors</a>().</p>


<h3 class="fn"><a name="lastResponse" /><a href="qhttpresponseheader.html">QHttpResponseHeader</a> QHttp.lastResponse (<i>self</i>)</h3><p>Returns the received response header of the most recently
finished HTTP request. If no response has yet been received
<a href="qhttpheader.html#isValid">QHttpResponseHeader.isValid</a>()
will return false.</p>
<p><b>See also</b> <a href="qhttp.html#currentRequest">currentRequest</a>().</p>


<h3 class="fn"><a name="post" />int QHttp.post (<i>self</i>, QString&#160;<i>path</i>, <a href="qiodevice.html">QIODevice</a>&#160;<i>data</i>, <a href="qiodevice.html">QIODevice</a>&#160;<i>to</i>&#160;=&#160;None)</h3><p>Sends a post request for <i>path</i> to the server set by
<a href="qhttp.html#setHost">setHost</a>() or as specified in the
constructor.</p>
<p><i>path</i> must be an absolute path like <tt>/index.html</tt>
or an absolute URI like <tt>http://example.com/index.html</tt> and
must be encoded with either <a href="qurl.html#toPercentEncoding">QUrl.toPercentEncoding</a>() or
<a href="qurl.html#encodedPath">QUrl.encodedPath</a>().</p>
<p>The incoming data comes via the <i>data</i> IO device.</p>
<p>If the IO device <i>to</i> is 0 the <a href="qhttp.html#readyRead">readyRead</a>() signal is emitted every time
new content data is available to read.</p>
<p>If the IO device <i>to</i> is not 0, the content data of the
response is written directly to the device. Make sure that the
<i>to</i> pointer is valid for the duration of the operation (it is
safe to delete it when the <a href="qhttp.html#requestFinished">requestFinished</a>() signal is
emitted).</p>
<p>The function does not block; instead, it returns immediately.
The request is scheduled, and its execution is performed
asynchronously. The function returns a unique identifier which is
passed by <a href="qhttp.html#requestStarted">requestStarted</a>()
and <a href="qhttp.html#requestFinished">requestFinished</a>().</p>
<p>When the request is started the <a href="qhttp.html#requestStarted">requestStarted</a>() signal is emitted.
When it is finished the <a href="qhttp.html#requestFinished">requestFinished</a>() signal is
emitted.</p>
<p><b>See also</b> <a href="qhttp.html#setHost">setHost</a>(),
<a href="qhttp.html#get">get</a>(), <a href="qhttp.html#head">head</a>(), <a href="qhttp.html#request">request</a>(), <a href="qhttp.html#requestStarted">requestStarted</a>(), <a href="qhttp.html#requestFinished">requestFinished</a>(), and <a href="qhttp.html#done">done</a>().</p>


<h3 class="fn"><a name="post-2" />int QHttp.post (<i>self</i>, QString&#160;<i>path</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>data</i>, <a href="qiodevice.html">QIODevice</a>&#160;<i>to</i>&#160;=&#160;None)</h3><p>This is an overloaded function.</p>
<p><i>data</i> is used as the content data of the HTTP request.</p>


<h3 class="fn"><a name="read" />str QHttp.read (<i>self</i>, int&#160;<i>maxlen</i>)</h3><p>Reads <i>maxlen</i> bytes from the response content into
<i>data</i> and returns the number of bytes read. Returns -1 if an
error occurred.</p>
<p><b>See also</b> <a href="qhttp.html#get">get</a>(), <a href="qhttp.html#post">post</a>(), <a href="qhttp.html#request">request</a>(), <a href="qhttp.html#readyRead">readyRead</a>(), <a href="qhttp.html#bytesAvailable">bytesAvailable</a>(), and <a href="qhttp.html#readAll">readAll</a>().</p>


<h3 class="fn"><a name="readAll" /><a href="qbytearray.html">QByteArray</a> QHttp.readAll (<i>self</i>)</h3><p>Reads all the bytes from the response content and returns
them.</p>
<p><b>See also</b> <a href="qhttp.html#get">get</a>(), <a href="qhttp.html#post">post</a>(), <a href="qhttp.html#request">request</a>(), <a href="qhttp.html#readyRead">readyRead</a>(), <a href="qhttp.html#bytesAvailable">bytesAvailable</a>(), and <a href="qhttp.html#read">read</a>().</p>


<h3 class="fn"><a name="request" />int QHttp.request (<i>self</i>, <a href="qhttprequestheader.html">QHttpRequestHeader</a>&#160;<i>header</i>, <a href="qiodevice.html">QIODevice</a>&#160;<i>data</i>&#160;=&#160;None, <a href="qiodevice.html">QIODevice</a>&#160;<i>to</i>&#160;=&#160;None)</h3><p>Sends a request to the server set by <a href="qhttp.html#setHost">setHost</a>() or as specified in the
constructor. Uses the <i>header</i> as the HTTP request header. You
are responsible for setting up a header that is appropriate for
your request.</p>
<p>The incoming data comes via the <i>data</i> IO device.</p>
<p>If the IO device <i>to</i> is 0 the <a href="qhttp.html#readyRead">readyRead</a>() signal is emitted every time
new content data is available to read.</p>
<p>If the IO device <i>to</i> is not 0, the content data of the
response is written directly to the device. Make sure that the
<i>to</i> pointer is valid for the duration of the operation (it is
safe to delete it when the <a href="qhttp.html#requestFinished">requestFinished</a>() signal is
emitted).</p>
<p>The function does not block; instead, it returns immediately.
The request is scheduled, and its execution is performed
asynchronously. The function returns a unique identifier which is
passed by <a href="qhttp.html#requestStarted">requestStarted</a>()
and <a href="qhttp.html#requestFinished">requestFinished</a>().</p>
<p>When the request is started the <a href="qhttp.html#requestStarted">requestStarted</a>() signal is emitted.
When it is finished the <a href="qhttp.html#requestFinished">requestFinished</a>() signal is
emitted.</p>
<p><b>See also</b> <a href="qhttp.html#setHost">setHost</a>(),
<a href="qhttp.html#get">get</a>(), <a href="qhttp.html#post">post</a>(), <a href="qhttp.html#head">head</a>(),
<a href="qhttp.html#requestStarted">requestStarted</a>(), <a href="qhttp.html#requestFinished">requestFinished</a>(), and <a href="qhttp.html#done">done</a>().</p>


<h3 class="fn"><a name="request-2" />int QHttp.request (<i>self</i>, <a href="qhttprequestheader.html">QHttpRequestHeader</a>&#160;<i>header</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>data</i>, <a href="qiodevice.html">QIODevice</a>&#160;<i>to</i>&#160;=&#160;None)</h3><p>This is an overloaded function.</p>
<p><i>data</i> is used as the content data of the HTTP request.</p>


<h3 class="fn"><a name="setHost" />int QHttp.setHost (<i>self</i>, QString&#160;<i>hostName</i>, int&#160;<i>port</i>&#160;=&#160;80)</h3><p>Sets the HTTP server that is used for requests to
<i>hostName</i> on port <i>port</i>.</p>
<p>The function does not block; instead, it returns immediately.
The request is scheduled, and its execution is performed
asynchronously. The function returns a unique identifier which is
passed by <a href="qhttp.html#requestStarted">requestStarted</a>()
and <a href="qhttp.html#requestFinished">requestFinished</a>().</p>
<p>When the request is started the <a href="qhttp.html#requestStarted">requestStarted</a>() signal is emitted.
When it is finished the <a href="qhttp.html#requestFinished">requestFinished</a>() signal is
emitted.</p>
<p><b>See also</b> <a href="qhttp.html#get">get</a>(), <a href="qhttp.html#post">post</a>(), <a href="qhttp.html#head">head</a>(),
<a href="qhttp.html#request">request</a>(), <a href="qhttp.html#requestStarted">requestStarted</a>(), <a href="qhttp.html#requestFinished">requestFinished</a>(), and <a href="qhttp.html#done">done</a>().</p>


<h3 class="fn"><a name="setHost-2" />int QHttp.setHost (<i>self</i>, QString&#160;<i>hostname</i>, <a href="qhttp.html#ConnectionMode-enum">ConnectionMode</a>&#160;<i>mode</i>, int&#160;<i>port</i>&#160;=&#160;0)</h3><p>Sets the HTTP server that is used for requests to
<i>hostName</i> on port <i>port</i> using the connection mode
<i>mode</i>.</p>
<p>If port is 0, it will use the default port for the <i>mode</i>
used (80 for HTTP and 443 for HTTPS).</p>
<p>The function does not block; instead, it returns immediately.
The request is scheduled, and its execution is performed
asynchronously. The function returns a unique identifier which is
passed by <a href="qhttp.html#requestStarted">requestStarted</a>()
and <a href="qhttp.html#requestFinished">requestFinished</a>().</p>
<p>When the request is started the <a href="qhttp.html#requestStarted">requestStarted</a>() signal is emitted.
When it is finished the <a href="qhttp.html#requestFinished">requestFinished</a>() signal is
emitted.</p>
<p><b>See also</b> <a href="qhttp.html#get">get</a>(), <a href="qhttp.html#post">post</a>(), <a href="qhttp.html#head">head</a>(),
<a href="qhttp.html#request">request</a>(), <a href="qhttp.html#requestStarted">requestStarted</a>(), <a href="qhttp.html#requestFinished">requestFinished</a>(), and <a href="qhttp.html#done">done</a>().</p>


<h3 class="fn"><a name="setProxy" />int QHttp.setProxy (<i>self</i>, QString&#160;<i>host</i>, int&#160;<i>port</i>, QString&#160;<i>user</i>&#160;=&#160;QString(), QString&#160;<i>password</i>&#160;=&#160;QString())</h3><p>Enables HTTP proxy support, using the proxy server <i>host</i>
on port <i>port</i>. <i>username</i> and <i>password</i> can be
provided if the proxy server requires authentication.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type">void</span> Ticker<span class="operator">.</span>getTicks()
 {
   http <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qhttp.html">QHttp</a></span>(<span class="keyword">this</span>);
   connect(http<span class="operator">,</span> SIGNAL(done(<span class="type">bool</span>))<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> SLOT(showPage()));
   http<span class="operator">-</span><span class="operator">&gt;</span>setProxy(<span class="string">"proxy.example.com"</span><span class="operator">,</span> <span class="number">3128</span>);
   http<span class="operator">-</span><span class="operator">&gt;</span>setHost(<span class="string">"ticker.example.com"</span>);
   http<span class="operator">-</span><span class="operator">&gt;</span>get(<span class="string">"/ticks.asp"</span>);
 }

 <span class="type">void</span> Ticker<span class="operator">.</span>showPage()
 {
   display(http<span class="operator">-</span><span class="operator">&gt;</span>readAll());
 }
</pre>
<p><a class="obsolete" href="qhttp.html">QHttp</a> supports
non-transparent web proxy servers only, such as the Squid Web proxy
cache server (from <a href="http://www.squid.org/">http://www.squid.org/</a>). For transparent
proxying, such as SOCKS5, use <a href="qnetworkproxy.html">QNetworkProxy</a> instead.</p>
<p><b>Note:</b> setProxy() has to be called before <a href="qhttp.html#setHost">setHost</a>() for it to take effect. If
setProxy() is called after <a href="qhttp.html#setHost">setHost</a>(), then it will not apply until
after <a href="qhttp.html#setHost">setHost</a>() is called
again.</p>
<p><b>See also</b> <a href="qftp.html#setProxy">QFtp.setProxy</a>().</p>


<h3 class="fn"><a name="setProxy-2" />int QHttp.setProxy (<i>self</i>, <a href="qnetworkproxy.html">QNetworkProxy</a>&#160;<i>proxy</i>)</h3><p>This is an overloaded function.</p>
<p>Enables HTTP proxy support using the proxy settings from
<i>proxy</i>. If <i>proxy</i> is a transparent proxy, <a class="obsolete" href="qhttp.html">QHttp</a> will call <a href="qabstractsocket.html#setProxy">QAbstractSocket.setProxy</a>() on
the underlying socket. If the type is <a href="qnetworkproxy.html#ProxyType-enum">QNetworkProxy.HttpCachingProxy</a>,
<a class="obsolete" href="qhttp.html">QHttp</a> will behave like
the previous function.</p>
<p><b>Note:</b> for compatibility with Qt 4.3, if the proxy type is
<a href="qnetworkproxy.html#ProxyType-enum">QNetworkProxy.HttpProxy</a>
and the request type is unencrypted (that is, <a href="qhttp.html#ConnectionMode-enum">ConnectionModeHttp</a>), <a class="obsolete" href="qhttp.html">QHttp</a> will treat the proxy as a
caching proxy.</p>


<h3 class="fn"><a name="setSocket" />int QHttp.setSocket (<i>self</i>, <a href="qtcpsocket.html">QTcpSocket</a>&#160;<i>socket</i>)</h3><p>Replaces the internal <a href="qtcpsocket.html">QTcpSocket</a>
that <a class="obsolete" href="qhttp.html">QHttp</a> uses with
<i>socket</i>. This is useful if you want to use your own custom
<a href="qtcpsocket.html">QTcpSocket</a> subclass instead of the
plain <a href="qtcpsocket.html">QTcpSocket</a> that <a class="obsolete" href="qhttp.html">QHttp</a> uses by default. <a class="obsolete" href="qhttp.html">QHttp</a> does not take ownership of
the socket, and will not delete <i>socket</i> when destroyed.</p>
<p>The function does not block; instead, it returns immediately.
The request is scheduled, and its execution is performed
asynchronously. The function returns a unique identifier which is
passed by <a href="qhttp.html#requestStarted">requestStarted</a>()
and <a href="qhttp.html#requestFinished">requestFinished</a>().</p>
<p>When the request is started the <a href="qhttp.html#requestStarted">requestStarted</a>() signal is emitted.
When it is finished the <a href="qhttp.html#requestFinished">requestFinished</a>() signal is
emitted.</p>
<p>Note: If <a class="obsolete" href="qhttp.html">QHttp</a> is used
in a non-GUI thread that runs its own event loop, you must move
<i>socket</i> to that thread before calling setSocket().</p>
<p><b>See also</b> <a href="qobject.html#moveToThread">QObject.moveToThread</a>() and
<a href="threads.html">Thread Support in Qt</a>.</p>


<h3 class="fn"><a name="setUser" />int QHttp.setUser (<i>self</i>, QString&#160;<i>userName</i>, QString&#160;<i>password</i>&#160;=&#160;QString())</h3><p>This function sets the user name <i>userName</i> and password
<i>password</i> for web pages that require authentication.</p>
<p>The function does not block; instead, it returns immediately.
The request is scheduled, and its execution is performed
asynchronously. The function returns a unique identifier which is
passed by <a href="qhttp.html#requestStarted">requestStarted</a>()
and <a href="qhttp.html#requestFinished">requestFinished</a>().</p>
<p>When the request is started the <a href="qhttp.html#requestStarted">requestStarted</a>() signal is emitted.
When it is finished the <a href="qhttp.html#requestFinished">requestFinished</a>() signal is
emitted.</p>


<h3 class="fn"><a name="state" /><a href="qhttp.html#State-enum">State</a> QHttp.state (<i>self</i>)</h3><p>Returns the current state of the object. When the state changes,
the <a href="qhttp.html#stateChanged">stateChanged</a>() signal is
emitted.</p>
<p><b>See also</b> <a href="qhttp.html#State-enum">State</a> and
<a href="qhttp.html#stateChanged">stateChanged</a>().</p>


<hr /><h2>Qt Signal Documentation</h2><h3 class="fn"><a name="authenticationRequired" />void authenticationRequired (const QString&amp;,quint16,QAuthenticator *)</h3><p>This is the default overload of this signal.</p><p>This signal can be emitted when a web server on a given
<i>hostname</i> and <i>port</i> requires authentication. The
<i>authenticator</i> object can then be filled in with the required
details to allow authentication and continue the connection.</p>
<p><b>Note:</b> It is not possible to use a QueuedConnection to
connect to this signal, as the connection will fail if the
authenticator has not been filled in with new information when the
signal returns.</p>
<p>This function was introduced in Qt 4.3.</p>
<p><b>See also</b> <a href="qauthenticator.html">QAuthenticator</a>
and <a href="qnetworkproxy.html">QNetworkProxy</a>.</p>


<h3 class="fn"><a name="dataReadProgress" />void dataReadProgress (int,int)</h3><p>This is the default overload of this signal.</p><p>This signal is emitted when this object reads data from a HTTP
server to indicate the current progress of the download.</p>
<p><i>done</i> is the amount of data that has already arrived and
<i>total</i> is the total amount of data. It is possible that the
total amount of data that should be transferred cannot be
determined, in which case <i>total</i> is 0.(If you connect to a
<a href="qprogressbar.html">QProgressBar</a>, the progress bar
shows a busy indicator if the total is 0).</p>
<p><b>Warning:</b> <i>done</i> and <i>total</i> are not necessarily
the size in bytes, since for large files these values might need to
be "scaled" to avoid overflow.</p>
<p><b>See also</b> <a href="qhttp.html#dataSendProgress">dataSendProgress</a>(), <a href="qhttp.html#get">get</a>(), <a href="qhttp.html#post">post</a>(),
<a href="qhttp.html#request">request</a>(), and <a href="qprogressbar.html">QProgressBar</a>.</p>


<h3 class="fn"><a name="dataSendProgress" />void dataSendProgress (int,int)</h3><p>This is the default overload of this signal.</p><p>This signal is emitted when this object sends data to a HTTP
server to inform it about the progress of the upload.</p>
<p><i>done</i> is the amount of data that has already arrived and
<i>total</i> is the total amount of data. It is possible that the
total amount of data that should be transferred cannot be
determined, in which case <i>total</i> is 0.(If you connect to a
<a href="qprogressbar.html">QProgressBar</a>, the progress bar
shows a busy indicator if the total is 0).</p>
<p><b>Warning:</b> <i>done</i> and <i>total</i> are not necessarily
the size in bytes, since for large files these values might need to
be "scaled" to avoid overflow.</p>
<p><b>See also</b> <a href="qhttp.html#dataReadProgress">dataReadProgress</a>(), <a href="qhttp.html#post">post</a>(), <a href="qhttp.html#request">request</a>(), and <a href="qprogressbar.html">QProgressBar</a>.</p>


<h3 class="fn"><a name="done" />void done (bool)</h3><p>This is the default overload of this signal.</p><p>This signal is emitted when the last pending request has
finished; (it is emitted after the last request's <a href="qhttp.html#requestFinished">requestFinished</a>() signal).
<i>error</i> is true if an error occurred during the processing;
otherwise <i>error</i> is false.</p>
<p><b>See also</b> <a href="qhttp.html#requestFinished">requestFinished</a>(), <a href="qhttp.html#error">error</a>(), and <a href="qhttp.html#errorString">errorString</a>().</p>


<h3 class="fn"><a name="proxyAuthenticationRequired" />void proxyAuthenticationRequired (const QNetworkProxy&amp;,QAuthenticator *)</h3><p>This is the default overload of this signal.</p><p>This signal can be emitted when a <i>proxy</i> that requires
authentication is used. The <i>authenticator</i> object can then be
filled in with the required details to allow authentication and
continue the connection.</p>
<p><b>Note:</b> It is not possible to use a QueuedConnection to
connect to this signal, as the connection will fail if the
authenticator has not been filled in with new information when the
signal returns.</p>
<p>This function was introduced in Qt 4.3.</p>
<p><b>See also</b> <a href="qauthenticator.html">QAuthenticator</a>
and <a href="qnetworkproxy.html">QNetworkProxy</a>.</p>


<h3 class="fn"><a name="readyRead" />void readyRead (const QHttpResponseHeader&amp;)</h3><p>This is the default overload of this signal.</p><p>This signal is emitted when there is new response data to
read.</p>
<p>If you specified a device in the request where the data should
be written to, then this signal is <i>not</i> emitted; instead the
data is written directly to the device.</p>
<p>The response header is passed in <i>resp</i>.</p>
<p>You can read the data with the <a href="qhttp.html#readAll">readAll</a>() or <a href="qhttp.html#read">read</a>() functions</p>
<p>This signal is useful if you want to process the data in chunks
as soon as it becomes available. If you are only interested in the
complete data, just connect to the <a href="qhttp.html#requestFinished">requestFinished</a>() signal and read
the data then instead.</p>
<p><b>See also</b> <a href="qhttp.html#get">get</a>(), <a href="qhttp.html#post">post</a>(), <a href="qhttp.html#request">request</a>(), <a href="qhttp.html#readAll">readAll</a>(), <a href="qhttp.html#read">read</a>(), and <a href="qhttp.html#bytesAvailable">bytesAvailable</a>().</p>


<h3 class="fn"><a name="requestFinished" />void requestFinished (int,bool)</h3><p>This is the default overload of this signal.</p><p>This signal is emitted when processing the request identified by
<i>id</i> has finished. <i>error</i> is true if an error occurred
during the processing; otherwise <i>error</i> is false.</p>
<p><b>See also</b> <a href="qhttp.html#requestStarted">requestStarted</a>(), <a href="qhttp.html#done">done</a>(), <a href="qhttp.html#error">error</a>(), and <a href="qhttp.html#errorString">errorString</a>().</p>


<h3 class="fn"><a name="requestStarted" />void requestStarted (int)</h3><p>This is the default overload of this signal.</p><p>This signal is emitted when processing the request identified by
<i>id</i> starts.</p>
<p><b>See also</b> <a href="qhttp.html#requestFinished">requestFinished</a>() and <a href="qhttp.html#done">done</a>().</p>


<h3 class="fn"><a name="responseHeaderReceived" />void responseHeaderReceived (const QHttpResponseHeader&amp;)</h3><p>This is the default overload of this signal.</p><p>This signal is emitted when the HTTP header of a server response
is available. The header is passed in <i>resp</i>.</p>
<p><b>See also</b> <a href="qhttp.html#get">get</a>(), <a href="qhttp.html#post">post</a>(), <a href="qhttp.html#head">head</a>(),
<a href="qhttp.html#request">request</a>(), and <a href="qhttp.html#readyRead">readyRead</a>().</p>


<h3 class="fn"><a name="sslErrors" />void sslErrors (const QList&lt;QSslError&gt;&amp;)</h3><p>This is the default overload of this signal.</p><p>Forwards the sslErrors signal from the <a href="qsslsocket.html">QSslSocket</a> used in <a class="obsolete" href="qhttp.html">QHttp</a>. <i>errors</i> is the list of errors
that occurred during the SSL handshake. Unless you call <a href="qhttp.html#ignoreSslErrors">ignoreSslErrors</a>() from within a
slot connected to this signal when an error occurs, <a class="obsolete" href="qhttp.html">QHttp</a> will tear down the
connection immediately after emitting the signal.</p>
<p>This function was introduced in Qt 4.3.</p>
<p><b>See also</b> <a href="qsslsocket.html">QSslSocket</a> and
<a href="qsslsocket.html#ignoreSslErrors">QSslSocket.ignoreSslErrors</a>().</p>


<h3 class="fn"><a name="stateChanged" />void stateChanged (int)</h3><p>This is the default overload of this signal.</p><p>This signal is emitted when the state of the <a class="obsolete" href="qhttp.html">QHttp</a> object changes. The
argument <i>state</i> is the new state of the connection; it is one
of the <a href="qhttp.html#State-enum">State</a> values.</p>
<p>This usually happens when a request is started, but it can also
happen when the server closes the connection or when a call to
<a href="qhttp.html#close">close</a>() succeeded.</p>
<p><b>See also</b> <a href="qhttp.html#get">get</a>(), <a href="qhttp.html#post">post</a>(), <a href="qhttp.html#head">head</a>(),
<a href="qhttp.html#request">request</a>(), <a href="qhttp.html#close">close</a>(), <a href="qhttp.html#state">state</a>(), and <a href="qhttp.html#State-enum">State</a>.</p>
<address><hr /><div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address"><td align="left" width="25%">PyQt&#160;4.10 for Windows</td><td align="center" width="50%">Copyright &#169; <a href="http://www.riverbankcomputing.com">Riverbank&#160;Computing&#160;Ltd</a> and <a href="http://www.qtsoftware.com">Nokia</a> 2012</td><td align="right" width="25%">Qt&#160;4.8.4</td></tr></table></div></address></body></html>