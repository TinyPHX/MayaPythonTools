// qgraphicsscene.sip generated by MetaSIP on Fri Mar  1 21:45:59 2013
//
// This file is part of the QtGui Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// If you are unsure which license is appropriate for your use, please
// contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%If (Qt_4_2_0 -)
%ModuleCode
#include <qgraphicsscene.h>
%End
%End

%If (Qt_4_2_0 -)

class QGraphicsScene : QObject
{
%TypeHeaderCode
#include <qgraphicsscene.h>
%End

public:
    enum ItemIndexMethod
    {
        BspTreeIndex,
        NoIndex,
    };

    QGraphicsScene(QObject *parent /TransferThis/ = 0);
    QGraphicsScene(const QRectF &sceneRect, QObject *parent /TransferThis/ = 0);
    QGraphicsScene(qreal x, qreal y, qreal width, qreal height, QObject *parent /TransferThis/ = 0);
    virtual ~QGraphicsScene();
    QRectF sceneRect() const;
    qreal width() const;
    qreal height() const;
    void setSceneRect(const QRectF &rect);
    void setSceneRect(qreal x, qreal y, qreal w, qreal h);
    void render(QPainter *painter, const QRectF &target = QRectF(), const QRectF &source = QRectF(), Qt::AspectRatioMode mode = Qt::KeepAspectRatio);
    QGraphicsScene::ItemIndexMethod itemIndexMethod() const;
    void setItemIndexMethod(QGraphicsScene::ItemIndexMethod method);
    QRectF itemsBoundingRect() const;
%If (Qt_5_0_0 -)
    QList<QGraphicsItem*> items(Qt::SortOrder order = Qt::DescendingOrder) const;
%End
%If (- Qt_5_0_0)
    QList<QGraphicsItem*> items() const;
%End
%If (Qt_4_6_0 - Qt_5_0_0)
    QList<QGraphicsItem*> items(Qt::SortOrder order) const;
%End
%If (Qt_5_0_0 -)
    QList<QGraphicsItem*> items(const QPointF &pos, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape, Qt::SortOrder order = Qt::DescendingOrder, const QTransform &deviceTransform = QTransform()) const;
%End
%If (- Qt_5_0_0)
    QList<QGraphicsItem*> items(const QPointF &pos) const;
%End
%If (Qt_4_6_0 - Qt_5_0_0)
    QList<QGraphicsItem*> items(const QPointF &pos, Qt::ItemSelectionMode mode, Qt::SortOrder order, const QTransform &deviceTransform = QTransform()) const;
%End
%If (Qt_5_0_0 -)
    QList<QGraphicsItem*> items(const QRectF &rect, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape, Qt::SortOrder order = Qt::DescendingOrder, const QTransform &deviceTransform = QTransform()) const;
%End
%If (- Qt_5_0_0)
    QList<QGraphicsItem*> items(const QRectF &rectangle, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
%End
%If (Qt_4_6_0 - Qt_5_0_0)
    QList<QGraphicsItem*> items(const QRectF &rect, Qt::ItemSelectionMode mode, Qt::SortOrder order, const QTransform &deviceTransform = QTransform()) const;
%End
%If (Qt_5_0_0 -)
    QList<QGraphicsItem*> items(const QPolygonF &polygon, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape, Qt::SortOrder order = Qt::DescendingOrder, const QTransform &deviceTransform = QTransform()) const;
%End
%If (- Qt_5_0_0)
    QList<QGraphicsItem*> items(const QPolygonF &polygon, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
%End
%If (Qt_4_6_0 - Qt_5_0_0)
    QList<QGraphicsItem*> items(const QPolygonF &polygon, Qt::ItemSelectionMode mode, Qt::SortOrder order, const QTransform &deviceTransform = QTransform()) const;
%End
%If (Qt_5_0_0 -)
    QList<QGraphicsItem*> items(const QPainterPath &path, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape, Qt::SortOrder order = Qt::DescendingOrder, const QTransform &deviceTransform = QTransform()) const;
%End
%If (- Qt_5_0_0)
    QList<QGraphicsItem*> items(const QPainterPath &path, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
%End
%If (Qt_4_6_0 - Qt_5_0_0)
    QList<QGraphicsItem*> items(const QPainterPath &path, Qt::ItemSelectionMode mode, Qt::SortOrder order, const QTransform &deviceTransform = QTransform()) const;
%End
%If (Qt_4_3_0 -)
%If (PyQt_Deprecated_5_0)
    QList<QGraphicsItem*> items(qreal x, qreal y, qreal w, qreal h, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
%End
%End
%If (Qt_4_6_0 -)
    QList<QGraphicsItem*> items(qreal x, qreal y, qreal w, qreal h, Qt::ItemSelectionMode mode, Qt::SortOrder order, const QTransform &deviceTransform = QTransform()) const;
%End
    QList<QGraphicsItem*> collidingItems(const QGraphicsItem *item, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
%If (PyQt_Deprecated_5_0)
    QGraphicsItem *itemAt(const QPointF &pos) const;
%End
%If (PyQt_Deprecated_5_0)
    QGraphicsItem *itemAt(qreal x, qreal y) const;
%End
    QList<QGraphicsItem*> selectedItems() const;
%If (Qt_4_6_0 -)
    void setSelectionArea(const QPainterPath &path, const QTransform &deviceTransform);
%End
%If (Qt_5_0_0 -)
    void setSelectionArea(const QPainterPath &path, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape, const QTransform &deviceTransform = QTransform());
%End
%If (- Qt_5_0_0)
    void setSelectionArea(const QPainterPath &path);
%End
%If (Qt_4_3_0 - Qt_5_0_0)
    void setSelectionArea(const QPainterPath &path, Qt::ItemSelectionMode);
%End
%If (Qt_4_6_0 - Qt_5_0_0)
    void setSelectionArea(const QPainterPath &path, Qt::ItemSelectionMode mode, const QTransform &deviceTransform);
%End
    void clearSelection();
    QGraphicsItemGroup *createItemGroup(const QList<QGraphicsItem*> &items /Transfer/);
    void destroyItemGroup(QGraphicsItemGroup *group /Transfer/);
    void addItem(QGraphicsItem *item /Transfer/);
    QGraphicsEllipseItem *addEllipse(const QRectF &rect, const QPen &pen = QPen(), const QBrush &brush = QBrush());
%If (Qt_4_3_0 -)
    QGraphicsEllipseItem *addEllipse(qreal x, qreal y, qreal w, qreal h, const QPen &pen = QPen(), const QBrush &brush = QBrush());
%End
    QGraphicsLineItem *addLine(const QLineF &line, const QPen &pen = QPen());
%If (Qt_4_3_0 -)
    QGraphicsLineItem *addLine(qreal x1, qreal y1, qreal x2, qreal y2, const QPen &pen = QPen());
%End
    QGraphicsPathItem *addPath(const QPainterPath &path, const QPen &pen = QPen(), const QBrush &brush = QBrush());
    QGraphicsPixmapItem *addPixmap(const QPixmap &pixmap);
    QGraphicsPolygonItem *addPolygon(const QPolygonF &polygon, const QPen &pen = QPen(), const QBrush &brush = QBrush());
    QGraphicsRectItem *addRect(const QRectF &rect, const QPen &pen = QPen(), const QBrush &brush = QBrush());
%If (Qt_4_3_0 -)
    QGraphicsRectItem *addRect(qreal x, qreal y, qreal w, qreal h, const QPen &pen = QPen(), const QBrush &brush = QBrush());
%End
%If (Qt_4_3_0 -)
    QGraphicsSimpleTextItem *addSimpleText(const QString &text, const QFont &font = QFont());
%End
    QGraphicsTextItem *addText(const QString &text, const QFont &font = QFont());
    void removeItem(QGraphicsItem *item /TransferBack/);
    QGraphicsItem *focusItem() const;
    void setFocusItem(QGraphicsItem *item, Qt::FocusReason focusReason = Qt::OtherFocusReason);
    bool hasFocus() const;
    void setFocus(Qt::FocusReason focusReason = Qt::OtherFocusReason);
    void clearFocus();
    QGraphicsItem *mouseGrabberItem() const;
    QBrush backgroundBrush() const;
    void setBackgroundBrush(const QBrush &brush);
    QBrush foregroundBrush() const;
    void setForegroundBrush(const QBrush &brush);
    virtual QVariant inputMethodQuery(Qt::InputMethodQuery query) const;
    QList<QGraphicsView*> views() const;

public slots:
    void advance();
    void update(const QRectF &rect = QRectF());
%If (Qt_4_3_0 -)
    void invalidate(const QRectF &rect = QRectF(), QFlags<QGraphicsScene::SceneLayer> layers = QGraphicsScene::AllLayers);
%End
%If (Qt_4_4_0 -)
    void clear();
%End

signals:
    void changed(const QList<QRectF> &region);
    void sceneRectChanged(const QRectF &rect);
%If (Qt_4_3_0 -)
    void selectionChanged();
%End

protected:
    virtual bool event(QEvent *event);
    virtual void contextMenuEvent(QGraphicsSceneContextMenuEvent *event);
    virtual void dragEnterEvent(QGraphicsSceneDragDropEvent *event);
    virtual void dragMoveEvent(QGraphicsSceneDragDropEvent *event);
    virtual void dragLeaveEvent(QGraphicsSceneDragDropEvent *event);
    virtual void dropEvent(QGraphicsSceneDragDropEvent *event);
    virtual void focusInEvent(QFocusEvent *event);
    virtual void focusOutEvent(QFocusEvent *event);
    virtual void helpEvent(QGraphicsSceneHelpEvent *event);
    virtual void keyPressEvent(QKeyEvent *event);
    virtual void keyReleaseEvent(QKeyEvent *event);
    virtual void mousePressEvent(QGraphicsSceneMouseEvent *event);
    virtual void mouseMoveEvent(QGraphicsSceneMouseEvent *event);
    virtual void mouseReleaseEvent(QGraphicsSceneMouseEvent *event);
    virtual void mouseDoubleClickEvent(QGraphicsSceneMouseEvent *event);
    virtual void wheelEvent(QGraphicsSceneWheelEvent *event);
    virtual void inputMethodEvent(QInputMethodEvent *event);
    virtual void drawBackground(QPainter *painter, const QRectF &rect);
    virtual void drawForeground(QPainter *painter, const QRectF &rect);
    virtual void drawItems(QPainter *painter, SIP_PYLIST items /DocType="list-of-QGraphicsItem"/, SIP_PYLIST options /DocType="list-of-QStyleOptionGraphicsItem"/, QWidget *widget = 0) [void (QPainter *painter, int numItems, QGraphicsItem **items, const QStyleOptionGraphicsItem *options, QWidget *widget = 0)];
%MethodCode
        // PyQt takes lists as the items and options arguments.
        
        // Adjust the number items according to the actual list lengths.
        SIP_SSIZE_T numItems = PyList_GET_SIZE(a1);
        
        if (numItems > PyList_GET_SIZE(a2))
            numItems = PyList_GET_SIZE(a2);
        
        // Allocate temporary storage for the C++ conversions.
        QGraphicsItem **items = new QGraphicsItem *[numItems];
        QStyleOptionGraphicsItem *options = new QStyleOptionGraphicsItem[numItems];
        
        for (int i = 0; i < numItems; ++i)
        {
            void *cpp;
        
            cpp = sipForceConvertToType(PyList_GET_ITEM(a1, i), sipType_QGraphicsItem, NULL, SIP_NO_CONVERTORS, NULL, &sipIsErr);
            items[i] = reinterpret_cast<QGraphicsItem *>(cpp);
        
            cpp = sipForceConvertToType(PyList_GET_ITEM(a2, i), sipType_QStyleOptionGraphicsItem, NULL, SIP_NOT_NONE|SIP_NO_CONVERTORS, NULL, &sipIsErr);
            options[i] = *reinterpret_cast<QStyleOptionGraphicsItem *>(cpp);
        }
        
        if (!sipIsErr)
        {
            Py_BEGIN_ALLOW_THREADS
        #if defined(SIP_PROTECTED_IS_PUBLIC)
            if (sipSelfWasArg)
                sipCpp->QGraphicsScene::drawItems(a0, numItems, items, options, a3);
            else
                sipCpp->drawItems(a0, numItems, items, options, a3);
        #else
            sipCpp->sipProtectVirt_drawItems(sipSelfWasArg, a0, numItems, items, options, a3);
        #endif
            Py_END_ALLOW_THREADS
        }
        
        delete[] items;
        delete[] options;
%End

%VirtualCatcherCode
        // PyQt handles the items and options arguments as lists, but keeps the
        // numItems argument.
        PyObject *items = PyList_New(a1);
        PyObject *options = PyList_New(a1);
        
        sipIsErr = (!items || !options);
        
        if (!sipIsErr)
            for (int i = 0; i < a1; ++i)
            {
                PyObject *obj;
        
                obj = sipConvertFromType(a2[i], sipType_QGraphicsItem, 0);
        
                if (!obj)
                {
                    sipIsErr = true;
                    break;
                }
        
                PyList_SET_ITEM(items, i, obj);
        
                obj = sipConvertFromType(const_cast<QStyleOptionGraphicsItem *>(&a3[i]), sipType_QStyleOptionGraphicsItem, 0);
        
                if (!obj)
                {
                    sipIsErr = true;
                    break;
                }
        
                PyList_SET_ITEM(options, i, obj);
            }
        
        if (!sipIsErr)
        {
            PyObject *res = sipCallMethod(&sipIsErr, sipMethod, "DSSD", a0, sipType_QPainter, NULL, items, options, a4, sipType_QWidget, NULL);
        
            if (res)
            {
                sipParseResult(&sipIsErr, sipMethod, res, "Z");
                Py_DECREF(res);
            }
        }
        
        Py_XDECREF(items);
        Py_XDECREF(options);
%End

public:
%If (Qt_4_3_0 -)

    enum SceneLayer
    {
        ItemLayer,
        BackgroundLayer,
        ForegroundLayer,
        AllLayers,
    };

%End
%If (Qt_4_3_0 -)
    typedef QFlags<QGraphicsScene::SceneLayer> SceneLayers;
%End
%If (Qt_4_3_0 -)
    int bspTreeDepth() const;
%End
%If (Qt_4_3_0 -)
    void setBspTreeDepth(int depth);
%End
%If (Qt_4_3_0 -)
    QPainterPath selectionArea() const;
%End
%If (Qt_4_3_0 -)
    void update(qreal x, qreal y, qreal w, qreal h);
%End
%If (Qt_4_3_0 -)
    void invalidate(qreal x, qreal y, qreal w, qreal h, QFlags<QGraphicsScene::SceneLayer> layers = QGraphicsScene::AllLayers);
%End
%If (Qt_4_4_0 -)
    QGraphicsProxyWidget *addWidget(QWidget *widget /Transfer/, Qt::WindowFlags flags = 0);
%End
%If (Qt_4_4_0 -)
    QStyle *style() const;
%End
%If (Qt_4_4_0 -)
    void setStyle(QStyle *style /Transfer/);
%End
%If (Qt_4_4_0 -)
    QFont font() const;
%End
%If (Qt_4_4_0 -)
    void setFont(const QFont &font);
%End
%If (Qt_4_4_0 -)
    QPalette palette() const;
%End
%If (Qt_4_4_0 -)
    void setPalette(const QPalette &palette);
%End
%If (Qt_4_4_0 -)
    QGraphicsWidget *activeWindow() const;
%End
%If (Qt_4_4_0 -)
    void setActiveWindow(QGraphicsWidget *widget);
%End

protected:
%If (Qt_4_4_0 -)
    virtual bool eventFilter(QObject *watched, QEvent *event);
%End
%If (Qt_4_4_0 -)
    bool focusNextPrevChild(bool next);
%End

public:
%If (Qt_4_5_0 -)
    bool isSortCacheEnabled() const;
%End
%If (Qt_4_5_0 -)
    void setSortCacheEnabled(bool enabled);
%End
%If (Qt_4_5_0 -)
    void setStickyFocus(bool enabled);
%End
%If (Qt_4_5_0 -)
    bool stickyFocus() const;
%End
%If (Qt_4_6_0 -)
    QGraphicsItem *itemAt(const QPointF &pos, const QTransform &deviceTransform) const;
%End
%If (Qt_4_6_0 -)
    QGraphicsItem *itemAt(qreal x, qreal y, const QTransform &deviceTransform) const;
%End
%If (Qt_4_6_0 -)
    bool isActive() const;
%End
%If (Qt_4_6_0 -)
    QGraphicsItem *activePanel() const;
%End
%If (Qt_4_6_0 -)
    void setActivePanel(QGraphicsItem *item);
%End
%If (Qt_4_6_0 -)
    bool sendEvent(QGraphicsItem *item, QEvent *event);
%End

private:
%If (Qt_4_4_0 -)
    QGraphicsScene(const QGraphicsScene &);
%End
};

%End
%If (Qt_4_3_0 -)
QFlags<QGraphicsScene::SceneLayer> operator|(QGraphicsScene::SceneLayer f1, QFlags<QGraphicsScene::SceneLayer> f2);
%End
