// qxmlstream.sip generated by MetaSIP on Fri Mar  1 21:46:02 2013
//
// This file is part of the QtXml Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// If you are unsure which license is appropriate for your use, please
// contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%If (Qt_4_3_0 - Qt_4_4_0)

class QXmlStreamAttribute
{
%TypeHeaderCode
#include <qxmlstream.h>
%End

public:
    QXmlStreamAttribute();
    QXmlStreamAttribute(const QString &qualifiedName, const QString &value);
    QXmlStreamAttribute(const QString &namespaceUri, const QString &name, const QString &value);
    QXmlStreamAttribute(const QXmlStreamAttribute &);
    ~QXmlStreamAttribute();
    QStringRef namespaceUri() const;
    QStringRef name() const;
    QStringRef qualifiedName() const;
    QStringRef value() const;
    bool isDefault() const;
    bool operator==(const QXmlStreamAttribute &other) const;
    bool operator!=(const QXmlStreamAttribute &other) const;
};

%End
%If (Qt_4_3_0 - Qt_4_4_0)

class QXmlStreamAttributes
{
%TypeHeaderCode
#include <qxmlstream.h>
%End

public:
    QStringRef value(const QString &namespaceUri, const QString &name) const;
    QStringRef value(const QString &qualifiedName) const;
    void append(const QString &namespaceUri, const QString &name, const QString &value);
    void append(const QString &qualifiedName, const QString &value);
    void append(const QXmlStreamAttribute &attribute);
// Methods inherited from QVector<QXmlStreamAttribute> and Python special methods.
// Keep in sync with QPolygon and QPolygonF.

// This is picked up with "using" by QXmlStreamAttributes.
//void append(const QXmlStreamAttribute &value);

const QXmlStreamAttribute &at(int i) const;
void clear();
bool contains(const QXmlStreamAttribute &value) const;
int count(const QXmlStreamAttribute &value) const;
int count() const /__len__/;
void *data();

// Note the Qt return value is discarded as it would require handwritten code
// and seems pretty useless.
void fill(const QXmlStreamAttribute &value, int size = -1);

QXmlStreamAttribute &first();
int indexOf(const QXmlStreamAttribute &value, int from = 0) const;
void insert(int i, const QXmlStreamAttribute &value);
bool isEmpty() const;
QXmlStreamAttribute &last();
int lastIndexOf(const QXmlStreamAttribute &value, int from = -1) const;

// Note the Qt return type is QVector<QXmlStreamAttribute>.  We can't do the
// usual trick because there is no QXmlStreamAttributes ctor that takes a
// QVector<QXmlStreamAttribute> argument.  We could use handwritten code but we
// don't bother.
//QXmlStreamAttributes mid(int pos, int length = -1) const;

void prepend(const QXmlStreamAttribute &value);
void remove(int i);
void remove(int i, int count);
void replace(int i, const QXmlStreamAttribute &value);
int size() const;

// These are hidden by other implementations in QXmlStreamAttributes.
//QXmlStreamAttribute value(int i) const;
//QXmlStreamAttribute value(int i, const QXmlStreamAttribute &defaultValue) const;

bool operator!=(const QXmlStreamAttributes &other) const;

// Note the Qt return type is QVector<QXmlStreamAttribute>.  We can't do the
// usual trick because there is no QXmlStreamAttributes ctor that takes a
// QVector<QXmlStreamAttribute> argument.  We could use handwritten code but we
// don't bother.
//QXmlStreamAttributes operator+(const QXmlStreamAttributes &other) const;

QXmlStreamAttributes &operator+=(const QXmlStreamAttributes &other);
QXmlStreamAttributes &operator+=(const QXmlStreamAttribute &value);

bool operator==(const QXmlStreamAttributes &other) const;

SIP_PYOBJECT operator<<(const QXmlStreamAttribute &value);
%MethodCode
    *a0 << *a1;

    sipRes = sipArg0;
    Py_INCREF(sipRes);
%End

QXmlStreamAttribute &operator[](int i);
%MethodCode
SIP_SSIZE_T idx = sipConvertFromSequenceIndex(a0, sipCpp->count());

if (idx < 0)
    sipIsErr = 1;
else
    sipRes = new QXmlStreamAttribute(sipCpp->operator[]((int)idx));
%End

// Some additional Python special methods.

void __setitem__(int i, const QXmlStreamAttribute &value);
%MethodCode
int len;

len = sipCpp->count();

if ((a0 = (int)sipConvertFromSequenceIndex(a0, len)) < 0)
    sipIsErr = 1;
else
    (*sipCpp)[a0] = *a1;
%End

void __setitem__(SIP_PYSLICE slice, const QXmlStreamAttributes &list);
%MethodCode
SIP_SSIZE_T len, start, stop, step, slicelength, i;

len = sipCpp->count();

#if PY_VERSION_HEX >= 0x03020000
if (PySlice_GetIndicesEx(a0, len, &start, &stop, &step, &slicelength) < 0)
#else
if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
#endif
    sipIsErr = 1;
else
{
    int vlen = a1->count();

    if (vlen != slicelength)
    {
        sipBadLengthForSlice(vlen, slicelength);
        sipIsErr = 1;
    }
    else
    {
        QVector<QXmlStreamAttribute>::const_iterator it = a1->begin();

        for (i = 0; i < slicelength; ++i)
        {
            (*sipCpp)[start] = *it;
            start += step;
            ++it;
        }
    }
}
%End

void __delitem__(int i);
%MethodCode
int len;

len = sipCpp->count();

if ((a0 = (int)sipConvertFromSequenceIndex(a0, len)) < 0)
    sipIsErr = 1;
else
    sipCpp->remove(a0);
%End

void __delitem__(SIP_PYSLICE slice);
%MethodCode
SIP_SSIZE_T len, start, stop, step, slicelength, i;

len = sipCpp->count();

#if PY_VERSION_HEX >= 0x03020000
if (PySlice_GetIndicesEx(a0, len, &start, &stop, &step, &slicelength) < 0)
#else
if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
#endif
    sipIsErr = 1;
else
    for (i = 0; i < slicelength; ++i)
    {
        sipCpp->remove(start);
        start += step - 1;
    }
%End

QXmlStreamAttributes &operator[](SIP_PYSLICE slice);
%MethodCode
SIP_SSIZE_T len, start, stop, step, slicelength, i;

len = sipCpp->count();

#if PY_VERSION_HEX >= 0x03020000
if (PySlice_GetIndicesEx(a0, len, &start, &stop, &step, &slicelength) < 0)
#else
if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
#endif
    sipIsErr = 1;
else
{
    sipRes = new QXmlStreamAttributes();

    for (i = 0; i < slicelength; ++i)
    {
        (*sipRes) += (*sipCpp)[start];
        start += step;
    }
}
%End

int __contains__(const QXmlStreamAttribute &value);
%MethodCode
// It looks like you can't assign QBool to int.
sipRes = bool(sipCpp->contains(*a0));
%End
};

%End
%If (Qt_4_3_0 - Qt_4_4_0)

class QXmlStreamNamespaceDeclaration
{
%TypeHeaderCode
#include <qxmlstream.h>
%End

public:
    QXmlStreamNamespaceDeclaration();
    QXmlStreamNamespaceDeclaration(const QXmlStreamNamespaceDeclaration &);
    ~QXmlStreamNamespaceDeclaration();
    QStringRef prefix() const;
    QStringRef namespaceUri() const;
    bool operator==(const QXmlStreamNamespaceDeclaration &other) const;
    bool operator!=(const QXmlStreamNamespaceDeclaration &other) const;
};

%End
%If (Qt_4_3_0 - Qt_4_4_0)
typedef QVector<QXmlStreamNamespaceDeclaration> QXmlStreamNamespaceDeclarations;
%End
%If (Qt_4_3_0 - Qt_4_4_0)

class QXmlStreamNotationDeclaration
{
%TypeHeaderCode
#include <qxmlstream.h>
%End

public:
    QXmlStreamNotationDeclaration();
    QXmlStreamNotationDeclaration(const QXmlStreamNotationDeclaration &);
    ~QXmlStreamNotationDeclaration();
    QStringRef name() const;
    QStringRef systemId() const;
    QStringRef publicId() const;
    bool operator==(const QXmlStreamNotationDeclaration &other) const;
    bool operator!=(const QXmlStreamNotationDeclaration &other) const;
};

%End
%If (Qt_4_3_0 - Qt_4_4_0)
typedef QVector<QXmlStreamNotationDeclaration> QXmlStreamNotationDeclarations;
%End
%If (Qt_4_3_0 - Qt_4_4_0)

class QXmlStreamEntityDeclaration
{
%TypeHeaderCode
#include <qxmlstream.h>
%End

public:
    QXmlStreamEntityDeclaration();
    QXmlStreamEntityDeclaration(const QXmlStreamEntityDeclaration &);
    ~QXmlStreamEntityDeclaration();
    QStringRef name() const;
    QStringRef notationName() const;
    QStringRef systemId() const;
    QStringRef publicId() const;
    QStringRef value() const;
    bool operator==(const QXmlStreamEntityDeclaration &other) const;
    bool operator!=(const QXmlStreamEntityDeclaration &other) const;
};

%End
%If (Qt_4_3_0 - Qt_4_4_0)
typedef QVector<QXmlStreamEntityDeclaration> QXmlStreamEntityDeclarations;
%End
%If (Qt_4_3_0 - Qt_4_4_0)

class QXmlStreamReader
{
%TypeHeaderCode
#include <qxmlstream.h>
%End

public:
    enum Error
    {
        NoError,
        UnexpectedElementError,
        CustomError,
        NotWellFormedError,
        PrematureEndOfDocumentError,
    };

    enum TokenType
    {
        NoToken,
        Invalid,
        StartDocument,
        EndDocument,
        StartElement,
        EndElement,
        Characters,
        Comment,
        DTD,
        EntityReference,
        ProcessingInstruction,
    };

    QXmlStreamReader();
    QXmlStreamReader(QIODevice *device);
    QXmlStreamReader(const QByteArray &data);
    QXmlStreamReader(const QString &data);
    ~QXmlStreamReader();
    void setDevice(QIODevice *device);
    QIODevice *device() const;
    void addData(const QByteArray &data);
    void addData(const QString &data);
    void clear();
    bool atEnd() const;
    QXmlStreamReader::TokenType readNext();
    QXmlStreamReader::TokenType tokenType() const;
    QString tokenString() const;
    void setNamespaceProcessing(bool);
    bool namespaceProcessing() const;
    bool isStartDocument() const;
    bool isEndDocument() const;
    bool isStartElement() const;
    bool isEndElement() const;
    bool isCharacters() const;
    bool isWhitespace() const;
    bool isCDATA() const;
    bool isComment() const;
    bool isDTD() const;
    bool isEntityReference() const;
    bool isProcessingInstruction() const;
    bool isStandaloneDocument() const;
    qint64 lineNumber() const;
    qint64 columnNumber() const;
    qint64 characterOffset() const;
    QXmlStreamAttributes attributes() const;
    QString readElementText();
    QStringRef name() const;
    QStringRef namespaceUri() const;
    QStringRef qualifiedName() const;
    QStringRef processingInstructionTarget() const;
    QStringRef processingInstructionData() const;
    QStringRef text() const;
    QXmlStreamNamespaceDeclarations namespaceDeclarations() const;
    QXmlStreamNotationDeclarations notationDeclarations() const;
    QXmlStreamEntityDeclarations entityDeclarations() const;
    void raiseError(const QString &message /DocValue="Py_v3:''"/ = QString());
    QString errorString() const;
    QXmlStreamReader::Error error() const;
    bool hasError() const;

private:
    QXmlStreamReader(const QXmlStreamReader &);
};

%End
%If (Qt_4_3_0 - Qt_4_4_0)

class QXmlStreamWriter
{
%TypeHeaderCode
#include <qxmlstream.h>
%End

public:
    QXmlStreamWriter();
    QXmlStreamWriter(QIODevice *device);
    QXmlStreamWriter(QByteArray *array);
    QXmlStreamWriter(QString *string /Constrained/) /API=QString: - 2/;
    ~QXmlStreamWriter();
    void setDevice(QIODevice *device);
    QIODevice *device() const;
    void setCodec(QTextCodec *codec /KeepReference/);
    void setCodec(const char *codecName);
    QTextCodec *codec() const;
    void setAutoFormatting(bool);
    bool autoFormatting() const;
    void writeAttribute(const QString &qualifiedName, const QString &value);
    void writeAttribute(const QString &namespaceUri, const QString &name, const QString &value);
    void writeAttribute(const QXmlStreamAttribute &attribute);
    void writeAttributes(const QXmlStreamAttributes &attributes);
    void writeCDATA(const QString &text);
    void writeCharacters(const QString &text);
    void writeComment(const QString &text);
    void writeDTD(const QString &dtd);
    void writeEmptyElement(const QString &qualifiedName);
    void writeEmptyElement(const QString &namespaceUri, const QString &name);
    void writeTextElement(const QString &qualifiedName, const QString &text);
    void writeTextElement(const QString &namespaceUri, const QString &name, const QString &text);
    void writeEndDocument();
    void writeEndElement();
    void writeEntityReference(const QString &name);
    void writeNamespace(const QString &namespaceUri, const QString &prefix /DocValue="Py_v3:''"/ = QString());
    void writeDefaultNamespace(const QString &namespaceUri);
    void writeProcessingInstruction(const QString &target, const QString &data /DocValue="Py_v3:''"/ = QString());
    void writeStartDocument();
    void writeStartDocument(const QString &version);
    void writeStartElement(const QString &qualifiedName);
    void writeStartElement(const QString &namespaceUri, const QString &name);
    void writeCurrentToken(const QXmlStreamReader &reader);

private:
    QXmlStreamWriter(const QXmlStreamWriter &);
};

%End
