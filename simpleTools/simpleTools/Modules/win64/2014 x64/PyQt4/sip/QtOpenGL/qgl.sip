// qgl.sip generated by MetaSIP on Fri Mar  1 21:46:01 2013
//
// This file is part of the QtOpenGL Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// If you are unsure which license is appropriate for your use, please
// contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%ModuleCode
#include <qgl.h>
%End

%Include opengl_types.sip

namespace QGL
{
%TypeHeaderCode
#include <qgl.h>
%End

    enum FormatOption
    {
        DoubleBuffer,
        DepthBuffer,
        Rgba,
        AlphaChannel,
        AccumBuffer,
        StencilBuffer,
        StereoBuffers,
        DirectRendering,
        HasOverlay,
        SampleBuffers,
        SingleBuffer,
        NoDepthBuffer,
        ColorIndex,
        NoAlphaChannel,
        NoAccumBuffer,
        NoStencilBuffer,
        NoStereoBuffers,
        IndirectRendering,
        NoOverlay,
        NoSampleBuffers,
%If (Qt_4_7_0 -)
        DeprecatedFunctions,
%End
%If (Qt_4_7_0 -)
        NoDeprecatedFunctions,
%End
    };

    typedef QFlags<QGL::FormatOption> FormatOptions;
%If (Qt_4_6_0 - Qt_5_0_0)
    void setPreferredPaintEngine(QPaintEngine::Type engineType);
%End
};

QFlags<QGL::FormatOption> operator|(QGL::FormatOption f1, QFlags<QGL::FormatOption> f2);

class QGLFormat
{
%TypeHeaderCode
#include <qgl.h>
%End

public:
%If (Qt_4_2_0 -)

    enum OpenGLVersionFlag
    {
        OpenGL_Version_None,
        OpenGL_Version_1_1,
        OpenGL_Version_1_2,
        OpenGL_Version_1_3,
        OpenGL_Version_1_4,
        OpenGL_Version_1_5,
        OpenGL_Version_2_0,
        OpenGL_Version_2_1,
%If (Qt_4_5_0 -)
        OpenGL_Version_3_0,
%End
%If (Qt_4_7_0 -)
        OpenGL_Version_3_1,
%End
%If (Qt_4_7_0 -)
        OpenGL_Version_3_2,
%End
%If (Qt_4_7_0 -)
        OpenGL_Version_3_3,
%End
%If (Qt_4_7_0 -)
        OpenGL_Version_4_0,
%End
%If (Qt_5_0_0 -)
        OpenGL_Version_4_1,
%End
%If (Qt_5_0_0 -)
        OpenGL_Version_4_2,
%End
%If (Qt_5_0_0 -)
        OpenGL_Version_4_3,
%End
        OpenGL_ES_Common_Version_1_0,
        OpenGL_ES_CommonLite_Version_1_0,
        OpenGL_ES_Common_Version_1_1,
        OpenGL_ES_CommonLite_Version_1_1,
        OpenGL_ES_Version_2_0,
    };

%End
%If (Qt_4_2_0 -)
    typedef QFlags<QGLFormat::OpenGLVersionFlag> OpenGLVersionFlags;
%End
    QGLFormat();
    QGLFormat(QGL::FormatOptions options, int plane = 0);
    QGLFormat(const QGLFormat &other);
    ~QGLFormat();
    void setDepthBufferSize(int size);
    int depthBufferSize() const;
    void setAccumBufferSize(int size);
    int accumBufferSize() const;
    void setAlphaBufferSize(int size);
    int alphaBufferSize() const;
    void setStencilBufferSize(int size);
    int stencilBufferSize() const;
    void setSampleBuffers(bool enable);
    void setSamples(int numSamples);
    int samples() const;
    void setDoubleBuffer(bool enable);
    void setDepth(bool enable);
    void setRgba(bool enable);
    void setAlpha(bool enable);
    void setAccum(bool enable);
    void setStencil(bool enable);
    void setStereo(bool enable);
    void setDirectRendering(bool enable);
    void setOverlay(bool enable);
    int plane() const;
    void setPlane(int plane);
    void setOption(QGL::FormatOptions opt);
    bool testOption(QGL::FormatOptions opt) const;
    static QGLFormat defaultFormat();
    static void setDefaultFormat(const QGLFormat &f);
    static QGLFormat defaultOverlayFormat();
    static void setDefaultOverlayFormat(const QGLFormat &f);
    static bool hasOpenGL();
    static bool hasOpenGLOverlays();
    bool doubleBuffer() const;
    bool depth() const;
    bool rgba() const;
    bool alpha() const;
    bool accum() const;
    bool stencil() const;
    bool stereo() const;
    bool directRendering() const;
    bool hasOverlay() const;
    bool sampleBuffers() const;
%If (Qt_4_2_0 -)
    void setRedBufferSize(int size);
%End
%If (Qt_4_2_0 -)
    int redBufferSize() const;
%End
%If (Qt_4_2_0 -)
    void setGreenBufferSize(int size);
%End
%If (Qt_4_2_0 -)
    int greenBufferSize() const;
%End
%If (Qt_4_2_0 -)
    void setBlueBufferSize(int size);
%End
%If (Qt_4_2_0 -)
    int blueBufferSize() const;
%End
%If (Qt_4_2_0 -)
    void setSwapInterval(int interval);
%End
%If (Qt_4_2_0 -)
    int swapInterval() const;
%End
%If (Qt_4_2_0 -)
    static QFlags<QGLFormat::OpenGLVersionFlag> openGLVersionFlags();
%End
%If (Qt_4_7_0 -)
    void setVersion(int major, int minor);
%End
%If (Qt_4_7_0 -)
    int majorVersion() const;
%End
%If (Qt_4_7_0 -)
    int minorVersion() const;
%End
%If (Qt_4_7_0 -)

    enum OpenGLContextProfile
    {
        NoProfile,
        CoreProfile,
        CompatibilityProfile,
    };

%End
%If (Qt_4_7_0 -)
    void setProfile(QGLFormat::OpenGLContextProfile profile);
%End
%If (Qt_4_7_0 -)
    QGLFormat::OpenGLContextProfile profile() const;
%End
};

bool operator==(const QGLFormat &, const QGLFormat &);
bool operator!=(const QGLFormat &, const QGLFormat &);

class QGLContext /Supertype=sip.wrapper/
{
%TypeHeaderCode
#include <qgl.h>
%End

public:
    QGLContext(const QGLFormat &format, QPaintDevice *device);
    virtual ~QGLContext();
    virtual bool create(const QGLContext *shareContext = 0);
    bool isValid() const;
    bool isSharing() const;
    void reset();
    QGLFormat format() const;
    QGLFormat requestedFormat() const;
    void setFormat(const QGLFormat &format);
    virtual void makeCurrent();
    virtual void doneCurrent();
    virtual void swapBuffers() const;
    GLuint bindTexture(const QImage &image, GLenum target = GL_TEXTURE_2D, GLint format = GL_RGBA);
    GLuint bindTexture(const QPixmap &pixmap, GLenum target = GL_TEXTURE_2D, GLint format = GL_RGBA);
%If (Qt_4_4_0 -)
    void drawTexture(const QRectF &target, GLuint textureId, GLenum textureTarget = GL_TEXTURE_2D);
%End
%If (Qt_4_4_0 -)
    void drawTexture(const QPointF &point, GLuint textureId, GLenum textureTarget = GL_TEXTURE_2D);
%End
    GLuint bindTexture(const QString &fileName);

protected:
%If (- Qt_5_0_0)
%If (WS_X11)
%If (PyQt_NoOpenGLES)
    virtual void *chooseVisual();
%End
%End
%End

public:
    void deleteTexture(GLuint tx_id);
    static void setTextureCacheLimit(int size);
    static int textureCacheLimit();
%If (Qt_5_0_0 -)
    QFunctionPointer getProcAddress(const QString &proc) const;
%End
%If (- Qt_5_0_0)
    void *getProcAddress(const QString &proc) const;
%End
    QPaintDevice *device() const;
    QColor overlayTransparentColor() const;
    static const QGLContext *currentContext();

protected:
    virtual bool chooseContext(const QGLContext *shareContext = 0);
    bool deviceIsPixmap() const;
    bool windowCreated() const;
    void setWindowCreated(bool on);
    bool initialized() const;
    void setInitialized(bool on);
%If (- Qt_5_0_0)
    void generateFontDisplayLists(const QFont &fnt, int listBase);
%End

public:
%If (Qt_4_6_0 -)
    static bool areSharing(const QGLContext *context1, const QGLContext *context2);
%End
%If (Qt_4_6_0 -)

    enum BindOption
    {
        NoBindOption,
        InvertedYBindOption,
        MipmapBindOption,
        PremultipliedAlphaBindOption,
        LinearFilteringBindOption,
        DefaultBindOption,
    };

%End
%If (Qt_4_6_0 -)
    typedef QFlags<QGLContext::BindOption> BindOptions;
%End
%If (Qt_4_6_0 -)
    GLuint bindTexture(const QImage &image, GLenum target, GLint format, QFlags<QGLContext::BindOption> options);
%End
%If (Qt_4_6_0 -)
    GLuint bindTexture(const QPixmap &pixmap, GLenum target, GLint format, QFlags<QGLContext::BindOption> options);
%End
%If (Qt_5_0_0 -)
    void moveToThread(QThread *thread);
%End

private:
    QGLContext(const QGLContext &);
};

class QGLWidget : QWidget
{
%TypeHeaderCode
#include <qgl.h>
%End

%ConvertToSubClassCode
    static struct class_graph {
        const char *name;
        sipTypeDef **type;
        int yes, no;
    } graph[] = {
        {sipName_QGLWidget, &sipType_QGLWidget, -1, 1},
    #if QT_VERSION >= 0x040600
        {sipName_QGLShader, &sipType_QGLShader, -1, 2},
        {sipName_QGLShaderProgram, &sipType_QGLShaderProgram, -1, -1},
    #else
        {0, 0, -1, 2},
        {0, 0, -1, -1},
    #endif
    };
    
    int i = 0;
    
    sipType = 0;
    
    do
    {
        struct class_graph *cg = &graph[i];
    
        if (cg->name != NULL && sipCpp->inherits(cg->name))
        {
            sipType = *cg->type;
            i = cg->yes;
        }
        else
            i = cg->no;
    }
    while (i >= 0);
%End

public:
%If (- Qt_4_2_0)
    QGLWidget(QWidget *parent /TransferThis/ = 0, const QGLWidget *shareWidget = 0, Qt::WFlags flags = 0);
%End
%If (Qt_4_2_0 -)
    QGLWidget(QWidget *parent /TransferThis/ = 0, const QGLWidget *shareWidget = 0, Qt::WindowFlags flags = 0);
%End
%If (- Qt_4_2_0)
    QGLWidget(QGLContext *context /Transfer/, QWidget *parent /TransferThis/ = 0, const QGLWidget *shareWidget = 0, Qt::WFlags flags = 0);
%End
%If (Qt_4_2_0 -)
    QGLWidget(QGLContext *context /Transfer/, QWidget *parent /TransferThis/ = 0, const QGLWidget *shareWidget = 0, Qt::WindowFlags flags = 0);
%End
%If (- Qt_4_2_0)
    QGLWidget(const QGLFormat &format, QWidget *parent /TransferThis/ = 0, const QGLWidget *shareWidget = 0, Qt::WFlags flags = 0);
%End
%If (Qt_4_2_0 -)
    QGLWidget(const QGLFormat &format, QWidget *parent /TransferThis/ = 0, const QGLWidget *shareWidget = 0, Qt::WindowFlags flags = 0);
%End
    virtual ~QGLWidget();
    void qglColor(const QColor &c) const;
    void qglClearColor(const QColor &c) const;
    bool isValid() const;
    bool isSharing() const;
    void makeCurrent();
    void doneCurrent();
    bool doubleBuffer() const;
    void swapBuffers();
    QGLFormat format() const;
    void setFormat(const QGLFormat &format);
%If (Qt_5_0_0 -)
    QGLContext *context() const;
%End
%If (- Qt_5_0_0)
    const QGLContext *context() const;
%End
    void setContext(QGLContext *context /Transfer/, const QGLContext *shareContext = 0, bool deleteOldContext = true);
    QPixmap renderPixmap(int width = 0, int height = 0, bool useContext = false);
    QImage grabFrameBuffer(bool withAlpha = false);
    void makeOverlayCurrent();
    const QGLContext *overlayContext() const;
    static QImage convertToGLFormat(const QImage &img);
%If (- Qt_5_0_0)
    void setMouseTracking(bool enable);
%End
    const QGLColormap &colormap() const;
    void setColormap(const QGLColormap &map);
%If (Qt_5_0_0 -)
    void renderText(int x, int y, const QString &str, const QFont &font = QFont());
%End
%If (- Qt_5_0_0)
    void renderText(int x, int y, const QString &str, const QFont &font = QFont(), int listBase = 2000);
%End
%If (Qt_5_0_0 -)
    void renderText(double x, double y, double z, const QString &str, const QFont &font = QFont());
%End
%If (- Qt_5_0_0)
    void renderText(double x, double y, double z, const QString &str, const QFont &font = QFont(), int listBase = 2000);
%End
    virtual QPaintEngine *paintEngine() const;
    GLuint bindTexture(const QImage &image, GLenum target = GL_TEXTURE_2D, GLint format = GL_RGBA);
    GLuint bindTexture(const QPixmap &pixmap, GLenum target = GL_TEXTURE_2D, GLint format = GL_RGBA);
    GLuint bindTexture(const QString &fileName);
%If (Qt_4_4_0 -)
    void drawTexture(const QRectF &target, GLuint textureId, GLenum textureTarget = GL_TEXTURE_2D);
%End
%If (Qt_4_4_0 -)
    void drawTexture(const QPointF &point, GLuint textureId, GLenum textureTarget = GL_TEXTURE_2D);
%End
    void deleteTexture(GLuint tx_id);

public slots:
    virtual void updateGL();
    virtual void updateOverlayGL();

protected:
    virtual bool event(QEvent *);
    virtual void initializeGL();
    virtual void resizeGL(int w, int h);
    virtual void paintGL();
    virtual void initializeOverlayGL();
    virtual void resizeOverlayGL(int w, int h);
    virtual void paintOverlayGL();
    void setAutoBufferSwap(bool on);
    bool autoBufferSwap() const;
    virtual void paintEvent(QPaintEvent *);
    virtual void resizeEvent(QResizeEvent *);
    virtual void glInit();
    virtual void glDraw();
%If (- Qt_5_0_0)
    int fontDisplayListBase(const QFont &font, int listBase = 2000);
%End

public:
%If (Qt_4_6_0 -)
    GLuint bindTexture(const QImage &image, GLenum target, GLint format, QFlags<QGLContext::BindOption> options);
%End
%If (Qt_4_6_0 -)
    GLuint bindTexture(const QPixmap &pixmap, GLenum target, GLint format, QFlags<QGLContext::BindOption> options);
%End

private:
    QGLWidget(const QGLWidget &);
};

%If (Qt_4_2_0 -)
QFlags<QGLFormat::OpenGLVersionFlag> operator|(QGLFormat::OpenGLVersionFlag f1, QFlags<QGLFormat::OpenGLVersionFlag> f2);
%End
%If (Qt_4_6_0 -)
QFlags<QGLContext::BindOption> operator|(QGLContext::BindOption f1, QFlags<QGLContext::BindOption> f2);
%End

%ModuleHeaderCode
#include <qpyopengl_api.h>
%End
