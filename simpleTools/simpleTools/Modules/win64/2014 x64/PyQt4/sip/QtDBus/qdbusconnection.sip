// qdbusconnection.sip generated by MetaSIP on Fri Mar  1 21:46:03 2013
//
// This file is part of the QtDBus Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// If you are unsure which license is appropriate for your use, please
// contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%If (Qt_4_7_0 -)
%ModuleCode
#include <qdbusconnection.h>
%End
%End

%If (Qt_4_7_0 -)

namespace QDBus
{
%TypeHeaderCode
#include <qdbusconnection.h>
%End

    enum CallMode
    {
        NoBlock,
        Block,
        BlockWithGui,
        AutoDetect,
    };
};

%End
%If (Qt_4_7_0 -)

class QDBusConnection
{
%TypeHeaderCode
#include <qdbusconnection.h>
%End

public:
    enum BusType
    {
        SessionBus,
        SystemBus,
        ActivationBus,
    };

    enum RegisterOption
    {
        ExportAdaptors,
        ExportScriptableSlots,
        ExportScriptableSignals,
        ExportScriptableProperties,
        ExportScriptableInvokables,
        ExportScriptableContents,
        ExportNonScriptableSlots,
        ExportNonScriptableSignals,
        ExportNonScriptableProperties,
        ExportNonScriptableInvokables,
        ExportNonScriptableContents,
        ExportAllSlots,
        ExportAllSignals,
        ExportAllProperties,
        ExportAllInvokables,
        ExportAllContents,
        ExportAllSignal,
        ExportChildObjects,
    };

    enum UnregisterMode
    {
        UnregisterNode,
        UnregisterTree,
    };

    typedef QFlags<QDBusConnection::RegisterOption> RegisterOptions;
%If (Qt_4_8_0 -)

    enum ConnectionCapability
    {
        UnixFileDescriptorPassing,
    };

%End
%If (Qt_4_8_0 -)
    typedef QFlags<QDBusConnection::ConnectionCapability> ConnectionCapabilities;
%End
%If (Qt_5_0_0 -)
    explicit QDBusConnection(const QString &name);
%End
%If (- Qt_5_0_0)
    QDBusConnection(const QString &name);
%End
    QDBusConnection(const QDBusConnection &other);
    ~QDBusConnection();
    bool isConnected() const;
    QString baseService() const;
    QDBusError lastError() const;
    QString name() const;
%If (Qt_4_8_0 -)
    QFlags<QDBusConnection::ConnectionCapability> connectionCapabilities() const;
%End
    bool send(const QDBusMessage &message) const;
    bool callWithCallback(const QDBusMessage &message, QObject *receiver, SIP_SLOT returnMethod, SIP_SLOT errorMethod, int timeout = -1) const;
    SIP_PYOBJECT callWithCallback(const QDBusMessage &message, SIP_PYCALLABLE returnMethod, SIP_PYCALLABLE errorMethod, int timeout = -1);
%MethodCode
        QObject *qrx;
        QByteArray return_slot = qpycore_pyqtslot_get_parts(a1, &qrx);
        
        if (!return_slot.isNull())
        {
            QObject *error_qrx;
            QByteArray error_slot = qpycore_pyqtslot_get_parts(a2, &error_qrx);
        
            if (!error_slot.isNull())
            {
                if (qrx == error_qrx)
                {
                    bool ok;
            
                    Py_BEGIN_ALLOW_THREADS
                    ok = sipCpp->callWithCallback(*a0, qrx, return_slot.constData(), error_slot.constData(), a3);
                    Py_END_ALLOW_THREADS
        
                    sipRes = PyBool_FromLong(ok);
                }
                else
                {
                    PyErr_SetString(PyExc_ValueError,
                            "the return and error methods must be bound to the same QObject instance");
                }
            }
        }
%End

    bool callWithCallback(const QDBusMessage &message, QObject *receiver, SIP_SLOT slot, int timeout = -1) const;
    SIP_PYOBJECT callWithCallback(const QDBusMessage &message, SIP_PYCALLABLE slot, int timeout = -1);
%MethodCode
        QObject *qrx;
        QByteArray slot = qpycore_pyqtslot_get_parts(a1, &qrx);
        
        if (!slot.isNull())
        {
            bool ok;
            
            Py_BEGIN_ALLOW_THREADS
            ok = sipCpp->callWithCallback(*a0, qrx, slot.constData(), a2);
            Py_END_ALLOW_THREADS
        
            sipRes = PyBool_FromLong(ok);
        }
%End

    QDBusMessage call(const QDBusMessage &message, QDBus::CallMode mode = QDBus::Block, int timeout = -1) const /ReleaseGIL/;
    QDBusPendingCall asyncCall(const QDBusMessage &message, int timeout = -1) const;
    bool connect(const QString &service, const QString &path, const QString &interface, const QString &name, QObject *receiver, SIP_SLOT slot);
    SIP_PYOBJECT connect(const QString &service, const QString &path, const QString &interface, const QString &name, SIP_PYCALLABLE slot);
%MethodCode
        QObject *qrx;
        QByteArray slot = qpycore_pyqtslot_get_parts(a4, &qrx);
        
        if (!slot.isNull())
        {
            bool ok;
        
            Py_BEGIN_ALLOW_THREADS
            ok = sipCpp->connect(*a0, *a1, *a2, *a3, qrx, slot.constData());
            Py_END_ALLOW_THREADS
        
            sipRes = PyBool_FromLong(ok);
        }
%End

    bool connect(const QString &service, const QString &path, const QString &interface, const QString &name, const QString &signature, QObject *receiver, SIP_SLOT slot);
    SIP_PYOBJECT connect(const QString &service, const QString &path, const QString &interface, const QString &name, const QString &signature, SIP_PYCALLABLE slot);
%MethodCode
        QObject *qrx;
        QByteArray slot = qpycore_pyqtslot_get_parts(a5, &qrx);
        
        if (!slot.isNull())
        {
            bool ok;
        
            Py_BEGIN_ALLOW_THREADS
            ok = sipCpp->connect(*a0, *a1, *a2, *a3, *a4, qrx, slot.constData());
            Py_END_ALLOW_THREADS
        
            sipRes = PyBool_FromLong(ok);
        }
%End

    bool connect(const QString &service, const QString &path, const QString &interface, const QString &name, const QStringList &argumentMatch, const QString &signature, QObject *receiver, SIP_SLOT slot);
    SIP_PYOBJECT connect(const QString &service, const QString &path, const QString &interface, const QString &name, const QStringList &argumentMatch, const QString &signature, SIP_PYCALLABLE slot);
%MethodCode
        QObject *qrx;
        QByteArray slot = qpycore_pyqtslot_get_parts(a6, &qrx);
        
        if (!slot.isNull())
        {
            bool ok;
            
            Py_BEGIN_ALLOW_THREADS
            ok = sipCpp->connect(*a0, *a1, *a2, *a3, *a4, *a5, qrx, slot.constData());
            Py_END_ALLOW_THREADS
        
            sipRes = PyBool_FromLong(ok);
        }
%End

    bool disconnect(const QString &service, const QString &path, const QString &interface, const QString &name, QObject *receiver, SIP_SLOT slot);
    SIP_PYOBJECT disconnect(const QString &service, const QString &path, const QString &interface, const QString &name, SIP_PYCALLABLE slot);
%MethodCode
        QObject *qrx;
        QByteArray slot = qpycore_pyqtslot_get_parts(a4, &qrx);
        
        if (!slot.isNull())
        {
            bool ok;
            
            Py_BEGIN_ALLOW_THREADS
            ok = sipCpp->disconnect(*a0, *a1, *a2, *a3, qrx, slot.constData());
            Py_END_ALLOW_THREADS
        
            sipRes = PyBool_FromLong(ok);
        }
%End

    bool disconnect(const QString &service, const QString &path, const QString &interface, const QString &name, const QString &signature, QObject *receiver, SIP_SLOT slot);
    SIP_PYOBJECT disconnect(const QString &service, const QString &path, const QString &interface, const QString &name, const QString &signature, SIP_PYCALLABLE slot);
%MethodCode
        QObject *qrx;
        QByteArray slot = qpycore_pyqtslot_get_parts(a5, &qrx);
        
        if (!slot.isNull())
        {
            bool ok;
            
            Py_BEGIN_ALLOW_THREADS
            ok = sipCpp->disconnect(*a0, *a1, *a2, *a3, *a4, qrx, slot.constData());
            Py_END_ALLOW_THREADS
        
            sipRes = PyBool_FromLong(ok);
        }
%End

    bool disconnect(const QString &service, const QString &path, const QString &interface, const QString &name, const QStringList &argumentMatch, const QString &signature, QObject *receiver, SIP_SLOT slot);
    SIP_PYOBJECT disconnect(const QString &service, const QString &path, const QString &interface, const QString &name, const QStringList &argumentMatch, const QString &signature, SIP_PYCALLABLE slot);
%MethodCode
        QObject *qrx;
        QByteArray slot = qpycore_pyqtslot_get_parts(a6, &qrx);
        
        if (!slot.isNull())
        {
            bool ok;
            
            Py_BEGIN_ALLOW_THREADS
            ok = sipCpp->disconnect(*a0, *a1, *a2, *a3, *a4, *a5, qrx, slot.constData());
            Py_END_ALLOW_THREADS
        
            sipRes = PyBool_FromLong(ok);
        }
%End

    bool registerObject(const QString &path, QObject *object, QDBusConnection::RegisterOptions options = QDBusConnection::ExportAdaptors);
    void unregisterObject(const QString &path, QDBusConnection::UnregisterMode mode = QDBusConnection::UnregisterNode);
    QObject *objectRegisteredAt(const QString &path) const;
    bool registerService(const QString &serviceName);
    bool unregisterService(const QString &serviceName);
    QDBusConnectionInterface *interface() const;
    static QDBusConnection connectToBus(QDBusConnection::BusType type, const QString &name) /ReleaseGIL/;
    static QDBusConnection connectToBus(const QString &address, const QString &name) /ReleaseGIL/;
%If (Qt_4_8_0 -)
    static QDBusConnection connectToPeer(const QString &address, const QString &name) /ReleaseGIL/;
%End
    static void disconnectFromBus(const QString &name) /ReleaseGIL/;
%If (Qt_4_8_0 -)
    static void disconnectFromPeer(const QString &name) /ReleaseGIL/;
%End
%If (Qt_4_8_0 -)
    static QByteArray localMachineId();
%End
    static QDBusConnection sessionBus();
    static QDBusConnection systemBus();
    static QDBusConnection sender();
};

%End
%If (Qt_4_7_0 -)
QFlags<QDBusConnection::RegisterOption> operator|(QDBusConnection::RegisterOption f1, QFlags<QDBusConnection::RegisterOption> f2);
%End
%If (Qt_4_7_0 -)
QFlags<QDBusConnection::RegisterOption> operator|(QDBusConnection::RegisterOption f1, QDBusConnection::RegisterOption f2);
%End

%ModuleHeaderCode
extern QByteArray (*qpycore_pyqtslot_get_parts)(PyObject *, QObject **);
extern PyObject *(*qpycore_qvariant_value)(QVariant &, PyObject *);
%End

%ModuleCode
QByteArray (*qpycore_pyqtslot_get_parts)(PyObject *, QObject **);
PyObject *(*qpycore_qvariant_value)(QVariant &, PyObject *);
%End

%PostInitialisationCode
// Import helpers from the QtCore module.
qpycore_pyqtslot_get_parts = (QByteArray (*)(PyObject *, QObject **))sipImportSymbol("qpycore_pyqtslot_get_parts");
qpycore_qvariant_value = (PyObject *(*)(QVariant &, PyObject *))sipImportSymbol("qpycore_qvariant_value");
%End
