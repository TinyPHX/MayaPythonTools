// qsslcertificate.sip generated by MetaSIP on Fri Mar  1 21:46:01 2013
//
// This file is part of the QtNetwork Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// If you are unsure which license is appropriate for your use, please
// contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%If (Qt_4_3_0 -)
%If (PyQt_OpenSSL)

class QSslCertificate
{
%TypeHeaderCode
#include <qsslcertificate.h>
%End

public:
    enum SubjectInfo
    {
        Organization,
        CommonName,
        LocalityName,
        OrganizationalUnitName,
        CountryName,
        StateOrProvinceName,
%If (Qt_5_0_0 -)
        DistinguishedNameQualifier,
%End
%If (Qt_5_0_0 -)
        SerialNumber,
%End
%If (Qt_5_0_0 -)
        EmailAddress,
%End
    };

    QSslCertificate(QIODevice *device, QSsl::EncodingFormat format = QSsl::Pem);
    QSslCertificate(const QByteArray &data = QByteArray(), QSsl::EncodingFormat format = QSsl::Pem);
    QSslCertificate(const QSslCertificate &other);
    ~QSslCertificate();
    bool operator==(const QSslCertificate &other) const;
    bool operator!=(const QSslCertificate &other) const;
    bool isNull() const;
%If (PyQt_Deprecated_5_0)
    bool isValid() const;
%End
    void clear();
    QByteArray version() const;
    QByteArray serialNumber() const;
    QByteArray digest(QCryptographicHash::Algorithm algorithm = QCryptographicHash::Md5) const;
%If (Qt_5_0_0 -)
    QStringList issuerInfo(QSslCertificate::SubjectInfo info) const;
%End
%If (- Qt_5_0_0)
    QString issuerInfo(QSslCertificate::SubjectInfo info) const;
%End
%If (Qt_5_0_0 -)
    QStringList issuerInfo(const QByteArray &attribute) const;
%End
%If (- Qt_5_0_0)
    QString issuerInfo(const QByteArray &tag) const;
%End
%If (Qt_5_0_0 -)
    QStringList subjectInfo(QSslCertificate::SubjectInfo info) const;
%End
%If (- Qt_5_0_0)
    QString subjectInfo(QSslCertificate::SubjectInfo info) const;
%End
%If (Qt_5_0_0 -)
    QStringList subjectInfo(const QByteArray &attribute) const;
%End
%If (- Qt_5_0_0)
    QString subjectInfo(const QByteArray &tag) const;
%End
%If (Qt_5_0_0 -)
    QMultiMap<QSsl::AlternativeNameEntryType, QString> subjectAlternativeNames() const;
%End
%If (PyQt_Deprecated_5_0)
    QMultiMap<QSsl::AlternateNameEntryType, QString> alternateSubjectNames() const;
%End
    QDateTime effectiveDate() const;
    QDateTime expiryDate() const;
    QSslKey publicKey() const;
    QByteArray toPem() const;
    QByteArray toDer() const;
    static QList<QSslCertificate> fromPath(const QString &path, QSsl::EncodingFormat format = QSsl::Pem, QRegExp::PatternSyntax syntax = QRegExp::FixedString);
    static QList<QSslCertificate> fromDevice(QIODevice *device, QSsl::EncodingFormat format = QSsl::Pem);
    static QList<QSslCertificate> fromData(const QByteArray &data, QSsl::EncodingFormat format = QSsl::Pem);
    Qt::HANDLE handle() const;
%If (Qt_5_0_0 -)
    void swap(QSslCertificate &other);
%End
%If (Qt_5_0_0 -)
    bool isBlacklisted() const;
%End
%If (Qt_5_0_0 -)
    QList<QByteArray> subjectInfoAttributes() const;
%End
%If (Qt_5_0_0 -)
    QList<QByteArray> issuerInfoAttributes() const;
%End
%If (Qt_5_0_0 -)
    QList<QSslCertificateExtension> extensions() const;
%End
%If (Qt_5_0_0 -)
    QString toText() const;
%End
%If (Qt_5_0_0 -)
    static QList<QSslError> verify(QList<QSslCertificate> certificateChain, const QString &hostName = QString());
%End
};

%End
%End
%If (Qt_5_0_0 -)
%If (PyQt_OpenSSL)
// Mapped type for QMultiMap<QSsl::AlternativeNameEntryType, QString>.
%MappedType QMultiMap<QSsl::AlternativeNameEntryType, QString> /DocType="Py_v3:dict-of-QSsl.AlternativeNameEntryType-list-of-str;dict-of-QSsl.AlternateNameEntryType-list-of-QString"/
{
%TypeHeaderCode
#include <QtCore/qmap.h>
#include <QtCore/qstring.h>
#include <QtNetwork/qssl.h>
%End

%ConvertFromTypeCode
    // Get the enum objects that are the dictionary keys.
    static PyObject *email_entry = NULL;
    static PyObject *dns_entry = NULL;

    if (email_entry == NULL)
    {
        email_entry = PyObject_GetAttrString((PyObject *)sipTypeAsPyTypeObject(sipType_QSsl),
#if PY_VERSION_HEX >= 0x02050000
                "EmailEntry");
#else
                const_cast<char *>("EmailEntry"));
#endif

        if (email_entry == NULL)
            return NULL;
    }

    if (dns_entry == NULL)
    {
        dns_entry = PyObject_GetAttrString((PyObject *)sipTypeAsPyTypeObject(sipType_QSsl),
#if PY_VERSION_HEX >= 0x02050000
                "DnsEntry");
#else
                const_cast<char *>("DnsEntry"));
#endif

        if (dns_entry == NULL)
            return NULL;
    }

    // Create the dictionary.
    PyObject *d = PyDict_New();

    if (d == NULL)
        return NULL;

    QList<QString> vl;

    // Handle the Qssl::EmailEntry key.
    vl = sipCpp->values(QSsl::EmailEntry);

    if (!vl.isEmpty())
    {
        PyObject *vlobj = PyList_New(vl.count());

        if (vlobj == NULL)
        {
            Py_DECREF(d);
            return NULL;
        }

        int rc = PyDict_SetItem(d, email_entry, vlobj);

        Py_DECREF(email_entry);
        Py_DECREF(vlobj);

        if (rc < 0)
        {
            Py_DECREF(d);
            return NULL;
        }

        for (int i = 0; i < vl.count(); ++i)
        {
            QString *s = new QString(vl.at(i));
            PyObject *vobj = sipConvertFromNewType(s, sipType_QString, sipTransferObj);

            if (vlobj == NULL)
            {
                Py_DECREF(d);
                return NULL;
            }

            PyList_SET_ITEM(vlobj, i, vobj);
        }
    }

    // Handle the Qssl::DnsEntry key.
    vl = sipCpp->values(QSsl::DnsEntry);

    if (!vl.isEmpty())
    {
        PyObject *vlobj = PyList_New(vl.count());

        if (vlobj == NULL)
        {
            Py_DECREF(d);
            return NULL;
        }

        int rc = PyDict_SetItem(d, dns_entry, vlobj);

        Py_DECREF(dns_entry);
        Py_DECREF(vlobj);

        if (rc < 0)
        {
            Py_DECREF(d);
            return NULL;
        }

        for (int i = 0; i < vl.count(); ++i)
        {
            QString *s = new QString(vl.at(i));
            PyObject *vobj = sipConvertFromNewType(s, sipType_QString, sipTransferObj);

            if (vlobj == NULL)
            {
                Py_DECREF(d);
                return NULL;
            }

            PyList_SET_ITEM(vlobj, i, vobj);
        }
    }

    return d;
%End

%ConvertToTypeCode
    if (sipIsErr == NULL)
    {
        // We don't support passing the type as an argument as it isn't
        // currently needed (and is unlikely to be in the future).
        PyErr_SetString(PyExc_NotImplementedError, "converting to QMultiMap<QSsl::AlternativeNameEntryType, QString> is unsupported");

        return 0;
    }

    // Keep the compiler quiet.
    sipPy = NULL;
    return 0;
%End
};
%End
%End
%If (Qt_4_3_0 -)
%If (PyQt_Deprecated_5_0)
// Mapped type for QMultiMap<QSsl::AlternateNameEntryType, QString>.
%If (PyQt_OpenSSL)
%MappedType QMultiMap<QSsl::AlternateNameEntryType, QString> /DocType="Py_v3:dict-of-QSsl.AlternateNameEntryType-list-of-str;dict-of-QSsl.AlternateNameEntryType-list-of-QString"/
{
%TypeHeaderCode
#include <QtCore/qmap.h>
#include <QtCore/qstring.h>
#include <QtNetwork/qssl.h>
%End

%ConvertFromTypeCode
    // Get the enum objects that are the dictionary keys.
    static PyObject *email_entry = NULL;
    static PyObject *dns_entry = NULL;

    if (email_entry == NULL)
    {
        email_entry = PyObject_GetAttrString((PyObject *)sipTypeAsPyTypeObject(sipType_QSsl),
#if PY_VERSION_HEX >= 0x02050000
                "EmailEntry");
#else
                const_cast<char *>("EmailEntry"));
#endif

        if (email_entry == NULL)
            return NULL;
    }

    if (dns_entry == NULL)
    {
        dns_entry = PyObject_GetAttrString((PyObject *)sipTypeAsPyTypeObject(sipType_QSsl),
#if PY_VERSION_HEX >= 0x02050000
                "DnsEntry");
#else
                const_cast<char *>("DnsEntry"));
#endif

        if (dns_entry == NULL)
            return NULL;
    }

    // Create the dictionary.
    PyObject *d = PyDict_New();

    if (d == NULL)
        return NULL;

    QList<QString> vl;

    // Handle the Qssl::EmailEntry key.
    vl = sipCpp->values(QSsl::EmailEntry);

    if (!vl.isEmpty())
    {
        PyObject *vlobj = PyList_New(vl.count());

        if (vlobj == NULL)
        {
            Py_DECREF(d);
            return NULL;
        }

        int rc = PyDict_SetItem(d, email_entry, vlobj);

        Py_DECREF(email_entry);
        Py_DECREF(vlobj);

        if (rc < 0)
        {
            Py_DECREF(d);
            return NULL;
        }

        for (int i = 0; i < vl.count(); ++i)
        {
            QString *s = new QString(vl.at(i));
            PyObject *vobj = sipConvertFromNewType(s, sipType_QString, sipTransferObj);

            if (vlobj == NULL)
            {
                Py_DECREF(d);
                return NULL;
            }

            PyList_SET_ITEM(vlobj, i, vobj);
        }
    }

    // Handle the Qssl::DnsEntry key.
    vl = sipCpp->values(QSsl::DnsEntry);

    if (!vl.isEmpty())
    {
        PyObject *vlobj = PyList_New(vl.count());

        if (vlobj == NULL)
        {
            Py_DECREF(d);
            return NULL;
        }

        int rc = PyDict_SetItem(d, dns_entry, vlobj);

        Py_DECREF(dns_entry);
        Py_DECREF(vlobj);

        if (rc < 0)
        {
            Py_DECREF(d);
            return NULL;
        }

        for (int i = 0; i < vl.count(); ++i)
        {
            QString *s = new QString(vl.at(i));
            PyObject *vobj = sipConvertFromNewType(s, sipType_QString, sipTransferObj);

            if (vlobj == NULL)
            {
                Py_DECREF(d);
                return NULL;
            }

            PyList_SET_ITEM(vlobj, i, vobj);
        }
    }

    return d;
%End

%ConvertToTypeCode
    if (sipIsErr == NULL)
    {
        // We don't support passing the type as an argument as it isn't
        // currently needed (and is unlikely to be in the future).
        PyErr_SetString(PyExc_NotImplementedError, "converting to QMultiMap<QSsl::AlternateNameEntryType, QString> is unsupported");

        return 0;
    }

    // Keep the compiler quiet.
    sipPy = NULL;
    return 0;
%End
};
%End
%End
%End
