// qglobal.sip generated by MetaSIP on Fri Mar  1 21:45:57 2013
//
// This file is part of the QtCore Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// If you are unsure which license is appropriate for your use, please
// contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%ModuleCode
#include <qglobal.h>
%End

// PyQt version information.
int PYQT_VERSION;
const char *PYQT_VERSION_STR;

%ModuleCode
static int PYQT_VERSION = 0x040a00;
static const char *PYQT_VERSION_STR = "4.10";
%End
const int QT_VERSION;
const char *QT_VERSION_STR;
typedef signed char qint8;
typedef unsigned char quint8;
typedef short qint16;
typedef unsigned short quint16;
typedef int qint32;
typedef unsigned int quint32;
typedef long long qint64;
typedef unsigned long long quint64;
typedef qint64 qlonglong;
typedef quint64 qulonglong;
%If (PyQt_qreal_double)
typedef double qreal;
%End
%If (!PyQt_qreal_double)
typedef float qreal;
%End
typedef unsigned char uchar;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;
double qAbs(const double &t);
int qRound(qreal d);
qint64 qRound64(qreal d);

class QSysInfo
{
%TypeHeaderCode
#include <qglobal.h>
%End

public:
%If (- Qt_4_2_0)

    enum
    {
        WordSize,
    };

%End
%If (Qt_4_2_0 -)

    enum Sizes
    {
        WordSize,
    };

%End

    enum Endian
    {
        BigEndian,
        LittleEndian,
        ByteOrder,
    };

%If (WS_WIN)
// Windows specific system info.
enum WinVersion {
    WV_32s,
    WV_95,
    WV_98,
    WV_Me,
    WV_DOS_based,

    WV_NT,
    WV_2000,
    WV_XP,
    WV_2003,
%If (Qt_4_2_0 -)
    WV_VISTA,
%End
%If (Qt_4_5_1 -)
    WV_WINDOWS7,
%End
%If (Qt_4_8_3 -)
    WV_WINDOWS8,
%End
    WV_NT_based,

%If (Qt_4_5_0 -)
    WV_4_0,
    WV_5_0,
    WV_5_1,
    WV_5_2,
    WV_6_0,
%End
%If (Qt_4_5_1 -)
    WV_6_1,
%End
%If (Qt_4_8_3 -)
    WV_6_2,
%End

    WV_CE,
    WV_CENET,
%If (Qt_4_4_0 -)
    WV_CE_5,
    WV_CE_6,
%End
    WV_CE_based
};

static const WinVersion WindowsVersion;
%End
%If (WS_MACX)
// Mac specific system info.
enum MacVersion {
    MV_Unknown,
    MV_9,
    MV_10_0,
    MV_10_1,
    MV_10_2,
    MV_10_3,
    MV_10_4,
%If (Qt_4_2_0 -)
    MV_10_5,
%End
%If (Qt_4_5_1 -)
    MV_10_6,
%End
%If (Qt_4_8_0 -)
    MV_10_7,
%End
%If (Qt_4_8_3 -)
    MV_10_8,
%End

    MV_CHEETAH,
    MV_PUMA,
    MV_JAGUAR,
    MV_PANTHER,
    MV_TIGER,
%If (Qt_4_2_0 -)
    MV_LEOPARD,
%End
%If (Qt_4_5_1 -)
    MV_SNOWLEOPARD,
%End
%If (Qt_4_8_0 -)
    MV_LION,
%End
%If (Qt_4_8_3 -)
    MV_MOUNTAINLION,
%End
};

static const MacVersion MacintoshVersion;
%End
};

const char *qVersion();
bool qSharedBuild();
void qDebug(const char *);
%MethodCode
    Py_BEGIN_ALLOW_THREADS
    qDebug("%s", a0);
    Py_END_ALLOW_THREADS
%End

void qWarning(const char *);
%MethodCode
    Py_BEGIN_ALLOW_THREADS
    qWarning("%s", a0);
    Py_END_ALLOW_THREADS
%End

void qCritical(const char *);
%MethodCode
    Py_BEGIN_ALLOW_THREADS
    qCritical("%s", a0);
    Py_END_ALLOW_THREADS
%End

void qFatal(const char *);
%MethodCode
    Py_BEGIN_ALLOW_THREADS
    qFatal("%s", a0);
    Py_END_ALLOW_THREADS
%End

void qErrnoWarning(int code, const char *msg);
%MethodCode
    Py_BEGIN_ALLOW_THREADS
    qErrnoWarning(a0, "%s", a1);
    Py_END_ALLOW_THREADS
%End

void qErrnoWarning(const char *msg);
%MethodCode
    Py_BEGIN_ALLOW_THREADS
    qErrnoWarning("%s", a0);
    Py_END_ALLOW_THREADS
%End

enum QtMsgType
{
    QtDebugMsg,
    QtWarningMsg,
    QtCriticalMsg,
    QtFatalMsg,
    QtSystemMsg,
};

SIP_PYCALLABLE qInstallMsgHandler(SIP_PYCALLABLE /AllowNone/);
%MethodCode
    // Treat None as the default handler.
    #if QT_VERSION >= 0x050000
    QtMessageHandler old = qInstallMessageHandler((a0 != Py_None) ? qtcore_MsgHandler : 0);
    #else
    QtMsgHandler old = qInstallMsgHandler((a0 != Py_None) ? qtcore_MsgHandler : 0);
    #endif
    
    // If we recognise the old handler, then return it.  Otherwise return
    // the default handler.  This doesn't exactly mimic the Qt behaviour
    // but it is probably close enough for the way it will be used.
    sipRes = (old == qtcore_MsgHandler) ? qtcore_PyMsgHandler : Py_None;
    Py_INCREF(sipRes);
    
    // Save the new Python handler.
    Py_XDECREF(qtcore_PyMsgHandler);
    qtcore_PyMsgHandler = a0;
    Py_INCREF(qtcore_PyMsgHandler);
%End

// Module code needed by qInstallMsgHandler().
%ModuleCode
// The user supplied Python handler.
static PyObject *qtcore_PyMsgHandler = 0;

// The C++ wrapper around the Python handler.
#if QT_VERSION >= 0x050000
static void qtcore_MsgHandler(QtMsgType type, const QMessageLogContext &, const QString &msg)
#else
static void qtcore_MsgHandler(QtMsgType type, const char *msg)
#endif
{
    PyObject *res;

    SIP_BLOCK_THREADS
    
#if QT_VERSION >= 0x050000
    res = sipCallMethod(0, qtcore_PyMsgHandler, "FN", type, sipType_QtMsgType, new QString(msg), sipType_QString, NULL);
#else
    res = sipCallMethod(0, qtcore_PyMsgHandler, "Fs", type, sipType_QtMsgType, msg);
#endif

    Py_XDECREF(res);

    if (res != NULL && res != Py_None)
    {
        PyErr_SetString(PyExc_TypeError, "invalid result type from PyQt message handler");
        res = NULL;
    }

    if (res == NULL)
        PyErr_Print();

    SIP_UNBLOCK_THREADS
}
%End
%If (- Qt_5_0_0)
typedef bool QBool /NoTypeName/;
%End
// Template definition for QFlags.
template<ENUM>
class QFlags /PyQt4Flags=0x1/
{
public:
    QFlags(const QFlags &);
    // This is handled by the %ConvertToTypeCode.
    //QFlags(ENUM);
    // This is a convenience, eg. to restore a set of flags from QSettings.
    QFlags(int);
    QFlags();

    QFlags &operator&=(int mask);
    QFlags &operator|=(QFlags f);
    //QFlags &operator|=(ENUM f);
    QFlags &operator^=(QFlags f);
    //QFlags &operator^=(ENUM f);

    operator int() const;

    QFlags operator|(QFlags f) const;
    //QFlags operator|(ENUM f) const;
    QFlags operator^(QFlags f) const;
    //QFlags operator^(ENUM f) const;
    QFlags operator&(int mask) const;
    //QFlags operator&(ENUM f) const;
    QFlags operator~() const;

    // These are here to ensure consistency between, for example:
    //   Qt.AlignLeft | Qt.AlignTop | Qt.TextWordWrap and
    //   Qt.AlignLeft | Qt.TextWordWrap | Qt.AlignTop
    // In the first of the above Qt.TextWordWrap is ored with a
    // Qt.AlignmentFlag enum.  In the second it is being ored with a
    // Qt.Alignment class.
    QFlags operator|(int f);
%MethodCode
        sipRes = new QFlags(*a0 | a1);
%End

    QFlags operator^(int f);
%MethodCode
        sipRes = new QFlags(*a0 ^ a1);
%End

    // These are necessary to prevent Python comparing object IDs.
    bool operator==(const QFlags &f) const;
%MethodCode
#if QT_VERSION >= 0x050000
        sipRes = (sipCpp->operator QFlags::Int() == a0->operator QFlags::Int());
#else
        sipRes = (sipCpp->operator int() == a0->operator int());
#endif
%End

    bool operator!=(const QFlags &f) const;
%MethodCode
#if QT_VERSION >= 0x050000
        sipRes = (sipCpp->operator QFlags::Int() != a0->operator QFlags::Int());
#else
        sipRes = (sipCpp->operator int() != a0->operator int());
#endif
%End

    int __bool__() const;
%MethodCode
#if QT_VERSION >= 0x050000
        sipRes = (sipCpp->operator QFlags::Int() != 0);
#else
        sipRes = (sipCpp->operator int() != 0);
#endif
%End


%ConvertToTypeCode
// Allow an instance of the base enum whenever a QFlags is expected.

if (sipIsErr == NULL)
    return (PyObject_TypeCheck(sipPy, sipTypeAsPyTypeObject(sipType_ENUM)) ||
            sipCanConvertToType(sipPy, sipType_QFlags, SIP_NO_CONVERTORS));

if (PyObject_TypeCheck(sipPy, sipTypeAsPyTypeObject(sipType_ENUM)))
{
    *sipCppPtr = new QFlags(SIPLong_AsLong(sipPy));

    return sipGetState(sipTransferObj);
}

*sipCppPtr = reinterpret_cast<QFlags *>(sipConvertToType(sipPy, sipType_QFlags, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));

return 0;
%End
};
// Hook's into Qt's resource system.
%ModuleCode
QT_BEGIN_NAMESPACE
extern bool qRegisterResourceData(int, const unsigned char *, const unsigned char *, const unsigned char *);
extern bool qUnregisterResourceData(int, const unsigned char *, const unsigned char *, const unsigned char *);
QT_END_NAMESPACE
%End

bool qRegisterResourceData(int, const unsigned char *, const unsigned char *, const unsigned char *);
bool qUnregisterResourceData(int, const unsigned char *, const unsigned char *, const unsigned char *);
bool qFuzzyCompare(double p1, double p2);
bool qIsNull(double d);
%If (Qt_4_2_0 -)
void qsrand(uint seed);
%End
%If (Qt_4_2_0 -)
int qrand();
%End
%If (Qt_5_0_0 -)
typedef void *QFunctionPointer;
%End
%If (Qt_5_0_0 -)
// Mapped type for qintptr.
// Map qintptr onto sip.voidptr.  This means either an address (on Windows) or
// an integer file descriptor (on everything else) can be used.
%MappedType qintptr /DocType="sip.voidptr"/
{
%TypeHeaderCode
#include <QtGlobal>
%End

%ConvertToTypeCode
    qintptr ptr = (qintptr)sipConvertToVoidPtr(sipPy);

    if (!sipIsErr)
        return !PyErr_Occurred();

    // Mapped types deal with pointers, so create one on the heap.
    qintptr *heap = new qintptr;
    *heap = ptr;

    *sipCppPtr = heap;

    // Make sure the pointer doesn't leak.
    return SIP_TEMPORARY;
%End

%ConvertFromTypeCode
    return sipConvertFromVoidPtr((void *)*sipCpp);
%End
};
%End
// Mapped type for quintptr.
// Map quintptr onto sip.voidptr.  This means either an address (on Windows) or
// an integer file descriptor (on everything else) can be used.
%MappedType quintptr /DocType="sip.voidptr"/
{
%TypeHeaderCode
#include <QtGlobal>
%End

%ConvertToTypeCode
    quintptr ptr = (quintptr)sipConvertToVoidPtr(sipPy);

    if (!sipIsErr)
        return !PyErr_Occurred();

    // Mapped types deal with pointers, so create one on the heap.
    quintptr *heap = new quintptr;
    *heap = ptr;

    *sipCppPtr = heap;

    // Make sure the pointer doesn't leak.
    return SIP_TEMPORARY;
%End

%ConvertFromTypeCode
    return sipConvertFromVoidPtr((void *)*sipCpp);
%End
};
