// qcoreapplication.sip generated by MetaSIP on Fri Mar  1 21:45:57 2013
//
// This file is part of the QtCore Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// If you are unsure which license is appropriate for your use, please
// contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%ModuleCode
#include <qcoreapplication.h>
%End

%If (- Qt_5_0_0)
%If (WS_WIN)
// Windows specific definitions.
// These would normally be in qwindowdefs.h but are needed by
// qcoreapplication.h.
typedef struct HWND__ *HWND;
typedef unsigned UINT;
typedef long LONG;
typedef unsigned long DWORD;
typedef UINT WPARAM;
typedef LONG LPARAM;

struct POINT
{
%TypeHeaderCode
#include <wtypes.h>
%End

    LONG x;
    LONG y;
};

struct MSG
{
%TypeHeaderCode
#include <wtypes.h>
%End

    HWND hwnd;
    UINT message;
    WPARAM wParam;
    LPARAM lParam;
    DWORD time;
    POINT pt;
};
%End
%End

class QCoreApplication : QObject
{
%TypeHeaderCode
#include <qcoreapplication.h>
%End

public:
    QCoreApplication(SIP_PYLIST argv /DocType="list-of-str"/) /PostHook=__pyQtQAppHook__/ [(int &argc, char **argv)];
%MethodCode
        // The Python interface is a list of argument strings that is modified.
        
        int argc;
        char **argv;
        
        // Convert the list.
        if ((argv = qpycore_ArgvToC(a0, argc)) == NULL)
            sipIsErr = 1;
        else
        {
            // Create it now the arguments are right.
            static int nargc;
            nargc = argc;
        
            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipQCoreApplication(nargc, argv);
            Py_END_ALLOW_THREADS
        
            // Now modify the original list.
            qpycore_UpdatePyArgv(a0, argc, argv);
        }
%End

    virtual ~QCoreApplication();
%If (- Qt_5_0_0)
    static int argc();
%End
%If (- Qt_5_0_0)
    static SIP_PYLIST argv() /DocType="list-of-str"/;
%MethodCode
        // The Python interface returns a list of strings.
        
        int argc = QCoreApplication::argc();
        
        if ((sipRes = PyList_New(argc)) == NULL)
        {
            sipIsErr = 1;
        }
        else
        {
            char **argv = QCoreApplication::argv();
        
            for (int a = 0; a < argc; ++a)
            {
        #if PY_MAJOR_VERSION >= 3
                PyObject *arg_obj = PyUnicode_FromString(argv[a]);
        #else
                PyObject *arg_obj = PyString_FromString(argv[a]);
        #endif
        
                if (!arg_obj)
                {
                    Py_DECREF(sipRes);
                    sipIsErr = 1;
                    break;
                }
        
                PyList_SET_ITEM(sipRes, a, arg_obj);
            }
        }
%End

%End
    static void setOrganizationDomain(const QString &orgDomain);
    static QString organizationDomain();
    static void setOrganizationName(const QString &orgName);
    static QString organizationName();
    static void setApplicationName(const QString &application);
    static QString applicationName();
    static QStringList arguments();
    static QCoreApplication *instance();
    static int exec() /PostHook=__pyQtPostEventLoopHook__,PreHook=__pyQtPreEventLoopHook__,PyName=exec_,ReleaseGIL/;
%If (Py_v3)
    static int exec() /PostHook=__pyQtPostEventLoopHook__,PreHook=__pyQtPreEventLoopHook__,ReleaseGIL/;
%End
    static void processEvents(QFlags<QEventLoop::ProcessEventsFlag> flags = QEventLoop::AllEvents) /ReleaseGIL/;
    static void processEvents(QFlags<QEventLoop::ProcessEventsFlag> flags, int maxtime) /ReleaseGIL/;
    static void exit(int returnCode = 0);
    static bool sendEvent(QObject *receiver, QEvent *event) /ReleaseGIL/;
%If (Qt_5_0_0 -)
    static void postEvent(QObject *receiver, QEvent *event /Transfer/, int priority = Qt::NormalEventPriority);
%End
%If (- Qt_5_0_0)
    static void postEvent(QObject *receiver, QEvent *event /Transfer/);
%End
%If (Qt_4_3_0 - Qt_5_0_0)
    static void postEvent(QObject *receiver, QEvent *event /Transfer/, int priority);
%End
%If (Qt_5_0_0 -)
    static void sendPostedEvents(QObject *receiver = 0, int eventType = 0) /ReleaseGIL/;
%End
%If (- Qt_5_0_0)
    static void sendPostedEvents(QObject *receiver, int event_type) /ReleaseGIL/;
%End
%If (- Qt_5_0_0)
    static void sendPostedEvents() /ReleaseGIL/;
%End
%If (Qt_5_0_0 -)
    static void removePostedEvents(QObject *receiver, int eventType = 0);
%End
%If (- Qt_5_0_0)
    static void removePostedEvents(QObject *receiver);
%End
%If (Qt_4_3_0 - Qt_5_0_0)
    static void removePostedEvents(QObject *receiver, int eventType);
%End
    static bool hasPendingEvents();
    virtual bool notify(QObject *, QEvent *) /ReleaseGIL/;
    static bool startingUp();
    static bool closingDown();
    static QString applicationDirPath();
    static QString applicationFilePath();
    static void setLibraryPaths(const QStringList &);
    static QStringList libraryPaths();
    static void addLibraryPath(const QString &);
    static void removeLibraryPath(const QString &);
%If (Qt_5_0_0 -)
    static bool installTranslator(QTranslator *messageFile);
%End
%If (- Qt_5_0_0)
    static void installTranslator(QTranslator *);
%End
%If (Qt_5_0_0 -)
    static bool removeTranslator(QTranslator *messageFile);
%End
%If (- Qt_5_0_0)
    static void removeTranslator(QTranslator *);
%End
%If (PyQt_Deprecated_5_0)

    enum Encoding
    {
%If (Qt_4_2_0 -)
        CodecForTr,
%End
        UnicodeUTF8,
        DefaultCodec,
%If (Qt_5_0_0 -)
        Latin1,
%End
    };

%End
%If (Qt_5_0_0 -)
    static QString translate(const char *context, const char *sourceText, const char *disambiguation = 0, int n = -1);
%End
%If (Qt_4_2_0 -)
%If (PyQt_Deprecated_5_0)
    static QString translate(const char *context, SIP_PYOBJECT sourceText /DocType="str"/, const char *disambiguation = 0, QCoreApplication::Encoding encoding = QCoreApplication::CodecForTr);
%MethodCode
        const char *source = qpycore_encode(&a1, a3);
        
        if (source)
        {
            sipRes = new QString(QCoreApplication::translate(a0, source, a2, a3));
            Py_DECREF(a1);
        }
        else
        {
            sipIsErr = 1;
        }
%End

%End
%End
%If (Qt_4_2_0 -)
%If (PyQt_Deprecated_5_0)
    static QString translate(const char *context, SIP_PYOBJECT sourceText /DocType="str"/, const char *disambiguation, QCoreApplication::Encoding encoding, int n);
%MethodCode
        const char *source = qpycore_encode(&a1, a3);
        
        if (source)
        {
            sipRes = new QString(QCoreApplication::translate(a0, source, a2, a3, a4));
            Py_DECREF(a1);
        }
        else
        {
            sipIsErr = 1;
        }
%End

%End
%End
%If (- Qt_4_2_0)
    static QString translate(const char *context, SIP_PYOBJECT sourceText /DocType="str"/, const char *disambiguation = 0, QCoreApplication::Encoding encoding = QCoreApplication::DefaultCodec);
%MethodCode
        const char *source = qpycore_encode(&a1, a3);
        
        if (source)
        {
            sipRes = new QString(QCoreApplication::translate(a0, source, a2, a3));
            Py_DECREF(a1);
        }
        else
        {
            sipIsErr = 1;
        }
%End

%End
    static void flush() /ReleaseGIL/;
%If (Qt_4_2_0 -)
    static void setAttribute(Qt::ApplicationAttribute attribute, bool on = true);
%End
%If (Qt_4_2_0 -)
    static bool testAttribute(Qt::ApplicationAttribute attribute);
%End
%If (- Qt_5_0_0)
%If (WS_WIN)
    virtual bool winEventFilter(MSG *message, long *result);
%End
%End

public slots:
    static void quit();

signals:
    void aboutToQuit();

protected:
    virtual bool event(QEvent *);

public:
%If (Qt_4_4_0 -)
    static void setApplicationVersion(const QString &version);
%End
%If (Qt_4_4_0 -)
    static QString applicationVersion();
%End
%If (Qt_4_4_0 -)
    static qint64 applicationPid();
%End
%If (Qt_5_0_0 -)
    static QAbstractEventDispatcher *eventDispatcher();
%End
%If (Qt_5_0_0 -)
    static void setEventDispatcher(QAbstractEventDispatcher *eventDispatcher /Transfer/);
%End
%If (Qt_5_0_0 -)
    static bool isQuitLockEnabled();
%End
%If (Qt_5_0_0 -)
    static void setQuitLockEnabled(bool enabled);
%End
%If (Qt_5_0_0 -)
    void installNativeEventFilter(QAbstractNativeEventFilter *filterObj);
%End
%If (Qt_5_0_0 -)
    void removeNativeEventFilter(QAbstractNativeEventFilter *filterObj);
%End

private:
%If (Qt_4_6_0 -)
    QCoreApplication(const QCoreApplication &);
%End
};

void qAddPostRoutine(SIP_PYCALLABLE);
%MethodCode
    // Add it to the list of post routines if it already exists.
    if (qtcore_PostRoutines != NULL)
    {
        // See if there is an empty slot.
        bool app = true;
    
        for (SIP_SSIZE_T i = 0; i < PyList_GET_SIZE(qtcore_PostRoutines); ++i)
            if (PyList_GET_ITEM(qtcore_PostRoutines, i) == Py_None)
            {
                Py_DECREF(Py_None);
                Py_INCREF(a0);
                PyList_SET_ITEM(qtcore_PostRoutines, i, a0);
    
                app = false;
    
                break;
            }
    
        if (app && PyList_Append(qtcore_PostRoutines, a0) < 0)
            sipIsErr = 1;
    }
    else if ((qtcore_PostRoutines = PyList_New(1)) != NULL)
    {
        Py_INCREF(a0);
        PyList_SET_ITEM(qtcore_PostRoutines, 0, a0);
    
        qAddPostRoutine(qtcore_CallPostRoutines);
    }
    else
        sipIsErr = 1;
%End

void qRemovePostRoutine(SIP_PYCALLABLE);
%MethodCode
    // Remove it from the list of post routines if it exists.
    if (qtcore_PostRoutines != NULL)
        for (SIP_SSIZE_T i = 0; i < PyList_GET_SIZE(qtcore_PostRoutines); ++i)
            if (PyList_GET_ITEM(qtcore_PostRoutines, i) == a0)
            {
                Py_DECREF(a0);
                Py_INCREF(Py_None);
                PyList_SET_ITEM(qtcore_PostRoutines, i, Py_None);
    
                break;
            }
%End

// Module code needed by qAddPostRoutine() and qRemovePostRoutine().
%ModuleCode
// The list of Python post routines.
static PyObject *qtcore_PostRoutines = NULL;


// Call all of the registered Python post routines.
static void qtcore_CallPostRoutines()
{
    for (SIP_SSIZE_T i = 0; i < PyList_GET_SIZE(qtcore_PostRoutines); ++i)
    {
        PyObject *pr = PyList_GET_ITEM(qtcore_PostRoutines, i);

        if (pr != Py_None)
        {
            PyObject *res = PyObject_CallObject(pr, NULL);

            Py_XDECREF(res);
        }
    }
}
%End
void pyqtRemoveInputHook();
%MethodCode
    // Clear the Python input hook installed when the module was initialised.
    PyOS_InputHook = 0;
%End

void pyqtRestoreInputHook();
%MethodCode
    // Restore the input hook.
    PyOS_InputHook = qtcore_input_hook;
%End

%ModuleCode
#include <QCoreApplication>
#include <QThread>

#if defined(Q_OS_WIN)
#include <conio.h>
#include <QTimer>
#else
#include <QSocketNotifier>
#endif

// This is the input hook that will process events while the interpreter is
// waiting for interactive input.
extern "C" {static int qtcore_input_hook();}

static int qtcore_input_hook()
{
    QCoreApplication *app = QCoreApplication::instance();

    if (app && app->thread() == QThread::currentThread())
    {
#if defined(Q_OS_WIN)
        QTimer timer;
        QObject::connect(&timer, SIGNAL(timeout()), app, SLOT(quit()));

        do
        {
            timer.start(100);
            QCoreApplication::exec();
            timer.stop();
        }
        while (!_kbhit());

        QObject::disconnect(&timer, SIGNAL(timeout()), app, SLOT(quit()));
#else
        QSocketNotifier notifier(0, QSocketNotifier::Read, 0);
        QObject::connect(&notifier, SIGNAL(activated(int)), app, SLOT(quit()));
        QCoreApplication::exec();
        QObject::disconnect(&notifier, SIGNAL(activated(int)), app, SLOT(quit()));
#endif
    }

    return 0;
}
%End

%PostInitialisationCode
// Process events from the input hook.
PyOS_InputHook = qtcore_input_hook;
%End
