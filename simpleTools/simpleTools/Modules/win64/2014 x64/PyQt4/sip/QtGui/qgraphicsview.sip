// qgraphicsview.sip generated by MetaSIP on Fri Mar  1 21:45:59 2013
//
// This file is part of the QtGui Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// If you are unsure which license is appropriate for your use, please
// contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%If (Qt_4_2_0 -)
%ModuleCode
#include <qgraphicsview.h>
%End
%End

%If (Qt_4_2_0 -)

class QGraphicsView : QAbstractScrollArea
{
%TypeHeaderCode
#include <qgraphicsview.h>
%End

public:
    enum CacheModeFlag
    {
        CacheNone,
        CacheBackground,
    };

    typedef QFlags<QGraphicsView::CacheModeFlag> CacheMode;

    enum DragMode
    {
        NoDrag,
        ScrollHandDrag,
        RubberBandDrag,
    };

    enum ViewportAnchor
    {
        NoAnchor,
        AnchorViewCenter,
        AnchorUnderMouse,
    };

    QGraphicsView(QWidget *parent /TransferThis/ = 0);
    QGraphicsView(QGraphicsScene *scene /KeepReference/, QWidget *parent /TransferThis/ = 0);
    virtual ~QGraphicsView();
    virtual QSize sizeHint() const;
    QFlags<QPainter::RenderHint> renderHints() const;
    void setRenderHint(QPainter::RenderHint hint, bool on = true);
    void setRenderHints(QFlags<QPainter::RenderHint> hints);
    Qt::Alignment alignment() const;
    void setAlignment(Qt::Alignment alignment);
    QGraphicsView::ViewportAnchor transformationAnchor() const;
    void setTransformationAnchor(QGraphicsView::ViewportAnchor anchor);
    QGraphicsView::ViewportAnchor resizeAnchor() const;
    void setResizeAnchor(QGraphicsView::ViewportAnchor anchor);
    QGraphicsView::DragMode dragMode() const;
    void setDragMode(QGraphicsView::DragMode mode);
    QFlags<QGraphicsView::CacheModeFlag> cacheMode() const;
    void setCacheMode(QFlags<QGraphicsView::CacheModeFlag> mode);
    void resetCachedContent();
    bool isInteractive() const;
    void setInteractive(bool allowed);
    QGraphicsScene *scene() const;
    void setScene(QGraphicsScene *scene /KeepReference/);
    QRectF sceneRect() const;
    void setSceneRect(const QRectF &rect);
    QMatrix matrix() const;
    void setMatrix(const QMatrix &matrix, bool combine = false);
    void resetMatrix();
    void rotate(qreal angle);
    void scale(qreal sx, qreal sy);
    void shear(qreal sh, qreal sv);
    void translate(qreal dx, qreal dy);
    void centerOn(const QPointF &pos);
    void centerOn(const QGraphicsItem *item);
    void ensureVisible(const QRectF &rect, int xMargin = 50, int yMargin = 50);
    void ensureVisible(const QGraphicsItem *item, int xMargin = 50, int yMargin = 50);
    void fitInView(const QRectF &rect, Qt::AspectRatioMode mode = Qt::IgnoreAspectRatio);
    void fitInView(const QGraphicsItem *item, Qt::AspectRatioMode mode = Qt::IgnoreAspectRatio);
    void render(QPainter *painter, const QRectF &target = QRectF(), const QRect &source = QRect(), Qt::AspectRatioMode mode = Qt::KeepAspectRatio);
    QList<QGraphicsItem*> items() const;
    QList<QGraphicsItem*> items(const QPoint &pos) const;
    QList<QGraphicsItem*> items(int ax, int ay) const;
%If (Qt_4_3_0 -)
    QList<QGraphicsItem*> items(int x, int y, int w, int h, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
%End
    QList<QGraphicsItem*> items(const QRect &rect, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
    QList<QGraphicsItem*> items(const QPolygon &polygon, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
    QList<QGraphicsItem*> items(const QPainterPath &path, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
    QGraphicsItem *itemAt(const QPoint &pos) const;
    QPointF mapToScene(const QPoint &point) const;
    QPolygonF mapToScene(const QRect &rect) const;
    QPolygonF mapToScene(const QPolygon &polygon) const;
    QPainterPath mapToScene(const QPainterPath &path) const;
    QPoint mapFromScene(const QPointF &point) const;
    QPolygon mapFromScene(const QRectF &rect) const;
    QPolygon mapFromScene(const QPolygonF &polygon) const;
    QPainterPath mapFromScene(const QPainterPath &path) const;
    virtual QVariant inputMethodQuery(Qt::InputMethodQuery query) const;
    QBrush backgroundBrush() const;
    void setBackgroundBrush(const QBrush &brush);
    QBrush foregroundBrush() const;
    void setForegroundBrush(const QBrush &brush);

public slots:
%If (Qt_4_3_0 -)
    void invalidateScene(const QRectF &rect = QRectF(), QFlags<QGraphicsScene::SceneLayer> layers = QGraphicsScene::AllLayers);
%End
    void updateScene(const QList<QRectF> &rects);
    void updateSceneRect(const QRectF &rect);

protected slots:
%If (Qt_5_0_0 -)
    virtual void setupViewport(QWidget *widget);
%End
%If (- Qt_5_0_0)
    void setupViewport(QWidget *widget);
%End

protected:
    virtual bool event(QEvent *event);
    virtual bool viewportEvent(QEvent *event);
    virtual void contextMenuEvent(QContextMenuEvent *event);
    virtual void dragEnterEvent(QDragEnterEvent *event);
    virtual void dragLeaveEvent(QDragLeaveEvent *event);
    virtual void dragMoveEvent(QDragMoveEvent *event);
    virtual void dropEvent(QDropEvent *event);
    virtual void focusInEvent(QFocusEvent *event);
    virtual void focusOutEvent(QFocusEvent *event);
%If (Qt_4_4_0 -)
    virtual bool focusNextPrevChild(bool next);
%End
    virtual void keyPressEvent(QKeyEvent *event);
    virtual void keyReleaseEvent(QKeyEvent *event);
    virtual void mouseDoubleClickEvent(QMouseEvent *event);
    virtual void mousePressEvent(QMouseEvent *event);
    virtual void mouseMoveEvent(QMouseEvent *event);
    virtual void mouseReleaseEvent(QMouseEvent *event);
    virtual void wheelEvent(QWheelEvent *event);
    virtual void paintEvent(QPaintEvent *event);
    virtual void resizeEvent(QResizeEvent *event);
    virtual void scrollContentsBy(int dx, int dy);
    virtual void showEvent(QShowEvent *event);
    virtual void inputMethodEvent(QInputMethodEvent *event);
    virtual void drawBackground(QPainter *painter, const QRectF &rect);
    virtual void drawForeground(QPainter *painter, const QRectF &rect);
    virtual void drawItems(QPainter *painter, SIP_PYLIST items /DocType="list-of-QGraphicsItem"/, SIP_PYLIST options /DocType="list-of-QStyleOptionGraphicsItem"/) [void (QPainter *painter, int numItems, QGraphicsItem **items, const QStyleOptionGraphicsItem *options)];
%MethodCode
        // PyQt takes lists as the items and options arguments.
        
        // Adjust the number items according to the actual list lengths.
        SIP_SSIZE_T numItems = PyList_GET_SIZE(a1);
        
        if (numItems > PyList_GET_SIZE(a2))
            numItems = PyList_GET_SIZE(a2);
        
        // Allocate temporary storage for the C++ conversions.
        QGraphicsItem **items = new QGraphicsItem *[numItems];
        QStyleOptionGraphicsItem *options = new QStyleOptionGraphicsItem[numItems];
        
        for (int i = 0; i < numItems; ++i)
        {
            void *cpp;
        
            cpp = sipForceConvertToType(PyList_GET_ITEM(a1, i), sipType_QGraphicsItem, NULL, SIP_NO_CONVERTORS, NULL, &sipIsErr);
            items[i] = reinterpret_cast<QGraphicsItem *>(cpp);
        
            cpp = sipForceConvertToType(PyList_GET_ITEM(a2, i), sipType_QStyleOptionGraphicsItem, NULL, SIP_NOT_NONE|SIP_NO_CONVERTORS, NULL, &sipIsErr);
            options[i] = *reinterpret_cast<QStyleOptionGraphicsItem *>(cpp);
        }
        
        if (!sipIsErr)
        {
            Py_BEGIN_ALLOW_THREADS
        #if defined(SIP_PROTECTED_IS_PUBLIC)
            if (sipSelfWasArg)
                sipCpp->QGraphicsView::drawItems(a0, numItems, items, options);
            else
                sipCpp->drawItems(a0, numItems, items, options);
        #else
            sipCpp->sipProtectVirt_drawItems(sipSelfWasArg, a0, numItems, items, options);
        #endif
            Py_END_ALLOW_THREADS
        }
        
        delete[] items;
        delete[] options;
%End

%VirtualCatcherCode
        // PyQt handles the items and options arguments as lists, but keeps the
        // numItems argument.
        PyObject *items = PyList_New(a1);
        PyObject *options = PyList_New(a1);
        
        sipIsErr = (!items || !options);
        
        if (!sipIsErr)
            for (int i = 0; i < a1; ++i)
            {
                PyObject *obj;
        
                obj = sipConvertFromType(a2[i], sipType_QGraphicsItem, 0);
        
                if (!obj)
                {
                    sipIsErr = true;
                    break;
                }
        
                PyList_SET_ITEM(items, i, obj);
        
                obj = sipConvertFromType(const_cast<QStyleOptionGraphicsItem *>(&a3[i]), sipType_QStyleOptionGraphicsItem, 0);
        
                if (!obj)
                {
                    sipIsErr = true;
                    break;
                }
        
                PyList_SET_ITEM(options, i, obj);
            }
        
        if (!sipIsErr)
        {
            PyObject *res = sipCallMethod(&sipIsErr, sipMethod, "DSS", a0, sipType_QPainter, NULL, items, options, NULL);
        
            if (res)
            {
                sipParseResult(&sipIsErr, sipMethod, res, "Z");
                Py_DECREF(res);
            }
        }
        
        Py_XDECREF(items);
        Py_XDECREF(options);
%End

public:
    void setSceneRect(qreal ax, qreal ay, qreal aw, qreal ah);
    void centerOn(qreal ax, qreal ay);
    void ensureVisible(qreal x, qreal y, qreal w, qreal h, int xMargin = 50, int yMargin = 50);
    void fitInView(qreal x, qreal y, qreal w, qreal h, Qt::AspectRatioMode mode = Qt::IgnoreAspectRatio);
    QGraphicsItem *itemAt(int ax, int ay) const;
    QPointF mapToScene(int ax, int ay) const;
    QPolygonF mapToScene(int ax, int ay, int w, int h) const;
    QPoint mapFromScene(qreal ax, qreal ay) const;
    QPolygon mapFromScene(qreal ax, qreal ay, qreal w, qreal h) const;
%If (Qt_4_3_0 -)

    enum ViewportUpdateMode
    {
        FullViewportUpdate,
        MinimalViewportUpdate,
        SmartViewportUpdate,
%If (Qt_4_4_0 -)
        BoundingRectViewportUpdate,
%End
        NoViewportUpdate,
    };

%End
%If (Qt_4_3_0 -)

    enum OptimizationFlag
    {
        DontClipPainter,
        DontSavePainterState,
        DontAdjustForAntialiasing,
    };

%End
%If (Qt_4_3_0 -)
    typedef QFlags<QGraphicsView::OptimizationFlag> OptimizationFlags;
%End
%If (Qt_4_3_0 -)
    QGraphicsView::ViewportUpdateMode viewportUpdateMode() const;
%End
%If (Qt_4_3_0 -)
    void setViewportUpdateMode(QGraphicsView::ViewportUpdateMode mode);
%End
%If (Qt_4_3_0 -)
    QFlags<QGraphicsView::OptimizationFlag> optimizationFlags() const;
%End
%If (Qt_4_3_0 -)
    void setOptimizationFlag(QGraphicsView::OptimizationFlag flag, bool enabled = true);
%End
%If (Qt_4_3_0 -)
    void setOptimizationFlags(QFlags<QGraphicsView::OptimizationFlag> flags);
%End
%If (Qt_4_3_0 -)
    Qt::ItemSelectionMode rubberBandSelectionMode() const;
%End
%If (Qt_4_3_0 -)
    void setRubberBandSelectionMode(Qt::ItemSelectionMode mode);
%End
%If (Qt_4_3_0 -)
    QTransform transform() const;
%End
%If (Qt_4_3_0 -)
    QTransform viewportTransform() const;
%End
%If (Qt_4_3_0 -)
    void setTransform(const QTransform &matrix, bool combine = false);
%End
%If (Qt_4_3_0 -)
    void resetTransform();
%End
%If (Qt_4_6_0 -)
    bool isTransformed() const;
%End

private:
%If (Qt_4_4_0 -)
    QGraphicsView(const QGraphicsView &);
%End
};

%End
%If (Qt_4_2_0 -)
QFlags<QGraphicsView::CacheModeFlag> operator|(QGraphicsView::CacheModeFlag f1, QFlags<QGraphicsView::CacheModeFlag> f2);
%End
%If (Qt_4_3_0 -)
QFlags<QGraphicsView::OptimizationFlag> operator|(QGraphicsView::OptimizationFlag f1, QFlags<QGraphicsView::OptimizationFlag> f2);
%End
