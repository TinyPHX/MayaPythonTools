// qtextdocument.sip generated by MetaSIP on Fri Mar  1 21:46:00 2013
//
// This file is part of the QtGui Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// If you are unsure which license is appropriate for your use, please
// contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%ModuleCode
#include <qtextdocument.h>
%End

namespace Qt
{
%TypeHeaderCode
#include <qtextdocument.h>
%End

%If (- Qt_5_0_0)

    enum HitTestAccuracy
    {
        ExactHit,
        FuzzyHit,
    };

%End
%If (- Qt_5_0_0)

    enum WhiteSpaceMode
    {
        WhiteSpaceNormal,
        WhiteSpacePre,
        WhiteSpaceNoWrap,
        WhiteSpaceModeUndefined,
    };

%End
    bool mightBeRichText(const QString &);
%If (- Qt_5_0_0)
    QString escape(const QString &plain);
%End
    QString convertFromPlainText(const QString &plain, Qt::WhiteSpaceMode mode = Qt::WhiteSpacePre);
};

class QTextDocument : QObject
{
%TypeHeaderCode
#include <qtextdocument.h>
%End

public:
    explicit QTextDocument(QObject *parent /TransferThis/ = 0);
    QTextDocument(const QString &text, QObject *parent /TransferThis/ = 0);
    virtual ~QTextDocument();
    QTextDocument *clone(QObject *parent /TransferThis/ = 0) const /Factory/;
    bool isEmpty() const;
    virtual void clear();
    void setUndoRedoEnabled(bool enable);
    bool isUndoRedoEnabled() const;
    bool isUndoAvailable() const;
    bool isRedoAvailable() const;
    void setDocumentLayout(QAbstractTextDocumentLayout *layout /Transfer/);
    QAbstractTextDocumentLayout *documentLayout() const;

    enum MetaInformation
    {
        DocumentTitle,
%If (Qt_4_4_0 -)
        DocumentUrl,
%End
    };

    void setMetaInformation(QTextDocument::MetaInformation info, const QString &);
    QString metaInformation(QTextDocument::MetaInformation info) const;
    QString toHtml(const QByteArray &encoding = QByteArray()) const;
    void setHtml(const QString &html);
    QString toPlainText() const;
    void setPlainText(const QString &text);

    enum FindFlag
    {
        FindBackward,
        FindCaseSensitively,
        FindWholeWords,
    };

    typedef QFlags<QTextDocument::FindFlag> FindFlags;
    QTextCursor find(const QString &subString, int position = 0, QFlags<QTextDocument::FindFlag> options = 0) const;
%If (Qt_4_2_0 -)
    QTextCursor find(const QRegExp &expr, int position = 0, QFlags<QTextDocument::FindFlag> options = 0) const;
%End
    QTextCursor find(const QString &subString, const QTextCursor &cursor, QFlags<QTextDocument::FindFlag> options = 0) const;
%If (Qt_4_2_0 -)
    QTextCursor find(const QRegExp &expr, const QTextCursor &cursor, QFlags<QTextDocument::FindFlag> options = 0) const;
%End
    QTextFrame *rootFrame() const;
    QTextObject *object(int objectIndex) const;
    QTextObject *objectForFormat(const QTextFormat &) const;
    QTextBlock findBlock(int pos) const;
    QTextBlock begin() const;
    QTextBlock end() const;
    void setPageSize(const QSizeF &size);
    QSizeF pageSize() const;
    void setDefaultFont(const QFont &font);
    QFont defaultFont() const;
    int pageCount() const;
    bool isModified() const;
%If (Qt_5_0_0 -)
%If (PyQt_Printer)
    void print(QPagedPaintDevice *printer) const /PyName=print_/;
%End
%End
%If (- Qt_5_0_0)
%If (PyQt_Printer)
    void print(QPrinter *printer) const /PyName=print_/;
%End
%End
%If (Qt_5_0_0 -)
%If (Py_v3 || PyQt_Printer)
    void print(QPagedPaintDevice *printer) const;
%End
%End
%If (- Qt_5_0_0)
%If (Py_v3 || PyQt_Printer)
    void print(QPrinter *printer) const;
%End
%End

    enum ResourceType
    {
        HtmlResource,
        ImageResource,
%If (Qt_4_2_0 -)
        StyleSheetResource,
%End
        UserResource,
    };

    QVariant resource(int type, const QUrl &name) const;
    void addResource(int type, const QUrl &name, const QVariant &resource);
    QVector<QTextFormat> allFormats() const;
    void markContentsDirty(int from, int length);
    void setUseDesignMetrics(bool b);
    bool useDesignMetrics() const;

signals:
%If (Qt_4_3_0 -)
    void blockCountChanged(int newBlockCount);
%End
    void contentsChange(int from, int charsRemoves, int charsAdded);
    void contentsChanged();
    void cursorPositionChanged(const QTextCursor &cursor);
    void modificationChanged(bool m);
    void redoAvailable(bool);
    void undoAvailable(bool);

public slots:
    void undo();
    void redo();
    void setModified(bool on = true);

protected:
    virtual QTextObject *createObject(const QTextFormat &f) /Factory/;
    virtual QVariant loadResource(int type, const QUrl &name);

public:
%If (Qt_4_2_0 -)
    void drawContents(QPainter *p, const QRectF &rect = QRectF());
%End
%If (Qt_4_2_0 -)
    void setTextWidth(qreal width);
%End
%If (Qt_4_2_0 -)
    qreal textWidth() const;
%End
%If (Qt_4_2_0 -)
    qreal idealWidth() const;
%End
%If (Qt_4_2_0 -)
    void adjustSize();
%End
%If (Qt_4_2_0 -)
    QSizeF size() const;
%End
%If (Qt_4_2_0 -)
    int blockCount() const;
%End
%If (Qt_4_2_0 -)
    void setDefaultStyleSheet(const QString &sheet);
%End
%If (Qt_4_2_0 -)
    QString defaultStyleSheet() const;
%End
%If (Qt_4_2_0 -)
    void undo(QTextCursor *cursor);
%End
%If (Qt_4_2_0 -)
    void redo(QTextCursor *cursor);
%End
%If (Qt_4_2_0 -)
    int maximumBlockCount() const;
%End
%If (Qt_4_2_0 -)
    void setMaximumBlockCount(int maximum);
%End
%If (Qt_4_3_0 -)
    QTextOption defaultTextOption() const;
%End
%If (Qt_4_3_0 -)
    void setDefaultTextOption(const QTextOption &option);
%End
%If (Qt_4_4_0 -)
    int revision() const;
%End
%If (Qt_4_4_0 -)
    QTextBlock findBlockByNumber(int blockNumber) const;
%End
%If (Qt_4_5_0 -)
    QTextBlock findBlockByLineNumber(int blockNumber) const;
%End
%If (Qt_4_4_0 -)
    QTextBlock firstBlock() const;
%End
%If (Qt_4_4_0 -)
    QTextBlock lastBlock() const;
%End
%If (Qt_4_4_0 -)
    qreal indentWidth() const;
%End
%If (Qt_4_4_0 -)
    void setIndentWidth(qreal width);
%End

signals:
%If (Qt_4_4_0 -)
    void undoCommandAdded();
%End
%If (Qt_4_4_0 -)
    void documentLayoutChanged();
%End

public:
%If (Qt_4_5_0 -)
    QChar characterAt(int pos) const;
%End
%If (Qt_4_5_0 -)
    qreal documentMargin() const;
%End
%If (Qt_4_5_0 -)
    void setDocumentMargin(qreal margin);
%End
%If (Qt_4_5_0 -)
    int lineCount() const;
%End
%If (Qt_4_5_0 -)
    int characterCount() const;
%End
%If (Qt_4_6_0 -)
    int availableUndoSteps() const;
%End
%If (Qt_4_6_0 -)
    int availableRedoSteps() const;
%End
%If (Qt_4_7_0 -)

    enum Stacks
    {
        UndoStack,
        RedoStack,
        UndoAndRedoStacks,
    };

%End
%If (Qt_4_7_0 -)
    void clearUndoRedoStacks(QTextDocument::Stacks stacks = QTextDocument::UndoAndRedoStacks);
%End
%If (Qt_4_8_0 -)
    Qt::CursorMoveStyle defaultCursorMoveStyle() const;
%End
%If (Qt_4_8_0 -)
    void setDefaultCursorMoveStyle(Qt::CursorMoveStyle style);
%End

private:
    QTextDocument(const QTextDocument &);
};

QFlags<QTextDocument::FindFlag> operator|(QTextDocument::FindFlag f1, QFlags<QTextDocument::FindFlag> f2);
