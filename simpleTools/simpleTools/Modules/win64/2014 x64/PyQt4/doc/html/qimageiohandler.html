<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html><head><title>QImageIOHandler Class Reference</title><style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style></head><body><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr /><td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" width="32" /></td><td width="1">&#160;&#160;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&#160;&#183; <a href="classes.html"><font color="#004faf">All Classes</font></a>&#160;&#183; <a href="modules.html"><font color="#004faf">Modules</font></a></td></table><h1 align="center">QImageIOHandler Class Reference<br /><sup><sup>[<a href="qtgui.html">QtGui</a> module]</sup></sup></h1><p>The QImageIOHandler class defines the common image I/O interface
for all image formats in Qt. <a href="#details">More...</a></p>

<h3>Types</h3><ul><li><div class="fn" />enum <b><a href="qimageiohandler.html#ImageOption-enum">ImageOption</a></b> { Size, ClipRect, Description, ScaledClipRect, ..., BackgroundColor }</li></ul><h3>Methods</h3><ul><li><div class="fn" /><b><a href="qimageiohandler.html#QImageIOHandler">__init__</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qimageiohandler.html#canRead">canRead</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qimageiohandler.html#currentImageNumber">currentImageNumber</a></b> (<i>self</i>)</li><li><div class="fn" />QRect <b><a href="qimageiohandler.html#currentImageRect">currentImageRect</a></b> (<i>self</i>)</li><li><div class="fn" />QIODevice <b><a href="qimageiohandler.html#device">device</a></b> (<i>self</i>)</li><li><div class="fn" />QByteArray <b><a href="qimageiohandler.html#format">format</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qimageiohandler.html#imageCount">imageCount</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qimageiohandler.html#jumpToImage">jumpToImage</a></b> (<i>self</i>, int&#160;<i>imageNumber</i>)</li><li><div class="fn" />bool <b><a href="qimageiohandler.html#jumpToNextImage">jumpToNextImage</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qimageiohandler.html#loopCount">loopCount</a></b> (<i>self</i>)</li><li><div class="fn" />QByteArray <b><a href="qimageiohandler.html#name">name</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qimageiohandler.html#nextImageDelay">nextImageDelay</a></b> (<i>self</i>)</li><li><div class="fn" />QVariant <b><a href="qimageiohandler.html#option">option</a></b> (<i>self</i>, ImageOption&#160;<i>option</i>)</li><li><div class="fn" />bool <b><a href="qimageiohandler.html#read">read</a></b> (<i>self</i>, QImage&#160;<i>image</i>)</li><li><div class="fn" /><b><a href="qimageiohandler.html#setDevice">setDevice</a></b> (<i>self</i>, QIODevice&#160;<i>device</i>)</li><li><div class="fn" /><b><a href="qimageiohandler.html#setFormat">setFormat</a></b> (<i>self</i>, QByteArray&#160;<i>format</i>)</li><li><div class="fn" /><b><a href="qimageiohandler.html#setOption">setOption</a></b> (<i>self</i>, ImageOption&#160;<i>option</i>, QVariant&#160;<i>value</i>)</li><li><div class="fn" />bool <b><a href="qimageiohandler.html#supportsOption">supportsOption</a></b> (<i>self</i>, ImageOption&#160;<i>option</i>)</li><li><div class="fn" />bool <b><a href="qimageiohandler.html#write">write</a></b> (<i>self</i>, QImage&#160;<i>image</i>)</li></ul><a name="details" /><hr /><h2>Detailed Description</h2><p>The QImageIOHandler class defines the common image I/O interface
for all image formats in Qt.</p>
<p>Qt uses QImageIOHandler for reading and writing images through
<a href="qimagereader.html">QImageReader</a> and <a href="qimagewriter.html">QImageWriter</a>. You can also derive from this
class to write your own image format handler using Qt's plugin
mechanism.</p>
<p>Call <a href="qimageiohandler.html#setDevice">setDevice</a>() to
assign a device to the handler, and <a href="qimageiohandler.html#setFormat">setFormat</a>() to assign a format
to it. One QImageIOHandler may support more than one image format.
<a href="qimageiohandler.html#canRead">canRead</a>() returns true
if an image can be read from the device, and <a href="qimageiohandler.html#read">read</a>() and <a href="qimageiohandler.html#write">write</a>() return true if reading or
writing an image was completed successfully.</p>
<p>QImageIOHandler also has support for animations formats, through
the functions <a href="qimageiohandler.html#loopCount">loopCount</a>(), <a href="qimageiohandler.html#imageCount">imageCount</a>(), <a href="qimageiohandler.html#nextImageDelay">nextImageDelay</a>() and
<a href="qimageiohandler.html#currentImageNumber">currentImageNumber</a>().</p>
<p>In order to determine what options an image handler supports, Qt
will call <a href="qimageiohandler.html#supportsOption">supportsOption</a>() and
<a href="qimageiohandler.html#setOption">setOption</a>(). Make sure
to reimplement these functions if you can provide support for any
of the options in the <a href="qimageiohandler.html#ImageOption-enum">ImageOption</a> enum.</p>
<p>To write your own image handler, you must at least reimplement
<a href="qimageiohandler.html#canRead">canRead</a>() and <a href="qimageiohandler.html#read">read</a>(). Then create a <a href="qimageioplugin.html">QImageIOPlugin</a> that can create the
handler. Finally, install your plugin, and <a href="qimagereader.html">QImageReader</a> and <a href="qimagewriter.html">QImageWriter</a> will then automatically load
the plugin, and start using it.</p>
<hr /><h2>Type Documentation</h2><h3 class="fn"><a name="ImageOption-enum" />QImageIOHandler.ImageOption</h3><p>This enum describes the different options supported by <a href="qimageiohandler.html">QImageIOHandler</a>. Some options are used
to query an image for properties, and others are used to toggle the
way in which an image should be written.</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QImageIOHandler.Size</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">The original size of an image. A handler that
supports this option is expected to read the size of the image from
the image metadata, and return this size from <a href="qimageiohandler.html#option">option</a>() as a <a href="qsize.html">QSize</a>.</td>
</tr>
<tr>
<td class="topAlign"><tt>QImageIOHandler.ClipRect</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">The clip rect, or ROI (Region Of Interest). A
handler that supports this option is expected to only read the
provided <a href="qrect.html">QRect</a> area from the original
image in <a href="qimageiohandler.html#read">read</a>(), before any
other transformation is applied.</td>
</tr>
<tr>
<td class="topAlign"><tt>QImageIOHandler.ScaledSize</tt></td>
<td class="topAlign"><tt>4</tt></td>
<td class="topAlign">The scaled size of the image. A handler that
supports this option is expected to scale the image to the provided
size (a <a href="qsize.html">QSize</a>), after applying any clip
rect transformation (ClipRect). If the handler does not support
this option, <a href="qimagereader.html">QImageReader</a> will
perform the scaling after the image has been read.</td>
</tr>
<tr>
<td class="topAlign"><tt>QImageIOHandler.ScaledClipRect</tt></td>
<td class="topAlign"><tt>3</tt></td>
<td class="topAlign">The scaled clip rect (or ROI, Region Of
Interest) of the image. A handler that supports this option is
expected to apply the provided clip rect (a <a href="qrect.html">QRect</a>), after applying any scaling (ScaleSize) or
regular clipping (ClipRect). If the handler does not support this
option, <a href="qimagereader.html">QImageReader</a> will apply the
scaled clip rect after the image has been read.</td>
</tr>
<tr>
<td class="topAlign"><tt>QImageIOHandler.Description</tt></td>
<td class="topAlign"><tt>2</tt></td>
<td class="topAlign">The image description. Some image formats,
such as GIF and PNG, allow embedding of text or comments into the
image data (e.g., for storing copyright information). It's common
that the text is stored in key-value pairs, but some formats store
all text in one continuous block. <a href="qimageiohandler.html">QImageIOHandler</a> returns the text as one
<a href="qstring.html">QString</a>, where keys and values are
separated by a ':', and keys-value pairs are separated by two
newlines (\n\n). For example, "Title: Sunset\n\nAuthor: Jim
Smith\nSarah Jones\n\n". Formats that store text in a single block
can use "Description" as the key.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QImageIOHandler.CompressionRatio</tt></td>
<td class="topAlign"><tt>5</tt></td>
<td class="topAlign">The compression ratio of the image data. A
handler that supports this option is expected to set its
compression rate depending on the value of this option (an int)
when writing.</td>
</tr>
<tr>
<td class="topAlign"><tt>QImageIOHandler.Gamma</tt></td>
<td class="topAlign"><tt>6</tt></td>
<td class="topAlign">The gamma level of the image. A handler that
supports this option is expected to set the image gamma level
depending on the value of this option (a float) when writing.</td>
</tr>
<tr>
<td class="topAlign"><tt>QImageIOHandler.Quality</tt></td>
<td class="topAlign"><tt>7</tt></td>
<td class="topAlign">The quality level of the image. A handler that
supports this option is expected to set the image quality level
depending on the value of this option (an int) when writing.</td>
</tr>
<tr>
<td class="topAlign"><tt>QImageIOHandler.Name</tt></td>
<td class="topAlign"><tt>8</tt></td>
<td class="topAlign">The name of the image. A handler that supports
this option is expected to read the name from the image metadata
and return this as a <a href="qstring.html">QString</a>, or when
writing an image it is expected to store the name in the image
metadata.</td>
</tr>
<tr>
<td class="topAlign"><tt>QImageIOHandler.SubType</tt></td>
<td class="topAlign"><tt>9</tt></td>
<td class="topAlign">The subtype of the image. A handler that
supports this option can use the subtype value to help when reading
and writing images. For example, a PPM handler may have a subtype
value of "ppm" or "ppmraw".</td>
</tr>
<tr>
<td class="topAlign">
<tt>QImageIOHandler.IncrementalReading</tt></td>
<td class="topAlign"><tt>10</tt></td>
<td class="topAlign">A handler that supports this option is
expected to read the image in several passes, as if it was an
animation. <a href="qimagereader.html">QImageReader</a> will treat
the image as an animation.</td>
</tr>
<tr>
<td class="topAlign"><tt>QImageIOHandler.Endianness</tt></td>
<td class="topAlign"><tt>11</tt></td>
<td class="topAlign">The endianness of the image. Certain image
formats can be stored as BigEndian or LittleEndian. A handler that
supports Endianness uses the value of this option to determine how
the image should be stored.</td>
</tr>
<tr>
<td class="topAlign"><tt>QImageIOHandler.Animation</tt></td>
<td class="topAlign"><tt>12</tt></td>
<td class="topAlign">Image formats that support animation return
true for this value in <a href="qimageiohandler.html#supportsOption">supportsOption</a>();
otherwise, false is returned.</td>
</tr>
<tr>
<td class="topAlign"><tt>QImageIOHandler.BackgroundColor</tt></td>
<td class="topAlign"><tt>13</tt></td>
<td class="topAlign">Certain image formats allow the background
color to be specified. A handler that supports BackgroundColor
initializes the background color to this option (a <a href="qcolor.html">QColor</a>) when reading an image.</td>
</tr>
<tr>
<td class="topAlign"><tt>QImageIOHandler.ImageFormat</tt></td>
<td class="topAlign"><tt>14</tt></td>
<td class="topAlign">The image's data format returned by the
handler. This can be any of the formats listed in <a href="qimage.html#Format-enum">QImage.Format</a>.</td>
</tr>
</table>
<hr /><h2>Method Documentation</h2><h3 class="fn"><a name="QImageIOHandler" />QImageIOHandler.__init__ (<i>self</i>)</h3><p>Constructs a <a href="qimageiohandler.html">QImageIOHandler</a>
object.</p>


<h3 class="fn"><a name="canRead" />bool QImageIOHandler.canRead (<i>self</i>)</h3><p>This method is abstract and should be reimplemented in any sub-class.</p><p>Returns true if an image can be read from the device (i.e., the
image format is supported, the device can be read from and the
initial header information suggests that the image can be read);
otherwise returns false.</p>
<p>When reimplementing canRead(), make sure that the I/O device
(<a href="qimageiohandler.html#device">device</a>()) is left in its
original state (e.g., by using peek() rather than <a href="qimageiohandler.html#read">read</a>()).</p>
<p><b>See also</b> <a href="qimageiohandler.html#read">read</a>()
and <a href="qiodevice.html#peek">QIODevice.peek</a>().</p>


<h3 class="fn"><a name="currentImageNumber" />int QImageIOHandler.currentImageNumber (<i>self</i>)</h3><p>For image formats that support animation, this function returns
the sequence number of the current image in the animation. If this
function is called before any image is <a href="qimageiohandler.html#read">read</a>(), -1 is returned. The number
of the first image in the sequence is 0.</p>
<p>If the image format does not support animation, 0 is
returned.</p>
<p><b>See also</b> <a href="qimageiohandler.html#read">read</a>().</p>


<h3 class="fn"><a name="currentImageRect" /><a href="qrect.html">QRect</a> QImageIOHandler.currentImageRect (<i>self</i>)</h3><p>Returns the rect of the current image. If no rect is defined for
the image, and empty QRect() is returned.</p>
<p>This function is useful for animations, where only parts of the
frame may be updated at a time.</p>


<h3 class="fn"><a name="device" /><a href="qiodevice.html">QIODevice</a> QImageIOHandler.device (<i>self</i>)</h3><p>Returns the device currently assigned to the <a href="qimageiohandler.html">QImageIOHandler</a>. If not device has been
assigned, 0 is returned.</p>
<p><b>See also</b> <a href="qimageiohandler.html#setDevice">setDevice</a>().</p>


<h3 class="fn"><a name="format" /><a href="qbytearray.html">QByteArray</a> QImageIOHandler.format (<i>self</i>)</h3><p>Returns the format that is currently assigned to <a href="qimageiohandler.html">QImageIOHandler</a>. If no format has been
assigned, an empty string is returned.</p>
<p><b>See also</b> <a href="qimageiohandler.html#setFormat">setFormat</a>().</p>


<h3 class="fn"><a name="imageCount" />int QImageIOHandler.imageCount (<i>self</i>)</h3><p>For image formats that support animation, this function returns
the number of images in the animation. If the image format does not
support animation, or if it is unable to determine the number of
images, 0 is returned.</p>
<p>The default implementation returns 1 if <a href="qimageiohandler.html#canRead">canRead</a>() returns true;
otherwise 0 is returned.</p>


<h3 class="fn"><a name="jumpToImage" />bool QImageIOHandler.jumpToImage (<i>self</i>, int&#160;<i>imageNumber</i>)</h3><p>For image formats that support animation, this function jumps to
the image whose sequence number is <i>imageNumber</i>. The next
call to <a href="qimageiohandler.html#read">read</a>() will attempt
to read this image.</p>
<p>The default implementation does nothing, and returns false.</p>


<h3 class="fn"><a name="jumpToNextImage" />bool QImageIOHandler.jumpToNextImage (<i>self</i>)</h3><p>For image formats that support animation, this function jumps to
the next image.</p>
<p>The default implementation does nothing, and returns false.</p>


<h3 class="fn"><a name="loopCount" />int QImageIOHandler.loopCount (<i>self</i>)</h3><p>For image formats that support animation, this function returns
the number of times the animation should loop. If the image format
does not support animation, 0 is returned.</p>


<h3 class="fn"><a name="name" /><a href="qbytearray.html">QByteArray</a> QImageIOHandler.name (<i>self</i>)</h3><h3 class="fn"><a name="nextImageDelay" />int QImageIOHandler.nextImageDelay (<i>self</i>)</h3><p>For image formats that support animation, this function returns
the number of milliseconds to wait until reading the next image. If
the image format does not support animation, 0 is returned.</p>


<h3 class="fn"><a name="option" />QVariant QImageIOHandler.option (<i>self</i>, <a href="qimageiohandler.html#ImageOption-enum">ImageOption</a>&#160;<i>option</i>)</h3><p>Returns the value assigned to <i>option</i> as a <a href="qvariant.html">QVariant</a>. The type of the value depends on the
option. For example, option(Size) returns a <a href="qsize.html">QSize</a> variant.</p>
<p><b>See also</b> <a href="qimageiohandler.html#setOption">setOption</a>() and <a href="qimageiohandler.html#supportsOption">supportsOption</a>().</p>


<h3 class="fn"><a name="read" />bool QImageIOHandler.read (<i>self</i>, <a href="qimage.html">QImage</a>&#160;<i>image</i>)</h3><p>This method is abstract and should be reimplemented in any sub-class.</p><p>Read an image from the device, and stores it in <i>image</i>.
Returns true if the image is successfully read; otherwise returns
false.</p>
<p>For image formats that support incremental loading, and for
animation formats, the image handler can assume that <i>image</i>
points to the previous frame.</p>
<p><b>See also</b> <a href="qimageiohandler.html#canRead">canRead</a>().</p>


<h3 class="fn"><a name="setDevice" />QImageIOHandler.setDevice (<i>self</i>, <a href="qiodevice.html">QIODevice</a>&#160;<i>device</i>)</h3><p>Sets the device of the <a href="qimageiohandler.html">QImageIOHandler</a> to <i>device</i>. The
image handler will use this device when reading and writing
images.</p>
<p>The device can only be set once and must be set before calling
<a href="qimageiohandler.html#canRead">canRead</a>(), <a href="qimageiohandler.html#read">read</a>(), <a href="qimageiohandler.html#write">write</a>(), etc. If you need to read
multiple files, construct multiple instances of the appropriate
<a href="qimageiohandler.html">QImageIOHandler</a> subclass.</p>
<p><b>See also</b> <a href="qimageiohandler.html#device">device</a>().</p>


<h3 class="fn"><a name="setFormat" />QImageIOHandler.setFormat (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>format</i>)</h3><p>Sets the format of the <a href="qimageiohandler.html">QImageIOHandler</a> to <i>format</i>. The
format is most useful for handlers that support multiple image
formats.</p>
<p><b>See also</b> <a href="qimageiohandler.html#format">format</a>().</p>


<h3 class="fn"><a name="setOption" />QImageIOHandler.setOption (<i>self</i>, <a href="qimageiohandler.html#ImageOption-enum">ImageOption</a>&#160;<i>option</i>, QVariant&#160;<i>value</i>)</h3><p>Sets the option <i>option</i> with the value <i>value</i>.</p>
<p><b>See also</b> <a href="qimageiohandler.html#option">option</a>() and <a href="qimageiohandler.html#ImageOption-enum">ImageOption</a>.</p>


<h3 class="fn"><a name="supportsOption" />bool QImageIOHandler.supportsOption (<i>self</i>, <a href="qimageiohandler.html#ImageOption-enum">ImageOption</a>&#160;<i>option</i>)</h3><p>Returns true if the <a href="qimageiohandler.html">QImageIOHandler</a> supports the option
<i>option</i>; otherwise returns false. For example, if the
<a href="qimageiohandler.html">QImageIOHandler</a> supports the
<a href="qimageiohandler.html#ImageOption-enum">Size</a> option,
supportsOption(Size) must return true.</p>
<p><b>See also</b> <a href="qimageiohandler.html#setOption">setOption</a>() and <a href="qimageiohandler.html#option">option</a>().</p>


<h3 class="fn"><a name="write" />bool QImageIOHandler.write (<i>self</i>, <a href="qimage.html">QImage</a>&#160;<i>image</i>)</h3><p>Writes the image <i>image</i> to the assigned device. Returns
true on success; otherwise returns false.</p>
<p>The default implementation does nothing, and simply returns
false.</p>
<address><hr /><div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address"><td align="left" width="25%">PyQt&#160;4.10 for Windows</td><td align="center" width="50%">Copyright &#169; <a href="http://www.riverbankcomputing.com">Riverbank&#160;Computing&#160;Ltd</a> and <a href="http://www.qtsoftware.com">Nokia</a> 2012</td><td align="right" width="25%">Qt&#160;4.8.4</td></tr></table></div></address></body></html>