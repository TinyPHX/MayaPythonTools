<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html><head><title>QGLWidget Class Reference</title><style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style></head><body><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr /><td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" width="32" /></td><td width="1">&#160;&#160;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&#160;&#183; <a href="classes.html"><font color="#004faf">All Classes</font></a>&#160;&#183; <a href="modules.html"><font color="#004faf">Modules</font></a></td></table><h1 align="center">QGLWidget Class Reference<br /><sup><sup>[<a href="qtopengl.html">QtOpenGL</a> module]</sup></sup></h1><p>The QGLWidget class is a widget for rendering OpenGL graphics.
<a href="#details">More...</a></p>

<p>Inherits <a href="qwidget.html">QWidget</a>.</p><h3>Methods</h3><ul><li><div class="fn" /><b><a href="qglwidget.html#QGLWidget">__init__</a></b> (<i>self</i>, QWidget&#160;<i>parent</i>&#160;=&#160;None, QGLWidget&#160;<i>shareWidget</i>&#160;=&#160;None, Qt.WindowFlags&#160;<i>flags</i>&#160;=&#160;0)</li><li><div class="fn" /><b><a href="qglwidget.html#QGLWidget-2">__init__</a></b> (<i>self</i>, QGLContext&#160;<i>context</i>, QWidget&#160;<i>parent</i>&#160;=&#160;None, QGLWidget&#160;<i>shareWidget</i>&#160;=&#160;None, Qt.WindowFlags&#160;<i>flags</i>&#160;=&#160;0)</li><li><div class="fn" /><b><a href="qglwidget.html#QGLWidget-3">__init__</a></b> (<i>self</i>, QGLFormat&#160;<i>format</i>, QWidget&#160;<i>parent</i>&#160;=&#160;None, QGLWidget&#160;<i>shareWidget</i>&#160;=&#160;None, Qt.WindowFlags&#160;<i>flags</i>&#160;=&#160;0)</li><li><div class="fn" />bool <b><a href="qglwidget.html#autoBufferSwap">autoBufferSwap</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qglwidget.html#bindTexture">bindTexture</a></b> (<i>self</i>, QImage&#160;<i>image</i>, int&#160;<i>target</i>&#160;=&#160;GL_TEXTURE_2D, int&#160;<i>format</i>&#160;=&#160;GL_RGBA)</li><li><div class="fn" />int <b><a href="qglwidget.html#bindTexture-2">bindTexture</a></b> (<i>self</i>, QPixmap&#160;<i>pixmap</i>, int&#160;<i>target</i>&#160;=&#160;GL_TEXTURE_2D, int&#160;<i>format</i>&#160;=&#160;GL_RGBA)</li><li><div class="fn" />int <b><a href="qglwidget.html#bindTexture-3">bindTexture</a></b> (<i>self</i>, QString&#160;<i>fileName</i>)</li><li><div class="fn" />int <b><a href="qglwidget.html#bindTexture-4">bindTexture</a></b> (<i>self</i>, QImage&#160;<i>image</i>, int&#160;<i>target</i>, int&#160;<i>format</i>, QGLContext.BindOptions&#160;<i>options</i>)</li><li><div class="fn" />int <b><a href="qglwidget.html#bindTexture-5">bindTexture</a></b> (<i>self</i>, QPixmap&#160;<i>pixmap</i>, int&#160;<i>target</i>, int&#160;<i>format</i>, QGLContext.BindOptions&#160;<i>options</i>)</li><li><div class="fn" />QGLColormap <b><a href="qglwidget.html#colormap">colormap</a></b> (<i>self</i>)</li><li><div class="fn" />QGLContext <b><a href="qglwidget.html#context">context</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qglwidget.html#deleteTexture">deleteTexture</a></b> (<i>self</i>, int&#160;<i>tx_id</i>)</li><li><div class="fn" /><b><a href="qglwidget.html#doneCurrent">doneCurrent</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qglwidget.html#doubleBuffer">doubleBuffer</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qglwidget.html#drawTexture">drawTexture</a></b> (<i>self</i>, QRectF&#160;<i>target</i>, int&#160;<i>textureId</i>, int&#160;<i>textureTarget</i>&#160;=&#160;GL_TEXTURE_2D)</li><li><div class="fn" /><b><a href="qglwidget.html#drawTexture-2">drawTexture</a></b> (<i>self</i>, QPointF&#160;<i>point</i>, int&#160;<i>textureId</i>, int&#160;<i>textureTarget</i>&#160;=&#160;GL_TEXTURE_2D)</li><li><div class="fn" />bool <b><a href="qglwidget.html#event">event</a></b> (<i>self</i>, QEvent)</li><li><div class="fn" />int <b><a href="qglwidget.html#fontDisplayListBase">fontDisplayListBase</a></b> (<i>self</i>, QFont&#160;<i>font</i>, int&#160;<i>listBase</i>&#160;=&#160;2000)</li><li><div class="fn" />QGLFormat <b><a href="qglwidget.html#format">format</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qglwidget.html#glDraw">glDraw</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qglwidget.html#glInit">glInit</a></b> (<i>self</i>)</li><li><div class="fn" />QImage <b><a href="qglwidget.html#grabFrameBuffer">grabFrameBuffer</a></b> (<i>self</i>, bool&#160;<i>withAlpha</i>&#160;=&#160;False)</li><li><div class="fn" /><b><a href="qglwidget.html#initializeGL">initializeGL</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qglwidget.html#initializeOverlayGL">initializeOverlayGL</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qglwidget.html#isSharing">isSharing</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qglwidget.html#isValid">isValid</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qglwidget.html#makeCurrent">makeCurrent</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qglwidget.html#makeOverlayCurrent">makeOverlayCurrent</a></b> (<i>self</i>)</li><li><div class="fn" />QGLContext <b><a href="qglwidget.html#overlayContext">overlayContext</a></b> (<i>self</i>)</li><li><div class="fn" />QPaintEngine <b><a href="qglwidget.html#paintEngine">paintEngine</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qglwidget.html#paintEvent">paintEvent</a></b> (<i>self</i>, QPaintEvent)</li><li><div class="fn" /><b><a href="qglwidget.html#paintGL">paintGL</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qglwidget.html#paintOverlayGL">paintOverlayGL</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qglwidget.html#qglClearColor">qglClearColor</a></b> (<i>self</i>, QColor&#160;<i>c</i>)</li><li><div class="fn" /><b><a href="qglwidget.html#qglColor">qglColor</a></b> (<i>self</i>, QColor&#160;<i>c</i>)</li><li><div class="fn" />QPixmap <b><a href="qglwidget.html#renderPixmap">renderPixmap</a></b> (<i>self</i>, int&#160;<i>width</i>&#160;=&#160;0, int&#160;<i>height</i>&#160;=&#160;0, bool&#160;<i>useContext</i>&#160;=&#160;False)</li><li><div class="fn" /><b><a href="qglwidget.html#renderText">renderText</a></b> (<i>self</i>, int&#160;<i>x</i>, int&#160;<i>y</i>, QString&#160;<i>str</i>, QFont&#160;<i>font</i>&#160;=&#160;QFont(), int&#160;<i>listBase</i>&#160;=&#160;2000)</li><li><div class="fn" /><b><a href="qglwidget.html#renderText-2">renderText</a></b> (<i>self</i>, float&#160;<i>x</i>, float&#160;<i>y</i>, float&#160;<i>z</i>, QString&#160;<i>str</i>, QFont&#160;<i>font</i>&#160;=&#160;QFont(), int&#160;<i>listBase</i>&#160;=&#160;2000)</li><li><div class="fn" /><b><a href="qglwidget.html#resizeEvent">resizeEvent</a></b> (<i>self</i>, QResizeEvent)</li><li><div class="fn" /><b><a href="qglwidget.html#resizeGL">resizeGL</a></b> (<i>self</i>, int&#160;<i>w</i>, int&#160;<i>h</i>)</li><li><div class="fn" /><b><a href="qglwidget.html#resizeOverlayGL">resizeOverlayGL</a></b> (<i>self</i>, int&#160;<i>w</i>, int&#160;<i>h</i>)</li><li><div class="fn" /><b><a href="qglwidget.html#setAutoBufferSwap">setAutoBufferSwap</a></b> (<i>self</i>, bool&#160;<i>on</i>)</li><li><div class="fn" /><b><a href="qglwidget.html#setColormap">setColormap</a></b> (<i>self</i>, QGLColormap&#160;<i>map</i>)</li><li><div class="fn" /><b><a href="qglwidget.html#setContext">setContext</a></b> (<i>self</i>, QGLContext&#160;<i>context</i>, QGLContext&#160;<i>shareContext</i>&#160;=&#160;None, bool&#160;<i>deleteOldContext</i>&#160;=&#160;True)</li><li><div class="fn" /><b><a href="qglwidget.html#setFormat">setFormat</a></b> (<i>self</i>, QGLFormat&#160;<i>format</i>)</li><li><div class="fn" /><b><a href="qglwidget.html#setMouseTracking">setMouseTracking</a></b> (<i>self</i>, bool&#160;<i>enable</i>)</li><li><div class="fn" /><b><a href="qglwidget.html#swapBuffers">swapBuffers</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qglwidget.html#updateGL">updateGL</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qglwidget.html#updateOverlayGL">updateOverlayGL</a></b> (<i>self</i>)</li></ul><h3>Static Methods</h3><ul><li><div class="fn" />QImage <b><a href="qglwidget.html#convertToGLFormat">convertToGLFormat</a></b> (QImage&#160;<i>img</i>)</li></ul><a name="details" /><hr /><h2>Detailed Description</h2><p>The QGLWidget class is a widget for rendering OpenGL
graphics.</p>
<p>QGLWidget provides functionality for displaying OpenGL graphics
integrated into a Qt application. It is very simple to use. You
inherit from it and use the subclass like any other <a href="qwidget.html">QWidget</a>, except that you have the choice between
using <a href="qpainter.html">QPainter</a> and standard OpenGL
rendering commands.</p>
<p>QGLWidget provides three convenient virtual functions that you
can reimplement in your subclass to perform the typical OpenGL
tasks:</p>
<ul>
<li><a href="qglwidget.html#paintGL">paintGL</a>() - Renders the
OpenGL scene. Gets called whenever the widget needs to be
updated.</li>
<li><a href="qglwidget.html#resizeGL">resizeGL</a>() - Sets up the
OpenGL viewport, projection, etc. Gets called whenever the widget
has been resized (and also when it is shown for the first time
because all newly created widgets get a resize event
automatically).</li>
<li><a href="qglwidget.html#initializeGL">initializeGL</a>() - Sets
up the OpenGL rendering context, defines display lists, etc. Gets
called once before the first time <a href="qglwidget.html#resizeGL">resizeGL</a>() or <a href="qglwidget.html#paintGL">paintGL</a>() is called.</li>
</ul>
<p>Here is a rough outline of how a QGLWidget subclass might
look:</p>
<pre class="cpp">
 <span class="keyword">class</span> MyGLDrawer : <span class="keyword">public</span> <span class="type">QGLWidget</span>
 {
     Q_OBJECT        <span class="comment">// must include this if you use Qt signals/slots</span>

 <span class="keyword">public</span>:
     MyGLDrawer(<span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>parent)
         : <span class="type">QGLWidget</span>(parent) {}

 <span class="keyword">protected</span>:

     <span class="type">void</span> initializeGL()
     {
         <span class="comment">// Set up the rendering context, define display lists etc.:</span>
         <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
         glClearColor(<span class="number">0.0</span><span class="operator">,</span> <span class="number">0.0</span><span class="operator">,</span> <span class="number">0.0</span><span class="operator">,</span> <span class="number">0.0</span>);
         glEnable(GL_DEPTH_TEST);
         <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     }

     <span class="type">void</span> resizeGL(<span class="type">int</span> w<span class="operator">,</span> <span class="type">int</span> h)
     {
         <span class="comment">// setup viewport, projection etc.:</span>
         glViewport(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> (GLint)w<span class="operator">,</span> (GLint)h);
         <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
         glFrustum(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);
         <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     }

     <span class="type">void</span> paintGL()
     {
         <span class="comment">// draw the scene:</span>
         <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
         glRotatef(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);
         glMaterialfv(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);
         glBegin(GL_QUADS);
         glVertex3f(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);
         glVertex3f(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);
         <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
         glEnd();
         <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     }

 };
</pre>
<p>If you need to trigger a repaint from places other than <a href="qglwidget.html#paintGL">paintGL</a>() (a typical example is when
using <a href="qtimer.html">timers</a> to animate scenes), you
should call the widget's <a href="qglwidget.html#updateGL">updateGL</a>() function.</p>
<p>Your widget's OpenGL rendering context is made current when
<a href="qglwidget.html#paintGL">paintGL</a>(), <a href="qglwidget.html#resizeGL">resizeGL</a>(), or <a href="qglwidget.html#initializeGL">initializeGL</a>() is called. If you
need to call the standard OpenGL API functions from other places
(e.g. in your widget's constructor or in your own paint functions),
you must call <a href="qglwidget.html#makeCurrent">makeCurrent</a>() first.</p>
<p>QGLWidget provides functions for requesting a new display
<a href="qglformat.html">format</a> and you can also create widgets
with customized rendering <a href="qglcontext.html">contexts</a>.</p>
<p>You can also share OpenGL display lists between QGLWidget
objects (see the documentation of the QGLWidget constructors for
details).</p>
<p>Note that under Windows, the <a href="qglcontext.html">QGLContext</a> belonging to a QGLWidget has to be
recreated when the QGLWidget is reparented. This is necessary due
to limitations on the Windows platform. This will most likely cause
problems for users that have subclassed and installed their own
<a href="qglcontext.html">QGLContext</a> on a QGLWidget. It is
possible to work around this issue by putting the QGLWidget inside
a dummy widget and then reparenting the dummy widget, instead of
the QGLWidget. This will side-step the issue altogether, and is
what we recommend for users that need this kind of
functionality.</p>
<p>On Mac OS X, when Qt is built with Cocoa support, a QGLWidget
can't have any sibling widgets placed ontop of itself. This is due
to limitations in the Cocoa API and is not supported by Apple.</p>
<a id="overlays" name="overlays" />
<h3>Overlays</h3>
<p>The QGLWidget creates a GL overlay context in addition to the
normal context if overlays are supported by the underlying
system.</p>
<p>If you want to use overlays, you specify it in the <a href="qglformat.html">format</a>. (Note: Overlay must be requested in
the format passed to the QGLWidget constructor.) Your GL widget
should also implement some or all of these virtual methods:</p>
<ul>
<li><a href="qglwidget.html#paintOverlayGL">paintOverlayGL</a>()</li>
<li><a href="qglwidget.html#resizeOverlayGL">resizeOverlayGL</a>()</li>
<li><a href="qglwidget.html#initializeOverlayGL">initializeOverlayGL</a>()</li>
</ul>
<p>These methods work in the same way as the normal <a href="qglwidget.html#paintGL">paintGL</a>() etc. functions, except that
they will be called when the overlay context is made current. You
can explicitly make the overlay context current by using <a href="qglwidget.html#makeOverlayCurrent">makeOverlayCurrent</a>(), and
you can access the overlay context directly (e.g. to ask for its
transparent color) by calling <a href="qglwidget.html#overlayContext">overlayContext</a>().</p>
<p>On X servers in which the default visual is in an overlay plane,
non-GL Qt windows can also be used for overlays.</p>
<a id="painting-techniques" name="painting-techniques" />
<h3>Painting Techniques</h3>
<p>As described above, subclass QGLWidget to render pure 3D content
in the following way:</p>
<ul>
<li>Reimplement the <a href="qglwidget.html#initializeGL">QGLWidget.initializeGL</a>() and
<a href="qglwidget.html#resizeGL">QGLWidget.resizeGL</a>() to set
up the OpenGL state and provide a perspective transformation.</li>
<li>Reimplement <a href="qglwidget.html#paintGL">QGLWidget.paintGL</a>() to paint the 3D
scene, calling only OpenGL functions to draw on the widget.</li>
</ul>
<p>It is also possible to draw 2D graphics onto a QGLWidget
subclass, it is necessary to reimplement <a href="qglwidget.html#paintEvent">QGLWidget.paintEvent</a>() and do the
following:</p>
<ul>
<li>Construct a <a href="qpainter.html">QPainter</a> object.</li>
<li>Initialize it for use on the widget with the <a href="qpainter.html#begin">QPainter.begin</a>() function.</li>
<li>Draw primitives using <a href="qpainter.html">QPainter</a>'s
member functions.</li>
<li>Call <a href="qpainter.html#end">QPainter.end</a>() to finish
painting.</li>
</ul>
<p>Overpainting 2D content on top of 3D content takes a little more
effort. One approach to doing this is shown in the <a href="opengl-overpainting.html">Overpainting</a> example.</p>
<a id="threading" name="threading" />
<h3>Threading</h3>
<p>As of Qt version 4.8, support for doing threaded GL rendering
has been improved. There are three scenarios that we currently
support:</p>
<ul>
<li>1. Buffer swapping in a thread.
<p>Swapping buffers in a double buffered context may be a
synchronous, locking call that may be a costly operation in some GL
implementations. Especially so on embedded devices. It's not
optimal to have the CPU idling while the GPU is doing a buffer
swap. In those cases it is possible to do the rendering in the main
thread and do the actual buffer swap in a separate thread. This can
be done with the following steps:</p>
<p>1. Call <a href="qglwidget.html#doneCurrent">doneCurrent</a>()
in the main thread when the rendering is finished.</p>
<p>2. Notify the swapping thread that it can grab the context.</p>
<p>3. Make the rendering context current in the swapping thread
with <a href="qglwidget.html#makeCurrent">makeCurrent</a>() and
then call <a href="qglwidget.html#swapBuffers">swapBuffers</a>().</p>
<p>4. Call <a href="qglwidget.html#doneCurrent">doneCurrent</a>()
in the swapping thread and notify the main thread that swapping is
done.</p>
<p>Doing this will free up the main thread so that it can continue
with, for example, handling UI events or network requests. Even if
there is a context swap involved, it may be preferable compared to
having the main thread wait while the GPU finishes the swap
operation. Note that this is highly implementation dependent.</p>
</li>
<li>2. Texture uploading in a thread.
<p>Doing texture uploads in a thread may be very useful for
applications handling large amounts of images that needs to be
displayed, like for instance a photo gallery application. This is
supported in Qt through the existing <a href="qglwidget.html#bindTexture">bindTexture</a>() API. A simple way of
doing this is to create two sharing QGLWidgets. One is made current
in the main GUI thread, while the other is made current in the
texture upload thread. The widget in the uploading thread is never
shown, it is only used for sharing textures with the main thread.
For each texture that is bound via <a href="qglwidget.html#bindTexture">bindTexture</a>(), notify the main
thread so that it can start using the texture.</p>
</li>
<li>3. Using <a href="qpainter.html">QPainter</a> to draw into a
QGLWidget in a thread.
<p>In Qt 4.8, it is possible to draw into a QGLWidget using a
<a href="qpainter.html">QPainter</a> in a separate thread. Note
that this is also possible for QGLPixelBuffers and
QGLFramebufferObjects. Since this is only supported in the GL 2
paint engine, OpenGL 2.0 or OpenGL ES 2.0 is required.</p>
<p>QGLWidgets can only be created in the main GUI thread. This
means a call to <a href="qglwidget.html#doneCurrent">doneCurrent</a>() is necessary to
release the GL context from the main thread, before the widget can
be drawn into by another thread. Also, the main GUI thread will
dispatch resize and paint events to a QGLWidget when the widget is
resized, or parts of it becomes exposed or needs redrawing. It is
therefore necessary to handle those events because the default
implementations inside QGLWidget will try to make the QGLWidget's
context current, which again will interfere with any threads
rendering into the widget. Reimplement <a href="qglwidget.html#paintEvent">QGLWidget.paintEvent</a>() and
<a href="qglwidget.html#resizeEvent">QGLWidget.resizeEvent</a>()
to notify the rendering thread that a resize or update is
necessary, and be careful not to call the base class
implementation. If you are rendering an animation, it might not be
necessary to handle the paint event at all since the rendering
thread is doing regular updates. Then it would be enough to
reimplement <a href="qglwidget.html#paintEvent">QGLWidget.paintEvent</a>() to do
nothing.</p>
</li>
</ul>
<p>As a general rule when doing threaded rendering: be aware that
binding and releasing contexts in different threads have to be
synchronized by the user. A GL rendering context can only be
current in one thread at any time. If you try to open a <a href="qpainter.html">QPainter</a> on a QGLWidget and the widget's
rendering context is current in another thread, it will fail.</p>
<p>Note that under X11 it is necessary to set the <a href="qt.html#ApplicationAttribute-enum">Qt.AA_X11InitThreads</a>
application attribute to make the X11 library and GLX calls thread
safe, otherwise the above scenarios will fail.</p>
<p>In addition to this, rendering using raw GL calls in a separate
thread is supported.</p>
<p><i>OpenGL is a trademark of Silicon Graphics, Inc. in the United
States and other countries.</i></p>
<hr /><h2>Method Documentation</h2><h3 class="fn"><a name="QGLWidget" />QGLWidget.__init__ (<i>self</i>, <a href="qwidget.html">QWidget</a>&#160;<i>parent</i>&#160;=&#160;None, <a href="qglwidget.html">QGLWidget</a>&#160;<i>shareWidget</i>&#160;=&#160;None, <a href="qt-windowflags.html">Qt.WindowFlags</a>&#160;<i>flags</i>&#160;=&#160;0)</h3><p>The <i>parent</i> argument, if not None, causes <i>self</i> to be owned by Qt instead of PyQt.</p><p>Constructs an OpenGL widget with a <i>parent</i> widget.</p>
<p>The <a href="qglformat.html#defaultFormat">default format</a> is
used. The widget will be <a href="qglwidget.html#isValid">invalid</a> if the system has no <a href="qglformat.html#hasOpenGL">OpenGL support</a>.</p>
<p>The <i>parent</i> and widget flag, <i>f</i>, arguments are
passed to the <a href="qwidget.html">QWidget</a> constructor.</p>
<p>If <i>shareWidget</i> is a valid <a href="qglwidget.html">QGLWidget</a>, this widget will share OpenGL
display lists and texture objects with <i>shareWidget</i>. But if
<i>shareWidget</i> and this widget have different <a href="qglwidget.html#format">formats</a>, sharing might not be possible.
You can check whether sharing is in effect by calling <a href="qglwidget.html#isSharing">isSharing</a>().</p>
<p>The initialization of OpenGL rendering state, etc. should be
done by overriding the <a href="qglwidget.html#initializeGL">initializeGL</a>() function, rather
than in the constructor of your <a href="qglwidget.html">QGLWidget</a> subclass.</p>
<p><b>See also</b> <a href="qglformat.html#defaultFormat">QGLFormat.defaultFormat</a>() and
<a href="opengl-textures.html">Textures Example</a>.</p>


<h3 class="fn"><a name="QGLWidget-2" />QGLWidget.__init__ (<i>self</i>, <a href="qglcontext.html">QGLContext</a>&#160;<i>context</i>, <a href="qwidget.html">QWidget</a>&#160;<i>parent</i>&#160;=&#160;None, <a href="qglwidget.html">QGLWidget</a>&#160;<i>shareWidget</i>&#160;=&#160;None, <a href="qt-windowflags.html">Qt.WindowFlags</a>&#160;<i>flags</i>&#160;=&#160;0)</h3><p>The <i>context</i> argument has it's ownership transferred to Qt.</p><p>The <i>parent</i> argument, if not None, causes <i>self</i> to be owned by Qt instead of PyQt.</p><p>Constructs an OpenGL widget with parent <i>parent</i>.</p>
<p>The <i>context</i> argument is a pointer to the <a href="qglcontext.html">QGLContext</a> that you wish to be bound to this
widget. This allows you to pass in your own <a href="qglcontext.html">QGLContext</a> sub-classes.</p>
<p>The widget will be <a href="qglwidget.html#isValid">invalid</a>
if the system has no <a href="qglformat.html#hasOpenGL">OpenGL
support</a>.</p>
<p>The <i>parent</i> and widget flag, <i>f</i>, arguments are
passed to the <a href="qwidget.html">QWidget</a> constructor.</p>
<p>If <i>shareWidget</i> is a valid <a href="qglwidget.html">QGLWidget</a>, this widget will share OpenGL
display lists and texture objects with <i>shareWidget</i>. But if
<i>shareWidget</i> and this widget have different <a href="qglwidget.html#format">formats</a>, sharing might not be possible.
You can check whether sharing is in effect by calling <a href="qglwidget.html#isSharing">isSharing</a>().</p>
<p>The initialization of OpenGL rendering state, etc. should be
done by overriding the <a href="qglwidget.html#initializeGL">initializeGL</a>() function, rather
than in the constructor of your <a href="qglwidget.html">QGLWidget</a> subclass.</p>
<p><b>See also</b> <a href="qglformat.html#defaultFormat">QGLFormat.defaultFormat</a>() and
<a href="qglwidget.html#isValid">isValid</a>().</p>


<h3 class="fn"><a name="QGLWidget-3" />QGLWidget.__init__ (<i>self</i>, <a href="qglformat.html">QGLFormat</a>&#160;<i>format</i>, <a href="qwidget.html">QWidget</a>&#160;<i>parent</i>&#160;=&#160;None, <a href="qglwidget.html">QGLWidget</a>&#160;<i>shareWidget</i>&#160;=&#160;None, <a href="qt-windowflags.html">Qt.WindowFlags</a>&#160;<i>flags</i>&#160;=&#160;0)</h3><p>The <i>parent</i> argument, if not None, causes <i>self</i> to be owned by Qt instead of PyQt.</p><p>Constructs an OpenGL widget with parent <i>parent</i>.</p>
<p>The <i>format</i> argument specifies the desired <a href="qglformat.html">rendering options</a>. If the underlying
OpenGL/Window system cannot satisfy all the features requested in
<i>format</i>, the nearest subset of features will be used. After
creation, the <a href="qglwidget.html#format">format</a>() method
will return the actual format obtained.</p>
<p>The widget will be <a href="qglwidget.html#isValid">invalid</a>
if the system has no <a href="qglformat.html#hasOpenGL">OpenGL
support</a>.</p>
<p>The <i>parent</i> and widget flag, <i>f</i>, arguments are
passed to the <a href="qwidget.html">QWidget</a> constructor.</p>
<p>If <i>shareWidget</i> is a valid <a href="qglwidget.html">QGLWidget</a>, this widget will share OpenGL
display lists and texture objects with <i>shareWidget</i>. But if
<i>shareWidget</i> and this widget have different <a href="qglwidget.html#format">formats</a>, sharing might not be possible.
You can check whether sharing is in effect by calling <a href="qglwidget.html#isSharing">isSharing</a>().</p>
<p>The initialization of OpenGL rendering state, etc. should be
done by overriding the <a href="qglwidget.html#initializeGL">initializeGL</a>() function, rather
than in the constructor of your <a href="qglwidget.html">QGLWidget</a> subclass.</p>
<p><b>See also</b> <a href="qglformat.html#defaultFormat">QGLFormat.defaultFormat</a>() and
<a href="qglwidget.html#isValid">isValid</a>().</p>


<h3 class="fn"><a name="autoBufferSwap" />bool QGLWidget.autoBufferSwap (<i>self</i>)</h3><p>Returns true if the widget is doing automatic GL buffer
swapping; otherwise returns false.</p>
<p><b>See also</b> <a href="qglwidget.html#setAutoBufferSwap">setAutoBufferSwap</a>().</p>


<h3 class="fn"><a name="bindTexture" />int QGLWidget.bindTexture (<i>self</i>, <a href="qimage.html">QImage</a>&#160;<i>image</i>, int&#160;<i>target</i>&#160;=&#160;GL_TEXTURE_2D, int&#160;<i>format</i>&#160;=&#160;GL_RGBA)</h3><p>Calls QGLContext.:bindTexture(<i>image</i>, <i>target</i>,
<i>format</i>) on the currently set context.</p>
<p><b>See also</b> <a href="qglwidget.html#deleteTexture">deleteTexture</a>().</p>


<h3 class="fn"><a name="bindTexture-2" />int QGLWidget.bindTexture (<i>self</i>, <a href="qpixmap.html">QPixmap</a>&#160;<i>pixmap</i>, int&#160;<i>target</i>&#160;=&#160;GL_TEXTURE_2D, int&#160;<i>format</i>&#160;=&#160;GL_RGBA)</h3><p>Calls QGLContext.:bindTexture(<i>pixmap</i>, <i>target</i>,
<i>format</i>) on the currently set context.</p>
<p><b>See also</b> <a href="qglwidget.html#deleteTexture">deleteTexture</a>().</p>


<h3 class="fn"><a name="bindTexture-3" />int QGLWidget.bindTexture (<i>self</i>, QString&#160;<i>fileName</i>)</h3><p>This is an overloaded function.</p>
<p>The binding <i>options</i> are a set of options used to decide
how to bind the texture to the context.</p>
<p>This function was introduced in Qt 4.6.</p>


<h3 class="fn"><a name="bindTexture-4" />int QGLWidget.bindTexture (<i>self</i>, <a href="qimage.html">QImage</a>&#160;<i>image</i>, int&#160;<i>target</i>, int&#160;<i>format</i>, <a href="qglcontext-bindoptions.html">QGLContext.BindOptions</a>&#160;<i>options</i>)</h3><p>This is an overloaded function.</p>
<p>Generates and binds a 2D GL texture to the current context,
based on <i>pixmap</i>. The generated texture id is returned and
can be used in</p>
<p>The binding <i>options</i> are a set of options used to decide
how to bind the texture to the context.</p>
<p>This function was introduced in Qt 4.6.</p>


<h3 class="fn"><a name="bindTexture-5" />int QGLWidget.bindTexture (<i>self</i>, <a href="qpixmap.html">QPixmap</a>&#160;<i>pixmap</i>, int&#160;<i>target</i>, int&#160;<i>format</i>, <a href="qglcontext-bindoptions.html">QGLContext.BindOptions</a>&#160;<i>options</i>)</h3><p>This is an overloaded function.</p>
<p>Calls QGLContext.bindTexture(<i>fileName</i>) on the currently
set context.</p>
<p><b>See also</b> <a href="qglwidget.html#deleteTexture">deleteTexture</a>().</p>


<h3 class="fn"><a name="colormap" /><a href="qglcolormap.html">QGLColormap</a> QGLWidget.colormap (<i>self</i>)</h3><p>Returns the colormap for this widget.</p>
<p>Usually it is only top-level widgets that can have different
colormaps installed. Asking for the colormap of a child widget will
return the colormap for the child's top-level widget.</p>
<p>If no colormap has been set for this widget, the <a href="qglcolormap.html">QGLColormap</a> returned will be empty.</p>
<p><b>See also</b> <a href="qglwidget.html#setColormap">setColormap</a>() and <a href="qglcolormap.html#isEmpty">QGLColormap.isEmpty</a>().</p>


<h3 class="fn"><a name="context" /><a href="qglcontext.html">QGLContext</a> QGLWidget.context (<i>self</i>)</h3><p>Returns the context of this widget.</p>
<p>It is possible that the context is not valid (see <a href="qglwidget.html#isValid">isValid</a>()), for example, if the
underlying hardware does not support the format attributes that
were requested.</p>


<h3 class="fn"><a name="convertToGLFormat" /><a href="qimage.html">QImage</a> QGLWidget.convertToGLFormat (<a href="qimage.html">QImage</a>&#160;<i>img</i>)</h3><p>Converts the image <i>img</i> into the unnamed format expected
by OpenGL functions such as glTexImage2D(). The returned image is
not usable as a <a href="qimage.html">QImage</a>, but <a href="qimage.html#width">QImage.width</a>(), <a href="qimage.html#height">QImage.height</a>() and <a href="qimage.html#bits">QImage.bits</a>() may be used with OpenGL. The
GL format used is <tt>GL_RGBA</tt>.</p>


<h3 class="fn"><a name="deleteTexture" />QGLWidget.deleteTexture (<i>self</i>, int&#160;<i>tx_id</i>)</h3><p>Calls QGLContext.deleteTexture(<i>id</i>) on the currently set
context.</p>
<p><b>See also</b> <a href="qglwidget.html#bindTexture">bindTexture</a>().</p>


<h3 class="fn"><a name="doneCurrent" />QGLWidget.doneCurrent (<i>self</i>)</h3><p>Makes no GL context the current context. Normally, you do not
need to call this function; <a href="qglcontext.html">QGLContext</a> calls it as necessary. However, it
may be useful in multithreaded environments.</p>


<h3 class="fn"><a name="doubleBuffer" />bool QGLWidget.doubleBuffer (<i>self</i>)</h3><p>Returns true if the contained GL rendering context has double
buffering; otherwise returns false.</p>
<p><b>See also</b> <a href="qglformat.html#doubleBuffer">QGLFormat.doubleBuffer</a>().</p>


<h3 class="fn"><a name="drawTexture" />QGLWidget.drawTexture (<i>self</i>, <a href="qrectf.html">QRectF</a>&#160;<i>target</i>, int&#160;<i>textureId</i>, int&#160;<i>textureTarget</i>&#160;=&#160;GL_TEXTURE_2D)</h3><p>Calls the corresponding <a href="qglcontext.html#drawTexture">QGLContext.drawTexture</a>() with
<i>target</i>, <i>textureId</i>, and <i>textureTarget</i> for this
widget's context.</p>
<p>This function was introduced in Qt 4.4.</p>


<h3 class="fn"><a name="drawTexture-2" />QGLWidget.drawTexture (<i>self</i>, <a href="qpointf.html">QPointF</a>&#160;<i>point</i>, int&#160;<i>textureId</i>, int&#160;<i>textureTarget</i>&#160;=&#160;GL_TEXTURE_2D)</h3><p>Calls the corresponding <a href="qglcontext.html#drawTexture">QGLContext.drawTexture</a>() with
<i>point</i>, <i>textureId</i>, and <i>textureTarget</i> for this
widget's context.</p>
<p>This function was introduced in Qt 4.4.</p>


<h3 class="fn"><a name="event" />bool QGLWidget.event (<i>self</i>, <a href="qevent.html">QEvent</a>)</h3><p>Reimplemented from <a href="qobject.html#event">QObject.event</a>().</p>


<h3 class="fn"><a name="fontDisplayListBase" />int QGLWidget.fontDisplayListBase (<i>self</i>, <a href="qfont.html">QFont</a>&#160;<i>font</i>, int&#160;<i>listBase</i>&#160;=&#160;2000)</h3><h3 class="fn"><a name="format" /><a href="qglformat.html">QGLFormat</a> QGLWidget.format (<i>self</i>)</h3><p>Returns the format of the contained GL rendering context.</p>
<p><b>See also</b> <a class="obsolete" href="qglwidget-obsolete.html#setFormat">setFormat</a>().</p>


<h3 class="fn"><a name="glDraw" />QGLWidget.glDraw (<i>self</i>)</h3><p>Executes the virtual function <a href="qglwidget.html#paintGL">paintGL</a>().</p>
<p>The widget's rendering context will become the current context
and <a href="qglwidget.html#initializeGL">initializeGL</a>() will
be called if it hasn't already been called.</p>


<h3 class="fn"><a name="glInit" />QGLWidget.glInit (<i>self</i>)</h3><p>Initializes OpenGL for this widget's context. Calls the virtual
function <a href="qglwidget.html#initializeGL">initializeGL</a>().</p>


<h3 class="fn"><a name="grabFrameBuffer" /><a href="qimage.html">QImage</a> QGLWidget.grabFrameBuffer (<i>self</i>, bool&#160;<i>withAlpha</i>&#160;=&#160;False)</h3><p>Returns an image of the frame buffer. If <i>withAlpha</i> is
true the alpha channel is included.</p>
<p>Depending on your hardware, you can explicitly select which
color buffer to grab with a glReadBuffer() call before calling this
function.</p>


<h3 class="fn"><a name="initializeGL" />QGLWidget.initializeGL (<i>self</i>)</h3><p>This virtual function is called once before the first call to
<a href="qglwidget.html#paintGL">paintGL</a>() or <a href="qglwidget.html#resizeGL">resizeGL</a>(), and then once whenever
the widget has been assigned a new <a href="qglcontext.html">QGLContext</a>. Reimplement it in a subclass.</p>
<p>This function should set up any required OpenGL context
rendering flags, defining display lists, etc.</p>
<p>There is no need to call <a href="qglwidget.html#makeCurrent">makeCurrent</a>() because this has
already been done when this function is called.</p>


<h3 class="fn"><a name="initializeOverlayGL" />QGLWidget.initializeOverlayGL (<i>self</i>)</h3><p>This virtual function is used in the same manner as <a href="qglwidget.html#initializeGL">initializeGL</a>() except that it
operates on the widget's overlay context instead of the widget's
main context. This means that initializeOverlayGL() is called once
before the first call to <a href="qglwidget.html#paintOverlayGL">paintOverlayGL</a>() or <a href="qglwidget.html#resizeOverlayGL">resizeOverlayGL</a>(). Reimplement
it in a subclass.</p>
<p>This function should set up any required OpenGL context
rendering flags, defining display lists, etc. for the overlay
context.</p>
<p>There is no need to call <a href="qglwidget.html#makeOverlayCurrent">makeOverlayCurrent</a>()
because this has already been done when this function is
called.</p>


<h3 class="fn"><a name="isSharing" />bool QGLWidget.isSharing (<i>self</i>)</h3><p>Returns true if this widget's GL context is shared with another
GL context, otherwise false is returned. Context sharing might not
be possible if the widgets use different formats.</p>
<p><b>See also</b> <a href="qglwidget.html#format">format</a>().</p>


<h3 class="fn"><a name="isValid" />bool QGLWidget.isValid (<i>self</i>)</h3><p>Returns true if the widget has a valid GL rendering context;
otherwise returns false. A widget will be invalid if the system has
no <a href="qglformat.html#hasOpenGL">OpenGL support</a>.</p>


<h3 class="fn"><a name="makeCurrent" />QGLWidget.makeCurrent (<i>self</i>)</h3><p>Makes this widget the current widget for OpenGL operations, i.e.
makes the widget's rendering context the current OpenGL rendering
context.</p>


<h3 class="fn"><a name="makeOverlayCurrent" />QGLWidget.makeOverlayCurrent (<i>self</i>)</h3><p>Makes the overlay context of this widget current. Use this if
you need to issue OpenGL commands to the overlay context outside of
<a href="qglwidget.html#initializeOverlayGL">initializeOverlayGL</a>(),
<a href="qglwidget.html#resizeOverlayGL">resizeOverlayGL</a>(), and
<a href="qglwidget.html#paintOverlayGL">paintOverlayGL</a>().</p>
<p>Does nothing if this widget has no overlay.</p>
<p><b>See also</b> <a href="qglwidget.html#makeCurrent">makeCurrent</a>().</p>


<h3 class="fn"><a name="overlayContext" /><a href="qglcontext.html">QGLContext</a> QGLWidget.overlayContext (<i>self</i>)</h3><p>Returns the overlay context of this widget, or 0 if this widget
has no overlay.</p>
<p><b>See also</b> <a href="qglwidget.html#context">context</a>().</p>


<h3 class="fn"><a name="paintEngine" /><a href="qpaintengine.html">QPaintEngine</a> QGLWidget.paintEngine (<i>self</i>)</h3><h3 class="fn"><a name="paintEvent" />QGLWidget.paintEvent (<i>self</i>, <a href="qpaintevent.html">QPaintEvent</a>)</h3><p>Reimplemented from <a href="qwidget.html#paintEvent">QWidget.paintEvent</a>().</p>
<p>Handles paint events passed in the <i>event</i> parameter. Will
cause the virtual <a href="qglwidget.html#paintGL">paintGL</a>()
function to be called.</p>
<p>The widget's rendering context will become the current context
and <a href="qglwidget.html#initializeGL">initializeGL</a>() will
be called if it hasn't already been called.</p>


<h3 class="fn"><a name="paintGL" />QGLWidget.paintGL (<i>self</i>)</h3><p>This virtual function is called whenever the widget needs to be
painted. Reimplement it in a subclass.</p>
<p>There is no need to call <a href="qglwidget.html#makeCurrent">makeCurrent</a>() because this has
already been done when this function is called.</p>


<h3 class="fn"><a name="paintOverlayGL" />QGLWidget.paintOverlayGL (<i>self</i>)</h3><p>This virtual function is used in the same manner as <a href="qglwidget.html#paintGL">paintGL</a>() except that it operates on
the widget's overlay context instead of the widget's main context.
This means that paintOverlayGL() is called whenever the widget's
overlay needs to be painted. Reimplement it in a subclass.</p>
<p>There is no need to call <a href="qglwidget.html#makeOverlayCurrent">makeOverlayCurrent</a>()
because this has already been done when this function is
called.</p>


<h3 class="fn"><a name="qglClearColor" />QGLWidget.qglClearColor (<i>self</i>, <a href="qcolor.html">QColor</a>&#160;<i>c</i>)</h3><p>Convenience function for specifying the clearing color to
OpenGL. Calls glClearColor (in RGBA mode) or glClearIndex (in
color-index mode) with the color <i>c</i>. Applies to this widgets
GL context.</p>
<p><b>See also</b> <a href="qglwidget.html#qglColor">qglColor</a>(), <a href="qglcontext.html#currentContext">QGLContext.currentContext</a>(),
and <a href="qcolor.html">QColor</a>.</p>


<h3 class="fn"><a name="qglColor" />QGLWidget.qglColor (<i>self</i>, <a href="qcolor.html">QColor</a>&#160;<i>c</i>)</h3><p>Convenience function for specifying a drawing color to OpenGL.
Calls glColor4 (in RGBA mode) or glIndex (in color-index mode) with
the color <i>c</i>. Applies to this widgets GL context.</p>
<p><b>Note:</b> This function is not supported on OpenGL/ES 2.0
systems.</p>
<p><b>See also</b> <a href="qglwidget.html#qglClearColor">qglClearColor</a>(), <a href="qglcontext.html#currentContext">QGLContext.currentContext</a>(),
and <a href="qcolor.html">QColor</a>.</p>


<h3 class="fn"><a name="renderPixmap" /><a href="qpixmap.html">QPixmap</a> QGLWidget.renderPixmap (<i>self</i>, int&#160;<i>width</i>&#160;=&#160;0, int&#160;<i>height</i>&#160;=&#160;0, bool&#160;<i>useContext</i>&#160;=&#160;False)</h3><p>Renders the current scene on a pixmap and returns the
pixmap.</p>
<p>You can use this method on both visible and invisible <a href="qglwidget.html">QGLWidget</a> objects.</p>
<p>This method will create a pixmap and a temporary <a href="qglcontext.html">QGLContext</a> to render on the pixmap. It will
then call <a href="qglwidget.html#initializeGL">initializeGL</a>(),
<a href="qglwidget.html#resizeGL">resizeGL</a>(), and <a href="qglwidget.html#paintGL">paintGL</a>() on this context. Finally,
the widget's original GL context is restored.</p>
<p>The size of the pixmap will be <i>w</i> pixels wide and <i>h</i>
pixels high unless one of these parameters is 0 (the default), in
which case the pixmap will have the same size as the widget.</p>
<p>If <i>useContext</i> is true, this method will try to be more
efficient by using the existing GL context to render the pixmap.
The default is false. Only use true if you understand the risks.
Note that under Windows a temporary context has to be created and
usage of the <i>useContext</i> parameter is not supported.</p>
<p>Overlays are not rendered onto the pixmap.</p>
<p>If the GL rendering context and the desktop have different bit
depths, the result will most likely look surprising.</p>
<p>Note that the creation of display lists, modifications of the
view frustum etc. should be done from within <a href="qglwidget.html#initializeGL">initializeGL</a>(). If this is not
done, the temporary <a href="qglcontext.html">QGLContext</a> will
not be initialized properly, and the rendered pixmap may be
incomplete/corrupted.</p>


<h3 class="fn"><a name="renderText" />QGLWidget.renderText (<i>self</i>, int&#160;<i>x</i>, int&#160;<i>y</i>, QString&#160;<i>str</i>, <a href="qfont.html">QFont</a>&#160;<i>font</i>&#160;=&#160;QFont(), int&#160;<i>listBase</i>&#160;=&#160;2000)</h3><p>Renders the string <i>str</i> into the GL context of this
widget.</p>
<p><i>x</i> and <i>y</i> are specified in window coordinates, with
the origin in the upper left-hand corner of the window. If
<i>font</i> is not specified, the currently set application font
will be used to render the string. To change the color of the
rendered text you can use the glColor() call (or the <a href="qglwidget.html#qglColor">qglColor</a>() convenience function),
just before the renderText() call.</p>
<p>The <i>listBase</i> parameter is obsolete and will be removed in
a future version of Qt.</p>
<p><b>Note:</b> This function clears the stencil buffer.</p>
<p><b>Note:</b> This function is not supported on OpenGL/ES
systems.</p>
<p><b>Note:</b> This function temporarily disables depth-testing
when the text is drawn.</p>
<p><b>Note:</b> This function can only be used inside a <a href="qpainter.html#beginNativePainting">QPainter.beginNativePainting</a>()/<a href="qpainter.html#endNativePainting">QPainter.endNativePainting</a>()
block if the default OpenGL paint engine is <a href="qpaintengine.html#Type-enum">QPaintEngine.OpenGL</a>. To make
<a href="qpaintengine.html#Type-enum">QPaintEngine.OpenGL</a> the
default GL engine, call QGL.setPreferredPaintEngine(<a href="qpaintengine.html#Type-enum">QPaintEngine.OpenGL</a>) before the
<a href="qapplication.html">QApplication</a> constructor.</p>
<p><a href="opengl-overpainting.html">Overpaint</a> with <a href="qpainter.html#drawText">QPainter.drawText</a>() instead.</p>


<h3 class="fn"><a name="renderText-2" />QGLWidget.renderText (<i>self</i>, float&#160;<i>x</i>, float&#160;<i>y</i>, float&#160;<i>z</i>, QString&#160;<i>str</i>, <a href="qfont.html">QFont</a>&#160;<i>font</i>&#160;=&#160;QFont(), int&#160;<i>listBase</i>&#160;=&#160;2000)</h3><p>This is an overloaded function.</p>
<p><i>x</i>, <i>y</i> and <i>z</i> are specified in scene or object
coordinates relative to the currently set projection and model
matrices. This can be useful if you want to annotate models with
text labels and have the labels move with the model as it is
rotated etc.</p>
<p><b>Note:</b> This function is not supported on OpenGL/ES
systems.</p>
<p><b>Note:</b> If depth testing is enabled before this function is
called, then the drawn text will be depth-tested against the models
that have already been drawn in the scene. Use
<tt>glDisable(GL_DEPTH_TEST)</tt> before calling this function to
annotate the models without depth-testing the text.</p>
<p><a href="opengl-overpainting.html">Overpaint</a> with <a href="qpainter.html#drawText">QPainter.drawText</a>() instead.</p>


<h3 class="fn"><a name="resizeEvent" />QGLWidget.resizeEvent (<i>self</i>, <a href="qresizeevent.html">QResizeEvent</a>)</h3><p>Reimplemented from <a href="qwidget.html#resizeEvent">QWidget.resizeEvent</a>().</p>
<p>Handles resize events that are passed in the <i>event</i>
parameter. Calls the virtual function <a href="qglwidget.html#resizeGL">resizeGL</a>().</p>


<h3 class="fn"><a name="resizeGL" />QGLWidget.resizeGL (<i>self</i>, int&#160;<i>w</i>, int&#160;<i>h</i>)</h3><p>This virtual function is called whenever the widget has been
resized. The new size is passed in <i>width</i> and <i>height</i>.
Reimplement it in a subclass.</p>
<p>There is no need to call <a href="qglwidget.html#makeCurrent">makeCurrent</a>() because this has
already been done when this function is called.</p>


<h3 class="fn"><a name="resizeOverlayGL" />QGLWidget.resizeOverlayGL (<i>self</i>, int&#160;<i>w</i>, int&#160;<i>h</i>)</h3><p>This virtual function is used in the same manner as <a href="qglwidget.html#paintGL">paintGL</a>() except that it operates on
the widget's overlay context instead of the widget's main context.
This means that resizeOverlayGL() is called whenever the widget has
been resized. The new size is passed in <i>width</i> and
<i>height</i>. Reimplement it in a subclass.</p>
<p>There is no need to call <a href="qglwidget.html#makeOverlayCurrent">makeOverlayCurrent</a>()
because this has already been done when this function is
called.</p>


<h3 class="fn"><a name="setAutoBufferSwap" />QGLWidget.setAutoBufferSwap (<i>self</i>, bool&#160;<i>on</i>)</h3><p>If <i>on</i> is true automatic GL buffer swapping is switched
on; otherwise it is switched off.</p>
<p>If <i>on</i> is true and the widget is using a double-buffered
format, the background and foreground GL buffers will automatically
be swapped after each <a href="qglwidget.html#paintGL">paintGL</a>() call.</p>
<p>The buffer auto-swapping is on by default.</p>
<p><b>See also</b> <a href="qglwidget.html#autoBufferSwap">autoBufferSwap</a>(), <a href="qglwidget.html#doubleBuffer">doubleBuffer</a>(), and <a href="qglwidget.html#swapBuffers">swapBuffers</a>().</p>


<h3 class="fn"><a name="setColormap" />QGLWidget.setColormap (<i>self</i>, <a href="qglcolormap.html">QGLColormap</a>&#160;<i>map</i>)</h3><p>Set the colormap for this widget to <i>cmap</i>. Usually it is
only top-level widgets that can have colormaps installed.</p>
<p><b>See also</b> <a href="qglwidget.html#colormap">colormap</a>().</p>


<h3 class="fn"><a name="setContext" />QGLWidget.setContext (<i>self</i>, <a href="qglcontext.html">QGLContext</a>&#160;<i>context</i>, <a href="qglcontext.html">QGLContext</a>&#160;<i>shareContext</i>&#160;=&#160;None, bool&#160;<i>deleteOldContext</i>&#160;=&#160;True)</h3><p>The <i>context</i> argument has it's ownership transferred to Qt.</p><h3 class="fn"><a name="setFormat" />QGLWidget.setFormat (<i>self</i>, <a href="qglformat.html">QGLFormat</a>&#160;<i>format</i>)</h3><h3 class="fn"><a name="setMouseTracking" />QGLWidget.setMouseTracking (<i>self</i>, bool&#160;<i>enable</i>)</h3><p>If <i>enable</i> is true then mouse tracking is enabled;
otherwise it is disabled.</p>


<h3 class="fn"><a name="swapBuffers" />QGLWidget.swapBuffers (<i>self</i>)</h3><p>Swaps the screen contents with an off-screen buffer. This only
works if the widget's format specifies double buffer mode.</p>
<p>Normally, there is no need to explicitly call this function
because it is done automatically after each widget repaint, i.e.
each time after <a href="qglwidget.html#paintGL">paintGL</a>() has
been executed.</p>
<p><b>See also</b> <a href="qglwidget.html#doubleBuffer">doubleBuffer</a>(), <a href="qglwidget.html#setAutoBufferSwap">setAutoBufferSwap</a>(), and
<a href="qglformat.html#setDoubleBuffer">QGLFormat.setDoubleBuffer</a>().</p>


<h3 class="fn"><a name="updateGL" />QGLWidget.updateGL (<i>self</i>)</h3><p>This method is also a Qt slot with the C++ signature <tt>void updateGL()</tt>.</p><p>Updates the widget by calling <a href="qglwidget.html#glDraw">glDraw</a>().</p>


<h3 class="fn"><a name="updateOverlayGL" />QGLWidget.updateOverlayGL (<i>self</i>)</h3><p>This method is also a Qt slot with the C++ signature <tt>void updateOverlayGL()</tt>.</p><p>Updates the widget's overlay (if any). Will cause the virtual
function <a href="qglwidget.html#paintOverlayGL">paintOverlayGL</a>() to be
executed.</p>
<p>The widget's rendering context will become the current context
and <a href="qglwidget.html#initializeGL">initializeGL</a>() will
be called if it hasn't already been called.</p>
<address><hr /><div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address"><td align="left" width="25%">PyQt&#160;4.10 for Windows</td><td align="center" width="50%">Copyright &#169; <a href="http://www.riverbankcomputing.com">Riverbank&#160;Computing&#160;Ltd</a> and <a href="http://www.qtsoftware.com">Nokia</a> 2012</td><td align="right" width="25%">Qt&#160;4.8.4</td></tr></table></div></address></body></html>