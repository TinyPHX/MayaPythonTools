<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html><head><title>QXmlQuery Class Reference</title><style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style></head><body><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr /><td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" width="32" /></td><td width="1">&#160;&#160;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&#160;&#183; <a href="classes.html"><font color="#004faf">All Classes</font></a>&#160;&#183; <a href="modules.html"><font color="#004faf">Modules</font></a></td></table><h1 align="center">QXmlQuery Class Reference<br /><sup><sup>[<a href="qtxmlpatterns.html">QtXmlPatterns</a> module]</sup></sup></h1><p>The QXmlQuery class performs XQueries on XML data, or on non-XML
data modeled to look like XML. <a href="#details">More...</a></p>

<h3>Types</h3><ul><li><div class="fn" />enum <b><a href="qxmlquery.html#QueryLanguage-enum">QueryLanguage</a></b> { XQuery10, XSLT20 }</li></ul><h3>Methods</h3><ul><li><div class="fn" /><b><a href="qxmlquery.html#QXmlQuery">__init__</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qxmlquery.html#QXmlQuery-2">__init__</a></b> (<i>self</i>, QXmlQuery&#160;<i>other</i>)</li><li><div class="fn" /><b><a href="qxmlquery.html#QXmlQuery-3">__init__</a></b> (<i>self</i>, QXmlNamePool&#160;<i>np</i>)</li><li><div class="fn" /><b><a href="qxmlquery.html#QXmlQuery-4">__init__</a></b> (<i>self</i>, QueryLanguage&#160;<i>queryLanguage</i>, QXmlNamePool&#160;<i>pool</i>&#160;=&#160;QXmlNamePool())</li><li><div class="fn" /><b><a href="qxmlquery.html#bindVariable">bindVariable</a></b> (<i>self</i>, QXmlName&#160;<i>name</i>, QXmlItem&#160;<i>value</i>)</li><li><div class="fn" /><b><a href="qxmlquery.html#bindVariable-2">bindVariable</a></b> (<i>self</i>, QXmlName&#160;<i>name</i>, QIODevice)</li><li><div class="fn" /><b><a href="qxmlquery.html#bindVariable-3">bindVariable</a></b> (<i>self</i>, QXmlName&#160;<i>name</i>, QXmlQuery&#160;<i>query</i>)</li><li><div class="fn" /><b><a href="qxmlquery.html#bindVariable-4">bindVariable</a></b> (<i>self</i>, QString&#160;<i>localName</i>, QXmlItem&#160;<i>value</i>)</li><li><div class="fn" /><b><a href="qxmlquery.html#bindVariable-5">bindVariable</a></b> (<i>self</i>, QString&#160;<i>localName</i>, QIODevice)</li><li><div class="fn" /><b><a href="qxmlquery.html#bindVariable-6">bindVariable</a></b> (<i>self</i>, QString&#160;<i>localName</i>, QXmlQuery&#160;<i>query</i>)</li><li><div class="fn" /><b><a href="qxmlquery.html#evaluateTo">evaluateTo</a></b> (<i>self</i>, QXmlResultItems&#160;<i>result</i>)</li><li><div class="fn" />bool <b><a href="qxmlquery.html#evaluateTo-2">evaluateTo</a></b> (<i>self</i>, QAbstractXmlReceiver&#160;<i>callback</i>)</li><li><div class="fn" />bool <b><a href="qxmlquery.html#evaluateTo-3">evaluateTo</a></b> (<i>self</i>, QStringList&#160;<i>target</i>)</li><li><div class="fn" />bool <b><a href="qxmlquery.html#evaluateTo-4">evaluateTo</a></b> (<i>self</i>, QIODevice&#160;<i>target</i>)</li><li><div class="fn" />bool <b><a href="qxmlquery.html#evaluateTo-5">evaluateTo</a></b> (<i>self</i>, QString&#160;<i>output</i>)</li><li><div class="fn" />QString <b><a href="qxmlquery.html#evaluateToString">evaluateToString</a></b> (<i>self</i>)</li><li><div class="fn" />QStringList <b><a href="qxmlquery.html#evaluateToStringList">evaluateToStringList</a></b> (<i>self</i>)</li><li><div class="fn" />QXmlName <b><a href="qxmlquery.html#initialTemplateName">initialTemplateName</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qxmlquery.html#isValid">isValid</a></b> (<i>self</i>)</li><li><div class="fn" />QAbstractMessageHandler <b><a href="qxmlquery.html#messageHandler">messageHandler</a></b> (<i>self</i>)</li><li><div class="fn" />QXmlNamePool <b><a href="qxmlquery.html#namePool">namePool</a></b> (<i>self</i>)</li><li><div class="fn" />QNetworkAccessManager <b><a href="qxmlquery.html#networkAccessManager">networkAccessManager</a></b> (<i>self</i>)</li><li><div class="fn" />QueryLanguage <b><a href="qxmlquery.html#queryLanguage">queryLanguage</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qxmlquery.html#setFocus">setFocus</a></b> (<i>self</i>, QXmlItem&#160;<i>item</i>)</li><li><div class="fn" />bool <b><a href="qxmlquery.html#setFocus-2">setFocus</a></b> (<i>self</i>, QUrl&#160;<i>documentURI</i>)</li><li><div class="fn" />bool <b><a href="qxmlquery.html#setFocus-3">setFocus</a></b> (<i>self</i>, QIODevice&#160;<i>document</i>)</li><li><div class="fn" />bool <b><a href="qxmlquery.html#setFocus-4">setFocus</a></b> (<i>self</i>, QString&#160;<i>focus</i>)</li><li><div class="fn" /><b><a href="qxmlquery.html#setInitialTemplateName">setInitialTemplateName</a></b> (<i>self</i>, QXmlName&#160;<i>name</i>)</li><li><div class="fn" /><b><a href="qxmlquery.html#setInitialTemplateName-2">setInitialTemplateName</a></b> (<i>self</i>, QString&#160;<i>name</i>)</li><li><div class="fn" /><b><a href="qxmlquery.html#setMessageHandler">setMessageHandler</a></b> (<i>self</i>, QAbstractMessageHandler&#160;<i>messageHandler</i>)</li><li><div class="fn" /><b><a href="qxmlquery.html#setNetworkAccessManager">setNetworkAccessManager</a></b> (<i>self</i>, QNetworkAccessManager&#160;<i>newManager</i>)</li><li><div class="fn" /><b><a href="qxmlquery.html#setQuery">setQuery</a></b> (<i>self</i>, QString&#160;<i>sourceCode</i>, QUrl&#160;<i>documentUri</i>&#160;=&#160;QUrl())</li><li><div class="fn" /><b><a href="qxmlquery.html#setQuery-2">setQuery</a></b> (<i>self</i>, QIODevice&#160;<i>sourceCode</i>, QUrl&#160;<i>documentUri</i>&#160;=&#160;QUrl())</li><li><div class="fn" /><b><a href="qxmlquery.html#setQuery-3">setQuery</a></b> (<i>self</i>, QUrl&#160;<i>queryURI</i>, QUrl&#160;<i>baseUri</i>&#160;=&#160;QUrl())</li><li><div class="fn" /><b><a href="qxmlquery.html#setUriResolver">setUriResolver</a></b> (<i>self</i>, QAbstractUriResolver&#160;<i>resolver</i>)</li><li><div class="fn" />QAbstractUriResolver <b><a href="qxmlquery.html#uriResolver">uriResolver</a></b> (<i>self</i>)</li></ul><a name="details" /><hr /><h2>Detailed Description</h2><p>The QXmlQuery class performs XQueries on XML data, or on non-XML
data modeled to look like XML.</p>
<p>The QXmlQuery class compiles and executes queries written in the
<a href="http://www.w3.org/TR/xquery/">XQuery language</a>.
QXmlQuery is typically used to query XML data, but it can also
query non-XML data that has been modeled to look like XML.</p>
<p>Using QXmlQuery to query XML data, as in the snippet below, is
simple because it can use the built-in <a href="qabstractxmlnodemodel.html">XML data model</a> as its delegate to
the underlying query engine for traversing the data. The built-in
data model is specified in <a href="http://www.w3.org/TR/xpath-datamodel/">XQuery 1.0 and XPath 2.0
Data Model</a>.</p>
<pre class="cpp">
 <span class="type">QXmlQuery</span> query;
 query<span class="operator">.</span><a href="qxmlquery.html#setQuery">setQuery</a>(<span class="string">"doc('index.html')/html/body/p[1]"</span>);

 <span class="type"><a href="qxmlserializer.html">QXmlSerializer</a></span> serializer(query<span class="operator">,</span> myOutputDevice);
 query<span class="operator">.</span><a href="qxmlquery.html#evaluateTo">evaluateTo</a>(<span class="operator">&amp;</span>serializer);
</pre>
<p>The example uses QXmlQuery to match the first paragraph of an
XML document and then <a href="qxmlserializer.html">output the
result</a> to a device as XML.</p>
<p>Using QXmlQuery to query <i>non-XML</i> data requires writing a
subclass of <a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a> to use as a
replacement for the built-in XML data model. The custom data model
will be able to traverse the non-XML data as required by the
<a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a>
interface. An instance of this custom data model then becomes the
delegate used by the query engine to traverse the non-XML data. For
an example of how to use QXmlQuery to query non-XML data, see the
documentation for <a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a>.</p>
<a id="running-xqueries" name="running-xqueries" />
<h3>Running XQueries</h3>
<p>To run a query set up with QXmlQuery, call one of the evaluation
functions.</p>
<ul>
<li>evaluateTo(<a href="qabstractxmlreceiver.html">QAbstractXmlReceiver</a> *) is called
with a pointer to an XML <a href="qabstractxmlreceiver.html">receiver</a>, which receives the query
results as a sequence of callbacks. The receiver callback class is
like the callback class used for translating the output of a SAX
parser. <a href="qxmlserializer.html">QXmlSerializer</a>, for
example, is a receiver callback class for translating the sequence
of callbacks for output as unformatted XML text.</li>
</ul>
<ul>
<li>evaluateTo(<a href="qxmlresultitems.html">QXmlResultItems</a>
*) is called with a pointer to an iterator for an empty sequence of
query <a href="qxmlresultitems.html">result items</a>. The
Java-like iterator allows the query results to be accessed
sequentially.</li>
</ul>
<ul>
<li>evaluateTo(<a href="qstringlist.html">QStringList</a> *) is
like evaluateTo(<a href="qxmlresultitems.html">QXmlResultItems</a>
*), but the query must evaluate to a sequence of strings.</li>
</ul>
<a id="running-xpath-expressions" name="running-xpath-expressions" />
<h3>Running XPath Expressions</h3>
<p>The XPath language is a subset of the <a href="xmlprocessing.html">XQuery</a> language, so running an XPath
expression is the same as running an <a href="xmlprocessing.html">XQuery</a> query. Pass the XPath expression to
QXmlQuery using <a href="qxmlquery.html#setQuery">setQuery</a>().</p>
<a id="running-xslt-stylesheets" name="running-xslt-stylesheets" />
<h3>Running XSLT stylesheets</h3>
<p>Running an XSLT stylesheet is like running an <a href="xmlprocessing.html">XQuery</a>, except that when you construct
your QXmlQuery, you must pass <a href="qxmlquery.html#QueryLanguage-enum">QXmlQuery.XSLT20</a> to tell
QXmlQuery to interpret whatever it gets from <a href="qxmlquery.html#setQuery">setQuery</a>() as an XSLT stylesheet
instead of as an <a href="xmlprocessing.html">XQuery</a>. You must
also set the input document by calling <a href="qxmlquery.html#setFocus">setFocus</a>().</p>
<pre class="cpp">
     <span class="type">QXmlQuery</span> query(<span class="type">QXmlQuery</span><span class="operator">.</span>XSLT20);
     query<span class="operator">.</span>setFocus(<span class="type"><a href="qurl.html">QUrl</a></span>(<span class="string">"myInput.xml"</span>));
     query<span class="operator">.</span>setQuery(<span class="type"><a href="qurl.html">QUrl</a></span>(<span class="string">"myStylesheet.xsl"</span>));
     query<span class="operator">.</span>evaluateTo(out);
</pre>
<p><b>Note:</b> Currently, <a href="qxmlquery.html#setFocus">setFocus</a>() must be called
<i>before</i> <a href="qxmlquery.html#setQuery">setQuery</a>() when
using XSLT.</p>
<p>Another way to run an XSLT stylesheet is to use the
<tt>xmlpatterns</tt> command line utility.</p>
<pre class="cpp">
 xmlpatterns myStylesheet<span class="operator">.</span>xsl myInput<span class="operator">.</span>xml
</pre>
<p><b>Note:</b> For the current release, XSLT support should be
considered experimental. See section <a href="xmlprocessing.html#xslt-2-0">XSLT conformance</a> for details.</p>
<p>Stylesheet parameters are bound using <a href="qxmlquery.html#bindVariable">bindVariable</a>().</p>
<a id="binding-a-query-to-a-starting-node" name="binding-a-query-to-a-starting-node" />
<h3>Binding A Query To A Starting Node</h3>
<p>When a query is run on XML data, as in the snippet above, the
<tt>doc()</tt> function returns the node in the built-in data model
where the query evaluation will begin. But when a query is run on a
custom node model containing non-XML data, one of the <a href="qxmlquery.html#bindVariable">bindVariable</a>() functions must be
called to bind a variable name to a starting node in the custom
model. A $variable reference is used in the <a href="xmlprocessing.html">XQuery</a> text to access the starting node in
the custom model. It is not necessary to declare the variable name
external in the query. See the example in the documentation for
<a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a>.</p>
<a id="reentrancy-and-thread-safety" name="reentrancy-and-thread-safety" />
<h3>Reentrancy and Thread-Safety</h3>
<p>QXmlQuery is reentrant but not thread-safe. It is safe to use
the QxmlQuery copy constructor to create a copy of a query and run
the same query multiple times. Behind the scenes, QXmlQuery will
reuse resources such as opened files and compiled queries to the
extent possible. But it is not safe to use the same instance of
QXmlQuery in multiple threads.</p>
<a id="error-handling" name="error-handling" />
<h3>Error Handling</h3>
<p>Errors can occur during query evaluation. Examples include type
errors and file loading errors. When an error occurs:</p>
<ul>
<li>The error message is sent to the <a href="qxmlquery.html#messageHandler">messageHandler</a>().</li>
<li><a href="qxmlresultitems.html#hasError">QXmlResultItems.hasError</a>()
will return <tt>true</tt>, or <a href="qxmlquery.html#evaluateTo">evaluateTo</a>() will return
<tt>false</tt>;</li>
<li>The results of the evaluation are undefined.</li>
</ul>
<a id="resource-management" name="resource-management" />
<h3>Resource Management</h3>
<p>When a query runs, it parses documents, allocating internal data
structures to hold them, and it may load other resources over the
network. It reuses these allocated resources when possible, to
avoid having to reload and reparse them.</p>
<p>When <a href="qxmlquery.html#setQuery">setQuery</a>() is called,
the query text is compiled into an internal data structure and
optimized. The optimized form can then be reused for multiple
evaluations of the query. Since the compile-and-optimize process
can be expensive, repeating it for the same query should be avoided
by using a separate instance of QXmlQuery for each query text.</p>
<p>Once a document has been parsed, its internal representation is
maintained in the QXmlQuery instance and shared among multiple
QXmlQuery instances.</p>
<p>An instance of <a href="qcoreapplication.html">QCoreApplication</a> must exist before
QXmlQuery can be used.</p>
<a id="event-handling" name="event-handling" />
<h3>Event Handling</h3>
<p>When QXmlQuery accesses resources (e.g., calling
<tt>fn:doc()</tt> to load a file, or accessing a device via a bound
variable), the event loop is used, which means events will be
processed. To avoid processing events when QXmlQuery accesses
resources, create your QXmlQuery instance in a separate thread.</p>
<hr /><h2>Type Documentation</h2><h3 class="fn"><a name="QueryLanguage-enum" />QXmlQuery.QueryLanguage</h3><p>Specifies whether you want <a href="qxmlquery.html">QXmlQuery</a> to interpret the input to <a href="qxmlquery.html#setQuery">setQuery</a>() as an <a href="xmlprocessing.html">XQuery</a> or as an XSLT stylesheet.</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QXmlQuery.XQuery10</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign"><a href="xmlprocessing.html">XQuery</a>
1.0.</td>
</tr>
<tr>
<td class="topAlign"><tt>QXmlQuery.XSLT20</tt></td>
<td class="topAlign"><tt>2</tt></td>
<td class="topAlign">XSLT 2.0 The selector, the restricted XPath
pattern found in W3C XML Schema 1.1 for uniqueness contraints.
Apart from restricting the syntax, the type check stage for the
expression assumes a sequence of nodes to be the focus. The field,
the restricted XPath pattern found in W3C XML Schema 1.1 for
uniqueness contraints. Apart from restricting the syntax, the type
check stage for the expression assumes a sequence of nodes to be
the focus. Signifies XPath 2.0. Has no effect in the public API,
it's used internally. As With XmlSchema11IdentityConstraintSelector
and XmlSchema11IdentityConstraintField, the type check stage for
the expression assumes a sequence of nodes to be the focus.</td>
</tr>
</table>
<p>This enum was introduced or modified in Qt 4.5.</p>
<p><b>See also</b> <a href="qxmlquery.html#setQuery">setQuery</a>().</p>
<hr /><h2>Method Documentation</h2><h3 class="fn"><a name="QXmlQuery" />QXmlQuery.__init__ (<i>self</i>)</h3><p>Constructs an invalid, empty query that cannot be used until
<a href="qxmlquery.html#setQuery">setQuery</a>() is called.</p>
<p><b>Note:</b> This constructor must not be used if you intend to
use this <a href="qxmlquery.html">QXmlQuery</a> to process XSL-T
stylesheets. The other constructor must be used in that case.</p>


<h3 class="fn"><a name="QXmlQuery-2" />QXmlQuery.__init__ (<i>self</i>, <a href="qxmlquery.html">QXmlQuery</a>&#160;<i>other</i>)</h3><p>Constructs a <a href="qxmlquery.html">QXmlQuery</a> that is a
copy of <i>other</i>. The new instance will share resources with
the existing query to the extent possible.</p>


<h3 class="fn"><a name="QXmlQuery-3" />QXmlQuery.__init__ (<i>self</i>, <a href="qxmlnamepool.html">QXmlNamePool</a>&#160;<i>np</i>)</h3><p>Constructs a query that will use <i>np</i> as its name pool. The
query cannot be evaluated until <a href="qxmlquery.html#setQuery">setQuery</a>() has been called.</p>


<h3 class="fn"><a name="QXmlQuery-4" />QXmlQuery.__init__ (<i>self</i>, <a href="qxmlquery.html#QueryLanguage-enum">QueryLanguage</a>&#160;<i>queryLanguage</i>, <a href="qxmlnamepool.html">QXmlNamePool</a>&#160;<i>pool</i>&#160;=&#160;QXmlNamePool())</h3><p>Constructs a query that will be used to run Xqueries or XSL-T
stylesheets, depending on the value of <i>queryLanguage</i>. It
will use <i>np</i> as its name pool.</p>
<p><b>Note:</b> If your <a href="qxmlquery.html">QXmlQuery</a> will
process XSL-T stylesheets, this constructor must be used. The
default constructor can only create instances of <a href="qxmlquery.html">QXmlQuery</a> for running XQueries.</p>
<p><b>Note:</b> The XSL-T support in this release is considered
experimental. See the <a href="xmlprocessing.html#xslt-2-0">XSLT
conformance</a> for details.</p>
<p>This function was introduced in Qt 4.5.</p>
<p><b>See also</b> <a href="qxmlquery.html#queryLanguage">queryLanguage</a>().</p>


<h3 class="fn"><a name="bindVariable" />QXmlQuery.bindVariable (<i>self</i>, <a href="qxmlname.html">QXmlName</a>&#160;<i>name</i>, <a href="qxmlitem.html">QXmlItem</a>&#160;<i>value</i>)</h3><p>Binds the variable <i>name</i> to the <i>value</i> so that
$<i>name</i> can be used from within the query to refer to the
<i>value</i>.</p>
<p><i>name</i> must not be <i>null</i>. <i>name</i>.isNull() must
return false. If <i>name</i> has already been bound by a previous
bindVariable() call, its previous binding will be overridden.</p>
<p>If <i>value</i> is null so that <i>value</i>.isNull() returns
true, and <i>name</i> already has a binding, the effect is to
remove the existing binding for <i>name</i>.</p>
<p>To bind a value of type <a href="qstring.html">QString</a> or
<a href="qurl.html">QUrl</a>, wrap the value in a <a href="qvariant.html">QVariant</a> such that <a href="qxmlitem.html">QXmlItem</a>'s <a href="qvariant.html">QVariant</a>
constructor is called.</p>
<p>All strings processed by the query must be valid <a href="xmlprocessing.html">XQuery</a> strings, which means they must
contain only XML 1.0 characters. However, this requirement is not
checked. If the query processes an invalid string, the behavior is
undefined.</p>
<p><b>See also</b> <a href="qvariant.html#isValid">QVariant.isValid</a>(), <a href="xmlprocessing.html#qtxdm">How QVariant maps to XQuery's Data
Model</a>, and <a href="qxmlitem.html#isNull">QXmlItem.isNull</a>().</p>


<h3 class="fn"><a name="bindVariable-2" />QXmlQuery.bindVariable (<i>self</i>, <a href="qxmlname.html">QXmlName</a>&#160;<i>name</i>, <a href="qiodevice.html">QIODevice</a>)</h3><p>Binds the variable <i>name</i> to the <i>device</i> so that
$<i>name</i> can be used from within the query to refer to the
<i>device</i>. The <a href="qiodevice.html">QIODevice</a>
<i>device</i> is exposed to the query as a URI of type
<tt>xs:anyURI</tt>, which can be passed to the <tt>fn:doc()</tt>
function to be read. E.g., this function can be used to pass an XML
document in memory to <tt>fn:doc</tt>.</p>
<pre class="cpp">
     <span class="type"><a href="qbytearray.html">QByteArray</a></span> myDocument;
     <span class="type"><a href="qbuffer.html">QBuffer</a></span> buffer(<span class="operator">&amp;</span>myDocument); <span class="comment">// This is a QIODevice.</span>
     buffer<span class="operator">.</span>open(<span class="type"><a href="qiodevice.html">QIODevice</a></span><span class="operator">.</span>ReadOnly);
     <span class="type"><a href="qxmlquery.html">QXmlQuery</a></span> query;
     query<span class="operator">.</span>bindVariable(<span class="string">"myDocument"</span><span class="operator">,</span> <span class="operator">&amp;</span>buffer);
     query<span class="operator">.</span>setQuery(<span class="string">"doc($myDocument)"</span>);
</pre>
<p>The caller must ensure that <i>device</i> has been opened with
at least <a href="qiodevice.html#OpenModeFlag-enum">QIODevice.ReadOnly</a> prior to
this binding. Otherwise, behavior is undefined.</p>
<p>If the query will access an XML document contained in a <a href="qstring.html">QString</a>, use a <a href="qbuffer.html">QBuffer</a> as shown in the following snippet.
Suppose <i>myQString</i> contains
<tt>&lt;document&gt;content&lt;/document&gt;</tt></p>
<pre class="cpp">
     <span class="type"><a href="qbuffer.html">QBuffer</a></span> device;
     device<span class="operator">.</span>setData(myQString<span class="operator">.</span>toUtf8());
     device<span class="operator">.</span>open(<span class="type"><a href="qiodevice.html">QIODevice</a></span><span class="operator">.</span>ReadOnly);

     <span class="type"><a href="qxmlquery.html">QXmlQuery</a></span> query;
     query<span class="operator">.</span><a href="qxmlquery.html#bindVariable">bindVariable</a>(<span class="string">"inputDocument"</span><span class="operator">,</span> <span class="operator">&amp;</span>device);
     query<span class="operator">.</span><a href="qxmlquery.html#setQuery">setQuery</a>(<span class="string">"doc($inputDocument)/query[theDocument]"</span>);
</pre>
<p><i>name</i> must not be <i>null</i>. <i>name</i>.isNull() must
return false. If <i>name</i> has already been bound, its previous
binding will be overridden. The URI that <i>name</i> evaluates to
is arbitrary and may change.</p>
<p>If the type of the variable binding changes (e.g., if a previous
binding by the same name was a <a href="qvariant.html">QVariant</a>, or if there was no previous binding),
<a href="qxmlquery.html#isValid">isValid</a>() will return
<tt>false</tt>, and recompilation of the query text is required. To
recompile the query, call <a href="qxmlquery.html#setQuery">setQuery</a>(). For this reason, <a href="qxmlquery.html#bindVariable">bindVariable</a>() should be called
before <a href="qxmlquery.html#setQuery">setQuery</a>(), if
possible.</p>
<p><b>Note:</b> <i>device</i> must not be deleted while this
<a href="qxmlquery.html">QXmlQuery</a> exists.</p>


<h3 class="fn"><a name="bindVariable-3" />QXmlQuery.bindVariable (<i>self</i>, <a href="qxmlname.html">QXmlName</a>&#160;<i>name</i>, <a href="qxmlquery.html">QXmlQuery</a>&#160;<i>query</i>)</h3><p>Binds the result of the query <i>query</i>, to a variable by
name <i>name</i>.</p>
<p>Evaluation of <i>query</i> will be commenced when this function
is called.</p>
<p>If <i>query</i> is invalid, behavior is undefined. <i>query</i>
will be copied.</p>
<p>This function was introduced in Qt 4.5.</p>
<p><b>See also</b> <a href="qxmlquery.html#isValid">isValid</a>().</p>


<h3 class="fn"><a name="bindVariable-4" />QXmlQuery.bindVariable (<i>self</i>, QString&#160;<i>localName</i>, <a href="qxmlitem.html">QXmlItem</a>&#160;<i>value</i>)</h3><p>This is an overloaded function.</p>
<p>This function constructs a <a href="qxmlname.html">QXmlName</a>
from <i>localName</i> using the query's <a href="qxmlnamepool.html">namespace</a>. The function then behaves as the
overloaded function. It is equivalent to the following snippet.</p>
<pre class="cpp">
     <span class="type"><a href="qxmlnamepool.html">QXmlNamePool</a></span> <a href="qxmlquery.html#namePool">namePool</a>(query<span class="operator">.</span>namePool());
     query<span class="operator">.</span><a href="qxmlquery.html#bindVariable">bindVariable</a>(<span class="type"><a href="qxmlname.html">QXmlName</a></span>(namePool<span class="operator">,</span> localName)<span class="operator">,</span> value);
</pre>


<h3 class="fn"><a name="bindVariable-5" />QXmlQuery.bindVariable (<i>self</i>, QString&#160;<i>localName</i>, <a href="qiodevice.html">QIODevice</a>)</h3><p>This is an overloaded function.</p>
<p>If <i>localName</i> is a valid <a href="qxmlname.html#isNCName">NCName</a>, this function is equivalent to
the following snippet.</p>
<pre class="cpp">
     <span class="type"><a href="qxmlnamepool.html">QXmlNamePool</a></span> namePool(query<span class="operator">.</span>namePool());
     query<span class="operator">.</span>bindVariable(<span class="type"><a href="qxmlname.html">QXmlName</a></span>(namePool<span class="operator">,</span> localName)<span class="operator">,</span> device);
</pre>
<p>A <a href="qxmlname.html">QXmlName</a> is constructed from
<i>localName</i>, and is passed to the appropriate overload along
with <i>device</i>.</p>
<p><b>See also</b> <a href="qxmlname.html#isNCName">QXmlName.isNCName</a>().</p>


<h3 class="fn"><a name="bindVariable-6" />QXmlQuery.bindVariable (<i>self</i>, QString&#160;<i>localName</i>, <a href="qxmlquery.html">QXmlQuery</a>&#160;<i>query</i>)</h3><p>This is an overloaded function.</p>
<p>Has the same behavior and effects as the function being
overloaded, but takes the variable name <i>localName</i> as a
<a href="qstring.html">QString</a>. <i>query</i> is used as in the
overloaded function.</p>
<p>This function was introduced in Qt 4.5.</p>


<h3 class="fn"><a name="evaluateTo" />QXmlQuery.evaluateTo (<i>self</i>, <a href="qxmlresultitems.html">QXmlResultItems</a>&#160;<i>result</i>)</h3><p>Starts the evaluation and makes it available in <i>result</i>.
If <i>result</i> is null, the behavior is undefined. The evaluation
takes place incrementally (lazy evaluation), as the caller uses
<a href="qxmlresultitems.html#next">QXmlResultItems.next</a>() to
get the next result.</p>
<p><b>See also</b> <a href="qxmlresultitems.html#next">QXmlResultItems.next</a>().</p>


<h3 class="fn"><a name="evaluateTo-2" />bool QXmlQuery.evaluateTo (<i>self</i>, <a href="qabstractxmlreceiver.html">QAbstractXmlReceiver</a>&#160;<i>callback</i>)</h3><p>Evaluates this query and sends the result as a sequence of
callbacks to the <a href="qabstractxmlreceiver.html">receiver</a>
<i>callback</i>. <a href="qxmlquery.html">QXmlQuery</a> does not
take ownership of <i>callback</i>.</p>
<p>If an error occurs during the evaluation, error messages are
sent to <a href="qxmlquery.html#messageHandler">messageHandler</a>() and
<tt>false</tt> is returned.</p>
<p>If this query <a href="qxmlquery.html#isValid">is invalid</a>,
<tt>false</tt> is returned and the behavior is undefined. If
<i>callback</i> is null, behavior is undefined.</p>
<p><b>See also</b> <a href="qabstractxmlreceiver.html">QAbstractXmlReceiver</a> and <a href="qxmlquery.html#isValid">isValid</a>().</p>


<h3 class="fn"><a name="evaluateTo-3" />bool QXmlQuery.evaluateTo (<i>self</i>, QStringList&#160;<i>target</i>)</h3><p>Attempts to evaluate the query and returns the results in the
<i>target</i> <a href="qstringlist.html">string list</a>.</p>
<p>If the query <a href="qxmlquery.html#isValid">is valid</a> and
the evaluation succeeds, true is returned. Otherwise, false is
returned and the contents of <i>target</i> are undefined.</p>
<p>The query must evaluate to a sequence of <tt>xs:string</tt>
values. If the query does not evaluate to a sequence of strings,
the values can often be converted by adding a call to
<tt>string()</tt> at the end of the <a href="xmlprocessing.html">XQuery</a>.</p>
<p>If <i>target</i> is null, the behavior is undefined.</p>


<h3 class="fn"><a name="evaluateTo-4" />bool QXmlQuery.evaluateTo (<i>self</i>, <a href="qiodevice.html">QIODevice</a>&#160;<i>target</i>)</h3><p>Evaluates the query, and serializes the output as XML to
<i>output</i>.</p>
<p>If an error occurs during the evaluation, error messages are
sent to <a href="qxmlquery.html#messageHandler">messageHandler</a>(), the content
of <i>output</i> is undefined and <tt>false</tt> is returned,
otherwise <tt>true</tt> is returned.</p>
<p>If <i>output</i> is <tt>null</tt> behavior is undefined.
<a href="qxmlquery.html">QXmlQuery</a> does not take ownership of
<i>output</i>.</p>
<p>Internally, the class <a href="qxmlformatter.html">QXmlFormatter</a> is used for this.</p>
<p>This function was introduced in Qt 4.5.</p>


<h3 class="fn"><a name="evaluateTo-5" />bool QXmlQuery.evaluateTo (<i>self</i>, QString&#160;<i>output</i>)</h3><p>Evaluates the query or stylesheet, and writes the output to
<i>target</i>.</p>
<p><a href="qxmlserializer.html">QXmlSerializer</a> is used to
write the output to <i>target</i>. In a future release, it is
expected that this function will be changed to respect
serialization options set in the stylesheet.</p>
<p>If an error occurs during the evaluation, error messages are
sent to <a href="qxmlquery.html#messageHandler">messageHandler</a>() and
<tt>false</tt> is returned.</p>
<p>If <i>target</i> is <tt>null</tt>, or is not opened in at least
<a href="qiodevice.html#OpenModeFlag-enum">QIODevice.WriteOnly</a>
mode, the behavior is undefined. <a href="qxmlquery.html">QXmlQuery</a> does not take ownership of
<i>target</i>.</p>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 4.5.</p>


<h3 class="fn"><a name="evaluateToString" />QString QXmlQuery.evaluateToString (<i>self</i>)</h3><h3 class="fn"><a name="evaluateToStringList" />QStringList QXmlQuery.evaluateToStringList (<i>self</i>)</h3><h3 class="fn"><a name="initialTemplateName" /><a href="qxmlname.html">QXmlName</a> QXmlQuery.initialTemplateName (<i>self</i>)</h3><p>Returns the name of the XSL-T stylesheet template that the
processor will call first when running an XSL-T stylesheet. This
function only applies when using <a href="qxmlquery.html">QXmlQuery</a> to process XSL-T stylesheets. By
default, no initial template is set. In that case, a default
constructed <a href="qxmlname.html">QXmlName</a> is returned.</p>
<p>This function was introduced in Qt 4.5.</p>
<p><b>See also</b> <a href="qxmlquery.html#setInitialTemplateName">setInitialTemplateName</a>().</p>


<h3 class="fn"><a name="isValid" />bool QXmlQuery.isValid (<i>self</i>)</h3><p>Returns true if this query is valid. Examples of invalid queries
are ones that contain syntax errors or that have not had <a href="qxmlquery.html#setQuery">setQuery</a>() called for them yet.</p>


<h3 class="fn"><a name="messageHandler" /><a href="qabstractmessagehandler.html">QAbstractMessageHandler</a> QXmlQuery.messageHandler (<i>self</i>)</h3><p>Returns the message handler that handles compile and runtime
messages for this <a href="qxmlquery.html">QXmlQuery</a>.</p>
<p><b>See also</b> <a href="qxmlquery.html#setMessageHandler">setMessageHandler</a>().</p>


<h3 class="fn"><a name="namePool" /><a href="qxmlnamepool.html">QXmlNamePool</a> QXmlQuery.namePool (<i>self</i>)</h3><p>Returns the name pool used by this <a href="qxmlquery.html">QXmlQuery</a> for constructing <a href="qxmlname.html">names</a>. There is no setter for the name pool,
because mixing name pools causes errors due to name confusion.</p>


<h3 class="fn"><a name="networkAccessManager" /><a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> QXmlQuery.networkAccessManager (<i>self</i>)</h3><p>Returns the network manager, or 0 if it has not been set.</p>
<p>This function was introduced in Qt 4.5.</p>
<p><b>See also</b> <a href="qxmlquery.html#setNetworkAccessManager">setNetworkAccessManager</a>().</p>


<h3 class="fn"><a name="queryLanguage" /><a href="qxmlquery.html#QueryLanguage-enum">QueryLanguage</a> QXmlQuery.queryLanguage (<i>self</i>)</h3><p>Returns a value indicating what this <a href="qxmlquery.html">QXmlQuery</a> is being used for. The default is
<a href="qxmlquery.html#QueryLanguage-enum">QXmlQuery.XQuery10</a>, which
means the <a href="qxmlquery.html">QXmlQuery</a> is being used for
running <a href="xmlprocessing.html">XQuery</a> and XPath queries.
<a href="qxmlquery.html#QueryLanguage-enum">QXmlQuery.XSLT20</a>
can also be returned, which indicates the <a href="qxmlquery.html">QXmlQuery</a> is for running XSL-T
spreadsheets.</p>
<p>This function was introduced in Qt 4.5.</p>


<h3 class="fn"><a name="setFocus" />QXmlQuery.setFocus (<i>self</i>, <a href="qxmlitem.html">QXmlItem</a>&#160;<i>item</i>)</h3><p>Sets the focus to <i>item</i>. The focus is the set of items
that the context item expression and path expressions navigate
from. For example, in the expression <i>p/span</i>, the element
that <i>p</i> evaluates to is the focus for the following
expression, <i>span</i>.</p>
<p>The focus can be accessed using the context item expression,
i.e., dot (".").</p>
<p>By default, the focus is not set and is undefined. It will
therefore result in a dynamic error, <tt>XPDY0002</tt>, if the
focus is attempted to be accessed. The focus must be set before the
query is set with <a href="qxmlquery.html#setQuery">setQuery</a>().</p>
<p>There is no behavior defined for setting an item which is
null.</p>


<h3 class="fn"><a name="setFocus-2" />bool QXmlQuery.setFocus (<i>self</i>, <a href="qurl.html">QUrl</a>&#160;<i>documentURI</i>)</h3><p>This is an overloaded function.</p>
<p>Sets the focus to be the document located at <i>documentURI</i>
and returns true. If <i>documentURI</i> cannot be loaded, false is
returned. It is undefined at what time the document may be loaded.
When loading the document, the message handler and URI resolver set
on this <a href="qxmlquery.html">QXmlQuery</a> are used.</p>
<p>If <i>documentURI</i> is empty or is not a valid URI, the
behavior of this function is undefined.</p>
<p>This function was introduced in Qt 4.5.</p>


<h3 class="fn"><a name="setFocus-3" />bool QXmlQuery.setFocus (<i>self</i>, <a href="qiodevice.html">QIODevice</a>&#160;<i>document</i>)</h3><p>Sets the focus to be the <i>document</i> read from the <a href="qiodevice.html">QIODevice</a> and returns true. If <i>document</i>
cannot be loaded, false is returned.</p>
<p><a href="qxmlquery.html">QXmlQuery</a> does not take ownership
of <i>document</i>. The user guarantees that a document is
available from the <i>document</i> device and that the document is
not empty. The device must be opened in at least read-only mode.
<i>document</i> must stay in scope as long as the current query is
active.</p>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 4.5.</p>


<h3 class="fn"><a name="setFocus-4" />bool QXmlQuery.setFocus (<i>self</i>, QString&#160;<i>focus</i>)</h3><p>This function behaves identically to calling the <a href="qxmlquery.html#setFocus">setFocus</a>() overload with a <a href="qiodevice.html">QIODevice</a> whose content is <i>focus</i>
encoded as UTF-8. That is, <i>focus</i> is treated as if it
contained an XML document.</p>
<p>Returns the same result as the overload.</p>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 4.6.</p>


<h3 class="fn"><a name="setInitialTemplateName" />QXmlQuery.setInitialTemplateName (<i>self</i>, <a href="qxmlname.html">QXmlName</a>&#160;<i>name</i>)</h3><p>Sets the <i>name</i> of the initial template. The initial
template is the one the processor calls first, instead of
attempting to match a template to the context node (if any). If an
initial template is not set, the standard order of template
invocation will be used.</p>
<p>This function only applies when using <a href="qxmlquery.html">QXmlQuery</a> to process XSL-T stylesheets. The
name becomes part of the compiled stylesheet. Therefore, this
function must be called before calling <a href="qxmlquery.html#setQuery">setQuery</a>().</p>
<p>If the stylesheet has no template named <i>name</i>, the
processor will use the standard order of template invocation.</p>
<p>This function was introduced in Qt 4.5.</p>
<p><b>See also</b> <a href="qxmlquery.html#initialTemplateName">initialTemplateName</a>().</p>


<h3 class="fn"><a name="setInitialTemplateName-2" />QXmlQuery.setInitialTemplateName (<i>self</i>, QString&#160;<i>name</i>)</h3><p>This is an overloaded function.</p>
<p>Sets the name of the initial template to <i>localName</i>, which
must be a valid <a href="qxmlname.html#localName">local name</a>.
The initial template is the one the processor calls first, instead
of attempting to match a template to the context node (if any). If
an initial template is not set, the standard order of template
invocation will be used.</p>
<p>This function only applies when using <a href="qxmlquery.html">QXmlQuery</a> to process XSL-T stylesheets. The
name becomes part of the compiled stylesheet. Therefore, this
function must be called before calling <a href="qxmlquery.html#setQuery">setQuery</a>().</p>
<p>If <i>localName</i> is not a valid <a href="qxmlname.html#localName">local name</a>, the effect is undefined.
If the stylesheet has no template named <i>localName</i>, the
processor will use the standard order of template invocation.</p>
<p>This function was introduced in Qt 4.5.</p>
<p><b>See also</b> <a href="qxmlquery.html#initialTemplateName">initialTemplateName</a>().</p>


<h3 class="fn"><a name="setMessageHandler" />QXmlQuery.setMessageHandler (<i>self</i>, <a href="qabstractmessagehandler.html">QAbstractMessageHandler</a>&#160;<i>messageHandler</i>)</h3><p>Changes the <a href="qabstractmessagehandler.html">message
handler</a> for this <a href="qxmlquery.html">QXmlQuery</a> to
<i>aMessageHandler</i>. The query sends all compile and runtime
messages to this message handler. <a href="qxmlquery.html">QXmlQuery</a> does not take ownership of
<i>aMessageHandler</i>.</p>
<p>Normally, the default message handler is sufficient. It writes
compile and runtime messages to <i>stderr</i>. The default message
handler includes color codes if <i>stderr</i> can render
colors.</p>
<p>Note that changing the message handler after the query has been
compiled has no effect, i.e. the query uses the same message
handler at runtime that it uses at compile time.</p>
<p>When <a href="qxmlquery.html">QXmlQuery</a> calls <a href="qabstractmessagehandler.html#message">QAbstractMessageHandler.message</a>(),
the arguments are as follows:</p>
<table class="generic">
<thead>
<tr class="qt-style">
<th>message() argument</th>
<th>Semantics</th>
</tr>
</thead>
<tr class="odd" valign="top">
<td><a href="qtcore.html#QtMsgType-enum">QtMsgType</a> type</td>
<td>Only <a href="qtcore.html#QtMsgType-enum">QtWarningMsg</a>
and <a href="qtcore.html#QtMsgType-enum">QtFatalMsg</a> are used.
The former identifies a compile or runtime warning, while the
latter identifies a dynamic or static error.</td>
</tr>
<tr class="even" valign="top">
<td>const <a href="qstring.html">QString</a> &amp; description</td>
<td>An XHTML document which is the actual message. It is translated
into the current language.</td>
</tr>
<tr class="odd" valign="top">
<td>const <a href="qurl.html">QUrl</a> &amp;identifier</td>
<td>Identifies the error with a URI, where the fragment is the
error code, and the rest of the URI is the error namespace.</td>
</tr>
<tr class="even" valign="top">
<td>const <a href="qsourcelocation.html">QSourceLocation</a> &amp;
sourceLocation</td>
<td>Identifies where the error occurred.</td>
</tr>
</table>
<p><b>See also</b> <a href="qxmlquery.html#messageHandler">messageHandler</a>().</p>


<h3 class="fn"><a name="setNetworkAccessManager" />QXmlQuery.setNetworkAccessManager (<i>self</i>, <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>&#160;<i>newManager</i>)</h3><p>Sets the network manager to <i>newManager</i>. <a href="qxmlquery.html">QXmlQuery</a> does not take ownership of
<i>newManager</i>.</p>
<p>This function was introduced in Qt 4.5.</p>
<p><b>See also</b> <a href="qxmlquery.html#networkAccessManager">networkAccessManager</a>().</p>


<h3 class="fn"><a name="setQuery" />QXmlQuery.setQuery (<i>self</i>, QString&#160;<i>sourceCode</i>, <a href="qurl.html">QUrl</a>&#160;<i>documentUri</i>&#160;=&#160;QUrl())</h3><p>Sets this <a href="qxmlquery.html">QXmlQuery</a> to an <a href="xmlprocessing.html">XQuery</a> read from the <i>sourceCode</i>
device. The device must have been opened with at least <a href="qiodevice.html#OpenModeFlag-enum">QIODevice.ReadOnly</a>.</p>
<p><i>documentURI</i> represents the query obtained from the
<i>sourceCode</i> device. It is the base URI of the static context,
as defined in the <a href="http://www.w3.org/TR/xquery/">XQuery
language</a>. It is used internally to resolve relative URIs that
appear in the query, and for message reporting. <i>documentURI</i>
can be empty. If it is empty, the <a href="qcoreapplication.html#applicationFilePath">application file
path</a> is used. If it is not empty, it may be either relative or
absolute. If it is relative, it is resolved itself against the
<a href="qcoreapplication.html#applicationFilePath">application
file path</a> before it is used. If <i>documentURI</i> is neither a
valid URI nor empty, the result is undefined.</p>
<p>If the query contains a static error (e.g. syntax error), an
error message is sent to the <a href="qxmlquery.html#messageHandler">messageHandler</a>(), and <a href="qxmlquery.html#isValid">isValid</a>() will return
<i>false</i>.</p>
<p>Variables must be bound before setQuery() is called.</p>
<p>The encoding of the <a href="xmlprocessing.html">XQuery</a> in
<i>sourceCode</i> is detected internally using the rules for
setting and detecting encoding of <a href="xmlprocessing.html">XQuery</a> files, which are explained in the
<a href="http://www.w3.org/TR/xquery/">XQuery language</a>.</p>
<p>If <i>sourceCode</i> is <tt>null</tt> or not readable, or if
<i>documentURI</i> is not a valid URI, behavior is undefined.</p>
<p><b>See also</b> <a href="qxmlquery.html#isValid">isValid</a>().</p>


<h3 class="fn"><a name="setQuery-2" />QXmlQuery.setQuery (<i>self</i>, <a href="qiodevice.html">QIODevice</a>&#160;<i>sourceCode</i>, <a href="qurl.html">QUrl</a>&#160;<i>documentUri</i>&#160;=&#160;QUrl())</h3><p>Sets this <a href="qxmlquery.html">QXmlQuery</a> to the <a href="xmlprocessing.html">XQuery</a> read from the <i>queryURI</i>. Use
<a href="qxmlquery.html#isValid">isValid</a>() after calling this
function. If an error occurred reading <i>queryURI</i>, e.g., the
query does not exist, cannot be read, or is invalid, <a href="qxmlquery.html#isValid">isValid</a>() will return
<i>false</i>.</p>
<p>The supported URI schemes are the same as those in the <a href="xmlprocessing.html">XQuery</a> function <tt>fn:doc</tt>, except
that queryURI can be the object of a variable binding.</p>
<p><i>baseURI</i> is the Base URI of the static context, as defined
in the <a href="http://www.w3.org/TR/xquery/">XQuery language</a>.
It is used internally to resolve relative URIs that appear in the
query, and for message reporting. If <i>baseURI</i> is empty,
<i>queryURI</i> is used. Otherwise, <i>baseURI</i> is used, and it
is resolved against the <a href="qcoreapplication.html#applicationFilePath">application file
path</a> if it is relative.</p>
<p>If <i>queryURI</i> is empty or invalid, or if <i>baseURI</i> is
invalid, the behavior of this function is undefined.</p>


<h3 class="fn"><a name="setQuery-3" />QXmlQuery.setQuery (<i>self</i>, <a href="qurl.html">QUrl</a>&#160;<i>queryURI</i>, <a href="qurl.html">QUrl</a>&#160;<i>baseUri</i>&#160;=&#160;QUrl())</h3><p>This is an overloaded function.</p>
<p>The behavior and requirements of this function are the same as
for setQuery(<a href="qiodevice.html">QIODevice</a>*, const
<a href="qurl.html">QUrl</a>&amp;), after the <a href="xmlprocessing.html">XQuery</a> has been read from the IO device
into a string. Because <i>sourceCode</i> is already a Unicode
string, detection of its encoding is unnecessary.</p>


<h3 class="fn"><a name="setUriResolver" />QXmlQuery.setUriResolver (<i>self</i>, <a href="qabstracturiresolver.html">QAbstractUriResolver</a>&#160;<i>resolver</i>)</h3><p>Sets the URI resolver to <i>resolver</i>. <a href="qxmlquery.html">QXmlQuery</a> does not take ownership of
<i>resolver</i>.</p>
<p><b>See also</b> <a href="qxmlquery.html#uriResolver">uriResolver</a>().</p>


<h3 class="fn"><a name="uriResolver" /><a href="qabstracturiresolver.html">QAbstractUriResolver</a> QXmlQuery.uriResolver (<i>self</i>)</h3><p>Returns the query's URI resolver. If no URI resolver has been
set, <a href="qtxmlpatterns.html">QtXmlPatterns</a> will use the
URIs in queries as they are.</p>
<p>The URI resolver provides a level of abstraction, or
<i>polymorphic URIs</i>. A resolver can rewrite <i>logical</i> URIs
to physical ones, or it can translate obsolete or invalid URIs to
valid ones.</p>
<p><a href="qtxmlpatterns.html">QtXmlPatterns</a> calls the URI
resolver for all URIs it encounters, except for namespaces.
Specifically, all builtin functions that deal with URIs
(<tt>fn:doc()</tt>, and <tt>fn:doc-available()</tt>).</p>
<p>In the case of <tt>fn:doc()</tt>, the absolute URI is the base
URI in the static context (which most likely is the location of the
query). Rather than use the URI the user specified, the return
value of <a href="qabstracturiresolver.html#resolve">QAbstractUriResolver.resolve</a>()
will be used.</p>
<p>When <a href="qtxmlpatterns.html">QtXmlPatterns</a> calls
<a href="qabstracturiresolver.html#resolve">QAbstractUriResolver.resolve</a>()
the absolute URI is the URI mandated by the <a href="xmlprocessing.html">XQuery</a> language, and the relative URI is
the URI specified by the user.</p>
<p><b>See also</b> <a href="qxmlquery.html#setUriResolver">setUriResolver</a>().</p>


<address><hr /><div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address"><td align="left" width="25%">PyQt&#160;4.10 for Windows</td><td align="center" width="50%">Copyright &#169; <a href="http://www.riverbankcomputing.com">Riverbank&#160;Computing&#160;Ltd</a> and <a href="http://www.qtsoftware.com">Nokia</a> 2012</td><td align="right" width="25%">Qt&#160;4.8.4</td></tr></table></div></address></body></html>