<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html><head><title>QObject Class Reference</title><style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style></head><body><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr /><td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" width="32" /></td><td width="1">&#160;&#160;</td><td class="postheader" valign="center"><a href="../pyqt4ref.html"><font color="#004faf">Home</font></a>&#160;&#183; <a href="classes.html"><font color="#004faf">All Classes</font></a>&#160;&#183; <a href="modules.html"><font color="#004faf">Modules</font></a></td></table><h1 align="center">QObject Class Reference<br /><sup><sup>[<a href="qtcore.html">QtCore</a> module]</sup></sup></h1><p>The QObject class is the base class of all Qt objects. <a href="#details">More...</a></p>

<p>Inherited by <a href="phonon-abstractaudiooutput.html">AbstractAudioOutput</a>, <a href="phonon-backendcapabilities-notifier.html">Notifier</a>, <a href="phonon-effect.html">Effect</a>, <a href="phonon-mediacontroller.html">MediaController</a>, <a href="phonon-mediaobject.html">MediaObject</a>, <a href="qabstractanimation.html">QAbstractAnimation</a>, <a href="qabstracteventdispatcher.html">QAbstractEventDispatcher</a>, <a href="qabstractitemdelegate.html">QAbstractItemDelegate</a>, <a href="qabstractitemmodel.html">QAbstractItemModel</a>, <a href="qabstractmessagehandler.html">QAbstractMessageHandler</a>, <a href="qabstractnetworkcache.html">QAbstractNetworkCache</a>, <a href="qabstractstate.html">QAbstractState</a>, <a href="qabstracttextdocumentlayout.html">QAbstractTextDocumentLayout</a>, <a href="qabstracttransition.html">QAbstractTransition</a>, <a href="qabstracturiresolver.html">QAbstractUriResolver</a>, <a href="qabstractvideosurface.html">QAbstractVideoSurface</a>, <a href="qaction.html">QAction</a>, <a href="qactiongroup.html">QActionGroup</a>, <a href="qassistantclient.html">QAssistantClient</a>, <a href="qaudioinput.html">QAudioInput</a>, <a href="qaudiooutput.html">QAudioOutput</a>, <a href="qaxobject.html">QAxObject</a>, <a href="qbuttongroup.html">QButtonGroup</a>, <a href="qclipboard.html">QClipboard</a>, <a href="qcompleter.html">QCompleter</a>, <a href="qcoreapplication.html">QCoreApplication</a>, <a href="qdatawidgetmapper.html">QDataWidgetMapper</a>, <a href="qdeclarativecomponent.html">QDeclarativeComponent</a>, <a href="qdeclarativecontext.html">QDeclarativeContext</a>, <a href="qdeclarativeengine.html">QDeclarativeEngine</a>, <a href="qdeclarativeexpression.html">QDeclarativeExpression</a>, <a href="qdeclarativeextensionplugin.html">QDeclarativeExtensionPlugin</a>, <a href="qdeclarativepropertymap.html">QDeclarativePropertyMap</a>, <a href="qdesignerformeditorinterface.html">QDesignerFormEditorInterface</a>, <a href="qdesignerformwindowmanagerinterface.html">QDesignerFormWindowManagerInterface</a>, <a href="qdrag.html">QDrag</a>, <a href="qeventloop.html">QEventLoop</a>, <a href="qextensionfactory.html">QExtensionFactory</a>, <a href="qextensionmanager.html">QExtensionManager</a>, <a href="qfilesystemwatcher.html">QFileSystemWatcher</a>, <a href="qftp.html">QFtp</a>, <a href="qgesture.html">QGesture</a>, <a href="qglshader.html">QGLShader</a>, <a href="qglshaderprogram.html">QGLShaderProgram</a>, <a href="qgraphicsanchor.html">QGraphicsAnchor</a>, <a href="qgraphicseffect.html">QGraphicsEffect</a>, <a href="qgraphicsitemanimation.html">QGraphicsItemAnimation</a>, <a href="qgraphicsobject.html">QGraphicsObject</a>, <a href="qgraphicsscene.html">QGraphicsScene</a>, <a href="qgraphicstransform.html">QGraphicsTransform</a>, <a href="qhelpenginecore.html">QHelpEngineCore</a>, <a href="qhelpsearchengine.html">QHelpSearchEngine</a>, <a href="qhttp.html">QHttp</a>, <a href="qinputcontext.html">QInputContext</a>, <a href="qiodevice.html">QIODevice</a>, <a href="qitemselectionmodel.html">QItemSelectionModel</a>, <a href="qlayout.html">QLayout</a>, <a href="qlibrary.html">QLibrary</a>, <a href="qlocalserver.html">QLocalServer</a>, <a href="qmimedata.html">QMimeData</a>, <a href="qmovie.html">QMovie</a>, <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>, <a href="qnetworkconfigurationmanager.html">QNetworkConfigurationManager</a>, <a href="qnetworkcookiejar.html">QNetworkCookieJar</a>, <a href="qnetworksession.html">QNetworkSession</a>, <a href="qobjectcleanuphandler.html">QObjectCleanupHandler</a>, <a href="qpluginloader.html">QPluginLoader</a>, <a href="qpydeclarativepropertyvaluesource.html">QPyDeclarativePropertyValueSource</a>, <a href="qpydesignercontainerextension.html">QPyDesignerContainerExtension</a>, <a href="qpydesignercustomwidgetcollectionplugin.html">QPyDesignerCustomWidgetCollectionPlugin</a>, <a href="qpydesignercustomwidgetplugin.html">QPyDesignerCustomWidgetPlugin</a>, <a href="qpydesignermembersheetextension.html">QPyDesignerMemberSheetExtension</a>, <a href="qpydesignerpropertysheetextension.html">QPyDesignerPropertySheetExtension</a>, <a href="qpydesignertaskmenuextension.html">QPyDesignerTaskMenuExtension</a>, <a href="qpytextobject.html">QPyTextObject</a>, <a href="qscriptengine.html">QScriptEngine</a>, <a href="qscriptenginedebugger.html">QScriptEngineDebugger</a>, <a href="qsessionmanager.html">QSessionManager</a>, <a href="qsettings.html">QSettings</a>, <a href="qsharedmemory.html">QSharedMemory</a>, <a href="qshortcut.html">QShortcut</a>, <a href="qsignalmapper.html">QSignalMapper</a>, <a href="qsocketnotifier.html">QSocketNotifier</a>, <a href="qsound.html">QSound</a>, <a href="qsqldriver.html">QSqlDriver</a>, <a href="qstyle.html">QStyle</a>, <a href="qsvgrenderer.html">QSvgRenderer</a>, <a href="qsyntaxhighlighter.html">QSyntaxHighlighter</a>, <a href="qsystemtrayicon.html">QSystemTrayIcon</a>, <a href="qtcpserver.html">QTcpServer</a>, <a href="qtextdocument.html">QTextDocument</a>, <a href="qtextobject.html">QTextObject</a>, <a href="qthread.html">QThread</a>, <a href="qthreadpool.html">QThreadPool</a>, <a href="qtimeline.html">QTimeLine</a>, <a href="qtimer.html">QTimer</a>, <a href="qtranslator.html">QTranslator</a>, <a href="qundogroup.html">QUndoGroup</a>, <a href="qundostack.html">QUndoStack</a>, <a href="qvalidator.html">QValidator</a>, <a href="qwebframe.html">QWebFrame</a>, <a href="qwebhistoryinterface.html">QWebHistoryInterface</a>, <a href="qwebpage.html">QWebPage</a>, <a href="qwebpluginfactory.html">QWebPluginFactory</a> and <a href="qwidget.html">QWidget</a>.</p><h3>Methods</h3><ul><li><div class="fn" /><b><a href="qobject.html#QObject">__init__</a></b> (<i>self</i>, QObject&#160;<i>parent</i>&#160;=&#160;None)</li><li><div class="fn" />bool <b><a href="qobject.html#blockSignals">blockSignals</a></b> (<i>self</i>, bool&#160;<i>b</i>)</li><li><div class="fn" /><b><a href="qobject.html#childEvent">childEvent</a></b> (<i>self</i>, QChildEvent)</li><li><div class="fn" />list-of-QObject <b><a href="qobject.html#children">children</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qobject.html#connect-3">connect</a></b> (<i>self</i>, QObject, SIGNAL(), SLOT(), Qt.ConnectionType&#160;=&#160;Qt.AutoConnection)</li><li><div class="fn" /><b><a href="qobject.html#connectNotify">connectNotify</a></b> (<i>self</i>, SIGNAL()&#160;<i>signal</i>)</li><li><div class="fn" /><b><a href="qobject.html#customEvent">customEvent</a></b> (<i>self</i>, QEvent)</li><li><div class="fn" /><b><a href="qobject.html#deleteLater">deleteLater</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qobject.html#disconnectNotify">disconnectNotify</a></b> (<i>self</i>, SIGNAL()&#160;<i>signal</i>)</li><li><div class="fn" /><b><a href="qobject.html#dumpObjectInfo">dumpObjectInfo</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qobject.html#dumpObjectTree">dumpObjectTree</a></b> (<i>self</i>)</li><li><div class="fn" />list-of-QByteArray <b><a href="qobject.html#dynamicPropertyNames">dynamicPropertyNames</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qobject.html#emit">emit</a></b> (<i>self</i>, SIGNAL(), ...)</li><li><div class="fn" />bool <b><a href="qobject.html#event">event</a></b> (<i>self</i>, QEvent)</li><li><div class="fn" />bool <b><a href="qobject.html#eventFilter">eventFilter</a></b> (<i>self</i>, QObject, QEvent)</li><li><div class="fn" />QObject <b><a href="qobject.html#findChild">findChild</a></b> (<i>self</i>, type&#160;<i>type</i>, QString&#160;<i>name</i>&#160;=&#160;QString())</li><li><div class="fn" />list-of-QObject <b><a href="qobject.html#findChildren">findChildren</a></b> (<i>self</i>, type&#160;<i>type</i>, QString&#160;<i>name</i>&#160;=&#160;QString())</li><li><div class="fn" />list-of-QObject <b><a href="qobject.html#findChildren-2">findChildren</a></b> (<i>self</i>, type&#160;<i>type</i>, QRegExp&#160;<i>regExp</i>)</li><li><div class="fn" />bool <b><a href="qobject.html#inherits">inherits</a></b> (<i>self</i>, str&#160;<i>classname</i>)</li><li><div class="fn" /><b><a href="qobject.html#installEventFilter">installEventFilter</a></b> (<i>self</i>, QObject)</li><li><div class="fn" />bool <b><a href="qobject.html#isWidgetType">isWidgetType</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qobject.html#killTimer">killTimer</a></b> (<i>self</i>, int&#160;<i>id</i>)</li><li><div class="fn" />QMetaObject <b><a href="qobject.html#metaObject">metaObject</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qobject.html#moveToThread">moveToThread</a></b> (<i>self</i>, QThread&#160;<i>thread</i>)</li><li><div class="fn" />QString <b><a href="qobject.html#objectName">objectName</a></b> (<i>self</i>)</li><li><div class="fn" />QObject <b><a href="qobject.html#parent">parent</a></b> (<i>self</i>)</li><li><div class="fn" />QVariant <b><a href="qobject.html#property">property</a></b> (<i>self</i>, str&#160;<i>name</i>)</li><li><div class="fn" /><b><a href="qobject.html#pyqtConfigure">pyqtConfigure</a></b> (<i>self</i>, object)</li><li><div class="fn" />int <b><a href="qobject.html#receivers">receivers</a></b> (<i>self</i>, SIGNAL()&#160;<i>signal</i>)</li><li><div class="fn" /><b><a href="qobject.html#removeEventFilter">removeEventFilter</a></b> (<i>self</i>, QObject)</li><li><div class="fn" />QObject <b><a href="qobject.html#sender">sender</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qobject.html#setObjectName">setObjectName</a></b> (<i>self</i>, QString&#160;<i>name</i>)</li><li><div class="fn" /><b><a href="qobject.html#setParent">setParent</a></b> (<i>self</i>, QObject)</li><li><div class="fn" />bool <b><a href="qobject.html#setProperty">setProperty</a></b> (<i>self</i>, str&#160;<i>name</i>, QVariant&#160;<i>value</i>)</li><li><div class="fn" />bool <b><a href="qobject.html#signalsBlocked">signalsBlocked</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qobject.html#startTimer">startTimer</a></b> (<i>self</i>, int&#160;<i>interval</i>)</li><li><div class="fn" />QThread <b><a href="qobject.html#thread">thread</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qobject.html#timerEvent">timerEvent</a></b> (<i>self</i>, QTimerEvent)</li><li><div class="fn" />QString <b><a href="qobject.html#tr">tr</a></b> (<i>self</i>, str&#160;<i>sourceText</i>, str&#160;<i>disambiguation</i>&#160;=&#160;None, int&#160;<i>n</i>&#160;=&#160;-1)</li><li><div class="fn" />QString <b><a href="qobject.html#trUtf8">trUtf8</a></b> (<i>self</i>, str&#160;<i>sourceText</i>, str&#160;<i>disambiguation</i>&#160;=&#160;None, int&#160;<i>n</i>&#160;=&#160;-1)</li></ul><h3>Static Methods</h3><ul><li><div class="fn" />bool <b><a href="qobject.html#connect">connect</a></b> (QObject, SIGNAL(), QObject, SLOT(), Qt.ConnectionType&#160;=&#160;Qt.AutoConnection)</li><li><div class="fn" />bool <b><a href="qobject.html#connect-2">connect</a></b> (QObject, SIGNAL(), callable, Qt.ConnectionType&#160;=&#160;Qt.AutoConnection)</li><li><div class="fn" />bool <b><a href="qobject.html#disconnect">disconnect</a></b> (QObject, SIGNAL(), QObject, SLOT())</li><li><div class="fn" />bool <b><a href="qobject.html#disconnect-2">disconnect</a></b> (QObject, SIGNAL(), callable)</li></ul><h3>Special Methods</h3><ul><li><div class="fn" />object <b><a href="qobject.html#__getattr__">__getattr__</a></b> (<i>self</i>, str&#160;<i>name</i>)</li></ul><h3>Qt Signals</h3><ul><li><div class="fn" />void <b><a href="qobject.html#destroyed">destroyed</a></b> (QObject * = 0)</li></ul><h3>Static Members</h3><ul><li><div class="fn" />QMetaObject <b><a href="qobject.html#staticMetaObject-var">staticMetaObject</a></b></li></ul><a name="details" /><hr /><h2>Detailed Description</h2><p>The QObject class is the base class of all Qt objects.</p>
<p>QObject is the heart of the Qt <a href="object.html">Object
Model</a>. The central feature in this model is a very powerful
mechanism for seamless object communication called <a href="signalsandslots.html#signals-and-slots">signals and slots</a>. You
can connect a signal to a slot with <a href="qobject.html#connect">connect</a>() and destroy the connection
with <a href="qobject.html#disconnect">disconnect</a>(). To avoid
never ending notification loops you can temporarily block signals
with <a href="qobject.html#blockSignals">blockSignals</a>(). The
protected functions <a href="qobject.html#connectNotify">connectNotify</a>() and <a href="qobject.html#disconnectNotify">disconnectNotify</a>() make it
possible to track connections.</p>
<p><a href="qtwebkit-bridge.html#qobjects">QObjects</a> organize
themselves in <a href="objecttrees.html">object trees</a>. When you
create a QObject with another object as parent, the object will
automatically add itself to the parent's <a href="qobject.html#children">children</a>() list. The parent takes
ownership of the object; i.e., it will automatically delete its
children in its destructor. You can look for an object by name and
optionally type using <a href="qobject.html#findChild">findChild</a>() or <a href="qobject.html#findChildren">findChildren</a>().</p>
<p>Every object has an <a href="qobject.html#objectName-prop">objectName</a>() and its class name
can be found via the corresponding <a href="qobject.html#metaObject">metaObject</a>() (see <a href="qmetaobject.html#className">QMetaObject.className</a>()). You can
determine whether the object's class inherits another class in the
QObject inheritance hierarchy by using the <a href="qobject.html#inherits">inherits</a>() function.</p>
<p>When an object is deleted, it emits a <a href="qobject.html#destroyed">destroyed</a>() signal. You can catch this
signal to avoid dangling references to <a href="qtwebkit-bridge.html#qobjects">QObjects</a>.</p>
<p><a href="qtwebkit-bridge.html#qobjects">QObjects</a> can receive
events through <a href="qobject.html#event">event</a>() and filter
the events of other objects. See <a href="qobject.html#installEventFilter">installEventFilter</a>() and
<a href="qobject.html#eventFilter">eventFilter</a>() for details. A
convenience handler, <a href="qobject.html#childEvent">childEvent</a>(), can be reimplemented to
catch child events.</p>
<p>Events are delivered in the thread in which the object was
created; see <a href="threads.html">Thread Support in Qt</a> and
<a href="qobject.html#thread">thread</a>() for details. Note that
event processing is not done at all for <a href="qtwebkit-bridge.html#qobjects">QObjects</a> with no thread
affinity (<a href="qobject.html#thread">thread</a>() returns zero).
Use the <a href="qobject.html#moveToThread">moveToThread</a>()
function to change the thread affinity for an object and its
children (the object cannot be moved if it has a parent).</p>
<p>Last but not least, QObject provides the basic timer support in
Qt; see <a href="qtimer.html">QTimer</a> for high-level support for
timers.</p>
<p>Notice that the <a href="qobject.html#Q_OBJECT">Q_OBJECT</a>
macro is mandatory for any object that implements signals, slots or
properties. You also need to run the <a href="moc.html#moc">Meta
Object Compiler</a> on the source file. We strongly recommend the
use of this macro in all subclasses of QObject regardless of
whether or not they actually use signals, slots and properties,
since failure to do so may lead certain functions to exhibit
strange behavior.</p>
<p>All Qt widgets inherit QObject. The convenience function
<a href="qobject.html#isWidgetType">isWidgetType</a>() returns
whether an object is actually a widget. It is much faster than
<a href="qobject.html#qobject_cast">qobject_cast</a>&lt;<a href="qwidget.html">QWidget</a> *&gt;(<i>obj</i>) or
<i>obj</i>-&gt;<a href="qobject.html#inherits">inherits</a>("<a href="qwidget.html">QWidget</a>").</p>
<p>Some QObject functions, e.g. <a href="qobject.html#children">children</a>(), return a <a href="qobject.html#QObjectList-typedef">QObjectList</a>. <a href="qobject.html#QObjectList-typedef">QObjectList</a> is a typedef for
<a href="qlist.html">QList</a>&lt;QObject *&gt;.</p>
<a id="no-copy-constructor" name="no-copy-constructor" /><a id="no-copy-constructor-or-assignment-operator" name="no-copy-constructor-or-assignment-operator" />
<h3>No copy constructor or assignment operator</h3>
<p>QObject has neither a copy constructor nor an assignment
operator. This is by design. Actually, they are declared, but in a
<tt>private</tt> section with the macro <a href="qobject.html#Q_DISABLE_COPY">Q_DISABLE_COPY</a>(). In fact, all Qt
classes derived from QObject (direct or indirect) use this macro to
declare their copy constructor and assignment operator to be
private. The reasoning is found in the discussion on <a href="object.html#identity-vs-value">Identity vs Value</a> on the Qt
<a href="object.html">Object Model</a> page.</p>
<p>The main consequence is that you should use pointers to QObject
(or to your QObject subclass) where you might otherwise be tempted
to use your QObject subclass as a value. For example, without a
copy constructor, you can't use a subclass of QObject as the value
to be stored in one of the container classes. You must store
pointers.</p>
<a id="auto-connection" name="auto-connection" />
<h3>Auto-Connection</h3>
<p>Qt's meta-object system provides a mechanism to automatically
connect signals and slots between QObject subclasses and their
children. As long as objects are defined with suitable object
names, and slots follow a simple naming convention, this connection
can be performed at run-time by the <a href="qmetaobject.html#connectSlotsByName">QMetaObject.connectSlotsByName</a>()
function.</p>
<p><a href="uic.html#uic">uic</a> generates code that invokes this
function to enable auto-connection to be performed between widgets
on forms created with <i>Qt Designer</i>. More information about
using auto-connection with <i>Qt Designer</i> is given in the
<a href="designer-using-a-ui-file.html">Using a Designer UI File in
Your Application</a> section of the <i>Qt Designer</i> manual.</p>
<a id="dynamic-properties" name="dynamic-properties" />
<h3>Dynamic Properties</h3>
<p>From Qt 4.2, dynamic properties can be added to and removed from
QObject instances at run-time. Dynamic properties do not need to be
declared at compile-time, yet they provide the same advantages as
static properties and are manipulated using the same API - using
<a href="qobject.html#property">property</a>() to read them and
<a href="qobject.html#setProperty">setProperty</a>() to write
them.</p>
<p>From Qt 4.3, dynamic properties are supported by <a href="designer-widget-mode.html#the-property-editor">Qt Designer</a>,
and both standard Qt widgets and user-created forms can be given
dynamic properties.</p>
<a id="internationalization-i18n" name="internationalization-i18n" />
<h3>Internationalization (i18n)</h3>
<p>All QObject subclasses support Qt's translation features, making
it possible to translate an application's user interface into
different languages.</p>
<p>To make user-visible text translatable, it must be wrapped in
calls to the <a href="qobject.html#tr">tr</a>() function. This is
explained in detail in the <a href="i18n-source-translation.html">Writing Source Code for
Translation</a> document.</p>
<hr /><h2>Method Documentation</h2><h3 class="fn"><a name="QObject" />QObject.__init__ (<i>self</i>, <a href="qobject.html">QObject</a>&#160;<i>parent</i>&#160;=&#160;None)</h3><p>The <i>parent</i> argument, if not None, causes <i>self</i> to be owned by Qt instead of PyQt.</p><p>Constructs an object with parent object <i>parent</i>.</p>
<p>The parent of an object may be viewed as the object's owner. For
instance, a <a href="qdialog.html">dialog box</a> is the parent of
the <b>OK</b> and <b>Cancel</b> buttons it contains.</p>
<p>The destructor of a parent object destroys all child
objects.</p>
<p>Setting <i>parent</i> to 0 constructs an object with no parent.
If the object is a widget, it will become a top-level window.</p>
<p>See also <a href="qobject.html#parent">parent</a>(), <a href="qobject.html#findChild">findChild</a>(), and <a href="qobject.html#findChildren">findChildren</a>().</p>


<h3 class="fn"><a name="blockSignals" />bool QObject.blockSignals (<i>self</i>, bool&#160;<i>b</i>)</h3><p>If <i>block</i> is true, signals emitted by this object are
blocked (i.e., emitting a signal will not invoke anything connected
to it). If <i>block</i> is false, no such blocking will occur.</p>
<p>The return value is the previous value of <a href="qobject.html#signalsBlocked">signalsBlocked</a>().</p>
<p>Note that the <a href="qobject.html#destroyed">destroyed</a>()
signal will be emitted even if the signals for this object have
been blocked.</p>
<p>See also <a href="qobject.html#signalsBlocked">signalsBlocked</a>().</p>


<h3 class="fn"><a name="childEvent" />QObject.childEvent (<i>self</i>, <a href="qchildevent.html">QChildEvent</a>)</h3><p>This event handler can be reimplemented in a subclass to receive
child events. The event is passed in the <i>event</i>
parameter.</p>
<p><a href="qevent.html#Type-enum">QEvent.ChildAdded</a> and
<a href="qevent.html#Type-enum">QEvent.ChildRemoved</a> events are
sent to objects when children are added or removed. In both cases
you can only rely on the child being a <a href="qobject.html">QObject</a>, or if <a href="qobject.html#isWidgetType">isWidgetType</a>() returns true, a
<a href="qwidget.html">QWidget</a>. (This is because, in the
<a href="qevent.html#Type-enum">ChildAdded</a> case, the child is
not yet fully constructed, and in the <a href="qevent.html#Type-enum">ChildRemoved</a> case it might have been
destructed already).</p>
<p><a href="qevent.html#Type-enum">QEvent.ChildPolished</a> events
are sent to widgets when children are polished, or when polished
children are added. If you receive a child polished event, the
child's construction is usually completed. However, this is not
guaranteed, and multiple polish events may be delivered during the
execution of a widget's constructor.</p>
<p>For every child widget, you receive one <a href="qevent.html#Type-enum">ChildAdded</a> event, zero or more <a href="qevent.html#Type-enum">ChildPolished</a> events, and one <a href="qevent.html#Type-enum">ChildRemoved</a> event.</p>
<p>The <a href="qevent.html#Type-enum">ChildPolished</a> event is
omitted if a child is removed immediately after it is added. If a
child is polished several times during construction and
destruction, you may receive several child polished events for the
same child, each time with a different virtual table.</p>
<p>See also <a href="qobject.html#event">event</a>().</p>


<h3 class="fn"><a name="children" />list-of-QObject QObject.children (<i>self</i>)</h3><p>Returns a list of child objects. The <a href="qobject.html#QObjectList-typedef">QObjectList</a> class is defined
in the <tt>&lt;QObject&gt;</tt> header file as the following:</p>
<pre class="highlightedCode brush: cpp">
 typedef QList&lt;QObject*&gt; QObjectList;
</pre>
<p>The first child added is the <a href="qlist.html#first">first</a> object in the list and the last child
added is the <a href="qlist.html#last">last</a> object in the list,
i.e. new children are appended at the end.</p>
<p>Note that the list order changes when <a href="qwidget.html">QWidget</a> children are <a href="qwidget.html#raise">raised</a> or <a href="qwidget.html#lower">lowered</a>. A widget that is raised becomes
the last object in the list, and a widget that is lowered becomes
the first object in the list.</p>
<p>See also <a href="qobject.html#findChild">findChild</a>(),
<a href="qobject.html#findChildren">findChildren</a>(), <a href="qobject.html#parent">parent</a>(), and <a href="qobject.html#setParent">setParent</a>().</p>


<h3 class="fn"><a name="connect" />bool QObject.connect (<a href="qobject.html">QObject</a>, SIGNAL(), <a href="qobject.html">QObject</a>, SLOT(), <a href="qt.html#ConnectionType-enum">Qt.ConnectionType</a>&#160;=&#160;Qt.AutoConnection)</h3><p>Creates a connection of the given <i>type</i> from the
<i>signal</i> in the <i>sender</i> object to the <i>method</i> in
the <i>receiver</i> object. Returns true if the connection
succeeds; otherwise returns false.</p>
<p>You must use the <tt>SIGNAL()</tt> and <tt>SLOT()</tt> macros
when specifying the <i>signal</i> and the <i>method</i>, for
example:</p>
<pre class="highlightedCode brush: cpp">
 QLabel *label = new QLabel;
 QScrollBar *scrollBar = new QScrollBar;
 QObject.connect(scrollBar, SIGNAL(valueChanged(int)),
                  label,  SLOT(setNum(int)));
</pre>
<p>This example ensures that the label always displays the current
scroll bar value. Note that the signal and slots parameters must
not contain any variable names, only the type. E.g. the following
would not work and return false:</p>
<pre class="highlightedCode brush: cpp">
<span class="comment"> // WRONG</span>
 QObject.connect(scrollBar, SIGNAL(valueChanged(int value)),
                  label, SLOT(setNum(int value)));
</pre>
<p>A signal can also be connected to another signal:</p>
<pre class="highlightedCode brush: cpp">
 class MyWidget : public QWidget
 {
     Q_OBJECT

 public:
     MyWidget();

 signals:
     void buttonClicked();

 private:
     QPushButton *myButton;
 };

 MyWidget.MyWidget()
 {
     myButton = new QPushButton(this);
     connect(myButton, SIGNAL(clicked()),
             this, SIGNAL(buttonClicked()));
 }
</pre>
<p>In this example, the <tt>MyWidget</tt> constructor relays a
signal from a private member variable, and makes it available under
a name that relates to <tt>MyWidget</tt>.</p>
<p>A signal can be connected to many slots and signals. Many
signals can be connected to one slot.</p>
<p>If a signal is connected to several slots, the slots are
activated in the same order as the order the connection was made,
when the signal is emitted.</p>
<p>The function returns true if it successfully connects the signal
to the slot. It will return false if it cannot create the
connection, for example, if <a href="qobject.html">QObject</a> is
unable to verify the existence of either <i>signal</i> or
<i>method</i>, or if their signatures aren't compatible.</p>
<p>By default, a signal is emitted for every connection you make;
two signals are emitted for duplicate connections. You can break
all of these connections with a single <a href="qobject.html#disconnect">disconnect</a>() call. If you pass the
<a href="qt.html#ConnectionType-enum">Qt.UniqueConnection</a>
<i>type</i>, the connection will only be made if it is not a
duplicate. If there is already a duplicate (exact same signal to
the exact same slot on the same objects), the connection will fail
and connect will return false.</p>
<p>The optional <i>type</i> parameter describes the type of
connection to establish. In particular, it determines whether a
particular signal is delivered to a slot immediately or queued for
delivery at a later time. If the signal is queued, the parameters
must be of types that are known to Qt's meta-object system, because
Qt needs to copy the arguments to store them in an event behind the
scenes. If you try to use a queued connection and get the error
message</p>
<pre class="highlightedCode brush: cpp">
 QObject.connect: Cannot queue arguments of type 'MyType'
 (Make sure 'MyType' is registered using qRegisterMetaType().)
</pre>
<p>call <a href="qmetatype.html#qRegisterMetaType">qRegisterMetaType</a>() to
register the data type before you establish the connection.</p>
<p><b>Note:</b> This function is <a href="threads-reentrancy.html#thread-safe">thread-safe</a>.</p>
<p>See also <a href="qobject.html#disconnect">disconnect</a>(),
<a href="qobject.html#sender">sender</a>(), and <a href="qmetatype.html#qRegisterMetaType">qRegisterMetaType</a>().</p>


<h3 class="fn"><a name="connect-2" />bool QObject.connect (<a href="qobject.html">QObject</a>, SIGNAL(), callable, <a href="qt.html#ConnectionType-enum">Qt.ConnectionType</a>&#160;=&#160;Qt.AutoConnection)</h3><p>This function overloads <a href="qobject.html#connect">connect</a>().</p>
<p>Connects <i>signal</i> from the <i>sender</i> object to this
object's <i>method</i>.</p>
<p>Equivalent to connect(<i>sender</i>, <i>signal</i>,
<tt>this</tt>, <i>method</i>, <i>type</i>).</p>
<p>Every connection you make emits a signal, so duplicate
connections emit two signals. You can break a connection using
<a href="qobject.html#disconnect">disconnect</a>().</p>
<p><b>Note:</b> This function is <a href="threads-reentrancy.html#thread-safe">thread-safe</a>.</p>
<p>See also <a href="qobject.html#disconnect">disconnect</a>().</p>


<h3 class="fn"><a name="connect-3" />bool QObject.connect (<i>self</i>, <a href="qobject.html">QObject</a>, SIGNAL(), SLOT(), <a href="qt.html#ConnectionType-enum">Qt.ConnectionType</a>&#160;=&#160;Qt.AutoConnection)</h3><h3 class="fn"><a name="connectNotify" />QObject.connectNotify (<i>self</i>, SIGNAL()&#160;<i>signal</i>)</h3><p>This virtual function is called when something has been
connected to <i>signal</i> in this object.</p>
<p>If you want to compare <i>signal</i> with a specific signal, use
<a href="qlatin1string.html">QLatin1String</a> and the
<tt>SIGNAL()</tt> macro as follows:</p>
<pre class="highlightedCode brush: cpp">
 if (QLatin1String(signal) == SIGNAL(valueChanged(int))) {
     <span class="comment">// signal is valueChanged(int)</span>
 }
</pre>
<p>If the signal contains multiple parameters or parameters that
contain spaces, call <a href="qmetaobject.html#normalizedSignature">QMetaObject.normalizedSignature</a>()
on the result of the <tt>SIGNAL()</tt> macro.</p>
<p><b>Warning:</b> This function violates the object-oriented
principle of modularity. However, it might be useful when you need
to perform expensive initialization only if something is connected
to a signal.</p>
<p>See also <a href="qobject.html#connect">connect</a>() and
<a href="qobject.html#disconnectNotify">disconnectNotify</a>().</p>


<h3 class="fn"><a name="customEvent" />QObject.customEvent (<i>self</i>, <a href="qevent.html">QEvent</a>)</h3><p>This event handler can be reimplemented in a subclass to receive
custom events. Custom events are user-defined events with a type
value at least as large as the <a href="qevent.html#Type-enum">QEvent.User</a> item of the <a href="qevent.html#Type-enum">QEvent.Type</a> enum, and is typically a
<a href="qevent.html">QEvent</a> subclass. The event is passed in
the <i>event</i> parameter.</p>
<p>See also <a href="qobject.html#event">event</a>() and <a href="qevent.html">QEvent</a>.</p>


<h3 class="fn"><a name="deleteLater" />QObject.deleteLater (<i>self</i>)</h3><p>This method is also a Qt slot with the C++ signature <tt>void deleteLater()</tt>.</p><p>Schedules this object for deletion.</p>
<p>The object will be deleted when control returns to the event
loop. If the event loop is not running when this function is called
(e.g. deleteLater() is called on an object before <a href="qcoreapplication.html#exec">QCoreApplication.exec</a>()), the
object will be deleted once the event loop is started.</p>
<p>Note that entering and leaving a new event loop (e.g., by
opening a modal dialog) will <i>not</i> perform the deferred
deletion; for the object to be deleted, the control must return to
the event loop from which deleteLater() was called.</p>
<p><b>Note:</b> It is safe to call this function more than once;
when the first deferred deletion event is delivered, any pending
events for the object are removed from the event queue.</p>
<p>See also <a href="qobject.html#destroyed">destroyed</a>() and
<a href="qpointer.html">QPointer</a>.</p>


<h3 class="fn"><a name="disconnect" />bool QObject.disconnect (<a href="qobject.html">QObject</a>, SIGNAL(), <a href="qobject.html">QObject</a>, SLOT())</h3><p>Disconnects <i>signal</i> in object <i>sender</i> from
<i>method</i> in object <i>receiver</i>. Returns true if the
connection is successfully broken; otherwise returns false.</p>
<p>A signal-slot connection is removed when either of the objects
involved are destroyed.</p>
<p>disconnect() is typically used in three ways, as the following
examples demonstrate.</p>
<ol class="1">
<li>Disconnect everything connected to an object's signals:
<pre class="highlightedCode brush: cpp">
 disconnect(myObject, 0, 0, 0);
</pre>
<p>equivalent to the non-static overloaded function</p>
<pre class="highlightedCode brush: cpp">
 myObject-&gt;disconnect();
</pre></li>
<li>Disconnect everything connected to a specific signal:
<pre class="highlightedCode brush: cpp">
 disconnect(myObject, SIGNAL(mySignal()), 0, 0);
</pre>
<p>equivalent to the non-static overloaded function</p>
<pre class="highlightedCode brush: cpp">
 myObject-&gt;disconnect(SIGNAL(mySignal()));
</pre></li>
<li>Disconnect a specific receiver:
<pre class="highlightedCode brush: cpp">
 disconnect(myObject, 0, myReceiver, 0);
</pre>
<p>equivalent to the non-static overloaded function</p>
<pre class="highlightedCode brush: cpp">
 myObject-&gt;disconnect(myReceiver);
</pre></li>
</ol>
<p>0 may be used as a wildcard, meaning "any signal", "any
receiving object", or "any slot in the receiving object",
respectively.</p>
<p>The <i>sender</i> may never be 0. (You cannot disconnect signals
from more than one object in a single call.)</p>
<p>If <i>signal</i> is 0, it disconnects <i>receiver</i> and
<i>method</i> from any signal. If not, only the specified signal is
disconnected.</p>
<p>If <i>receiver</i> is 0, it disconnects anything connected to
<i>signal</i>. If not, slots in objects other than <i>receiver</i>
are not disconnected.</p>
<p>If <i>method</i> is 0, it disconnects anything that is connected
to <i>receiver</i>. If not, only slots named <i>method</i> will be
disconnected, and all other slots are left alone. The <i>method</i>
must be 0 if <i>receiver</i> is left out, so you cannot disconnect
a specifically-named slot on all objects.</p>
<p><b>Note:</b> This function is <a href="threads-reentrancy.html#thread-safe">thread-safe</a>.</p>
<p>See also <a href="qobject.html#connect">connect</a>().</p>


<h3 class="fn"><a name="disconnect-2" />bool QObject.disconnect (<a href="qobject.html">QObject</a>, SIGNAL(), callable)</h3><p>This function overloads <a href="qobject.html#disconnect">disconnect</a>().</p>
<p>Disconnects <i>signal</i> from <i>method</i> of
<i>receiver</i>.</p>
<p>A signal-slot connection is removed when either of the objects
involved are destroyed.</p>
<p><b>Note:</b> This function is <a href="threads-reentrancy.html#thread-safe">thread-safe</a>.</p>


<h3 class="fn"><a name="disconnectNotify" />QObject.disconnectNotify (<i>self</i>, SIGNAL()&#160;<i>signal</i>)</h3><p>This virtual function is called when something has been
disconnected from <i>signal</i> in this object.</p>
<p>See <a href="qobject.html#connectNotify">connectNotify</a>() for
an example of how to compare <i>signal</i> with a specific
signal.</p>
<p><b>Warning:</b> This function violates the object-oriented
principle of modularity. However, it might be useful for optimizing
access to expensive resources.</p>
<p>See also <a href="qobject.html#disconnect">disconnect</a>() and
<a href="qobject.html#connectNotify">connectNotify</a>().</p>


<h3 class="fn"><a name="dumpObjectInfo" />QObject.dumpObjectInfo (<i>self</i>)</h3><p>Dumps information about signal connections, etc. for this object
to the debug output.</p>
<p>This function is useful for debugging, but does nothing if the
library has been compiled in release mode (i.e. without debugging
information).</p>
<p>See also <a href="qobject.html#dumpObjectTree">dumpObjectTree</a>().</p>


<h3 class="fn"><a name="dumpObjectTree" />QObject.dumpObjectTree (<i>self</i>)</h3><p>Dumps a tree of children to the debug output.</p>
<p>This function is useful for debugging, but does nothing if the
library has been compiled in release mode (i.e. without debugging
information).</p>
<p>See also <a href="qobject.html#dumpObjectInfo">dumpObjectInfo</a>().</p>


<h3 class="fn"><a name="dynamicPropertyNames" />list-of-QByteArray QObject.dynamicPropertyNames (<i>self</i>)</h3><p>Returns the names of all properties that were dynamically added
to the object using <a href="qobject.html#setProperty">setProperty</a>().</p>
<p>This function was introduced in Qt 4.2.</p>


<h3 class="fn"><a name="emit" />QObject.emit (<i>self</i>, SIGNAL(), ...)</h3><h3 class="fn"><a name="event" />bool QObject.event (<i>self</i>, <a href="qevent.html">QEvent</a>)</h3><p>This virtual function receives events to an object and should
return true if the event <i>e</i> was recognized and processed.</p>
<p>The event() function can be reimplemented to customize the
behavior of an object.</p>
<p>See also <a href="qobject.html#installEventFilter">installEventFilter</a>(),
<a href="qobject.html#timerEvent">timerEvent</a>(), <a href="qcoreapplication.html#sendEvent">QApplication.sendEvent</a>(),
<a href="qcoreapplication.html#postEvent">QApplication.postEvent</a>(),
and <a href="qwidget.html#event">QWidget.event</a>().</p>


<h3 class="fn"><a name="eventFilter" />bool QObject.eventFilter (<i>self</i>, <a href="qobject.html">QObject</a>, <a href="qevent.html">QEvent</a>)</h3><p>Filters events if this object has been installed as an event
filter for the <i>watched</i> object.</p>
<p>In your reimplementation of this function, if you want to filter
the <i>event</i> out, i.e. stop it being handled further, return
true; otherwise return false.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp">
 class MainWindow : public QMainWindow
 {
 public:
     MainWindow();

 protected:
     bool eventFilter(QObject *obj, QEvent *ev);

 private:
     QTextEdit *textEdit;
 };

 MainWindow.MainWindow()
 {
     textEdit = new QTextEdit;
     setCentralWidget(textEdit);

     textEdit-&gt;installEventFilter(this);
 }

 bool MainWindow.eventFilter(QObject *obj, QEvent *event)
 {
     if (obj == textEdit) {
         if (event-&gt;type() == QEvent.KeyPress) {
             QKeyEvent *keyEvent = static_cast&lt;QKeyEvent*&gt;(event);
             qDebug() &lt;&lt; "Ate key press" &lt;&lt; keyEvent-&gt;key();
             return true;
         } else {
             return false;
         }
     } else {
         <span class="comment">// pass the event on to the parent class</span>
         return QMainWindow.eventFilter(obj, event);
     }
 }
</pre>
<p>Notice in the example above that unhandled events are passed to
the base class's eventFilter() function, since the base class might
have reimplemented eventFilter() for its own internal purposes.</p>
<p><b>Warning:</b> If you delete the receiver object in this
function, be sure to return true. Otherwise, Qt will forward the
event to the deleted object and the program might crash.</p>
<p>See also <a href="qobject.html#installEventFilter">installEventFilter</a>().</p>


<h3 class="fn"><a name="findChild" />QObject QObject.findChild (<i>self</i>, type&#160;<i>type</i>, QString&#160;<i>name</i>&#160;=&#160;QString())</h3><p>Returns the child of this object that can be cast into type T
and that is called <i>name</i>, or 0 if there is no such object.
Omitting the <i>name</i> argument causes all object names to be
matched. The search is performed recursively.</p>
<p>If there is more than one child matching the search, the most
direct ancestor is returned. If there are several direct ancestors,
it is undefined which one will be returned. In that case, <a href="qobject.html#findChildren">findChildren</a>() should be used.</p>
<p>This example returns a child <a href="qpushbutton.html">QPushButton</a> of <tt>parentWidget</tt> named
<tt>"button1"</tt>:</p>
<pre class="highlightedCode brush: cpp">
 QPushButton *button = parentWidget-&gt;findChild&lt;QPushButton *&gt;("button1");
</pre>
<p>This example returns a <a href="qlistwidget.html">QListWidget</a> child of
<tt>parentWidget</tt>:</p>
<pre class="highlightedCode brush: cpp">
 QListWidget *list = parentWidget-&gt;findChild&lt;QListWidget *&gt;();
</pre>
<p><b>Warning:</b> This function is not available with MSVC 6. Use
<a href="qobject.html#qFindChild">qFindChild</a>() instead if you
need to support that version of the compiler.</p>
<p>See also <a href="qobject.html#findChildren">findChildren</a>()
and <a href="qobject.html#qFindChild">qFindChild</a>().</p>


<h3 class="fn"><a name="findChildren" />list-of-QObject QObject.findChildren (<i>self</i>, type&#160;<i>type</i>, QString&#160;<i>name</i>&#160;=&#160;QString())</h3><p>Returns all children of this object with the given <i>name</i>
that can be cast to type T, or an empty list if there are no such
objects. Omitting the <i>name</i> argument causes all object names
to be matched. The search is performed recursively.</p>
<p>The following example shows how to find a list of child <a href="qwidget.html">QWidget</a>s of the specified <tt>parentWidget</tt>
named <tt>widgetname</tt>:</p>
<pre class="highlightedCode brush: cpp">
 QList&lt;QWidget *&gt; widgets = parentWidget.findChildren&lt;QWidget *&gt;("widgetname");
</pre>
<p>This example returns all <tt>QPushButton</tt>s that are children
of <tt>parentWidget</tt>:</p>
<pre class="highlightedCode brush: cpp">
 QList&lt;QPushButton *&gt; allPButtons = parentWidget.findChildren&lt;QPushButton *&gt;();
</pre>
<p><b>Warning:</b> This function is not available with MSVC 6. Use
<a href="qobject.html#qFindChildren">qFindChildren</a>() instead if
you need to support that version of the compiler.</p>
<p>See also <a href="qobject.html#findChild">findChild</a>() and
<a href="qobject.html#qFindChildren">qFindChildren</a>().</p>


<h3 class="fn"><a name="findChildren-2" />list-of-QObject QObject.findChildren (<i>self</i>, type&#160;<i>type</i>, <a href="qregexp.html">QRegExp</a>&#160;<i>regExp</i>)</h3><p>This function overloads <a href="qobject.html#findChildren">findChildren</a>().</p>
<p>Returns the children of this object that can be cast to type T
and that have names matching the regular expression <i>regExp</i>,
or an empty list if there are no such objects. The search is
performed recursively.</p>
<p><b>Warning:</b> This function is not available with MSVC 6. Use
<a href="qobject.html#qFindChildren">qFindChildren</a>() instead if
you need to support that version of the compiler.</p>


<h3 class="fn"><a name="inherits" />bool QObject.inherits (<i>self</i>, str&#160;<i>classname</i>)</h3><p>Returns true if this object is an instance of a class that
inherits <i>className</i> or a <a href="qobject.html">QObject</a>
subclass that inherits <i>className</i>; otherwise returns
false.</p>
<p>A class is considered to inherit itself.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp">
 QTimer *timer = new QTimer;         <span class="comment">// QTimer inherits QObject</span>
 timer-&gt;inherits("QTimer");          <span class="comment">// returns true</span>
 timer-&gt;inherits("QObject");         <span class="comment">// returns true</span>
 timer-&gt;inherits("QAbstractButton"); <span class="comment">// returns false</span>

<span class="comment"> // QVBoxLayout inherits QObject and QLayoutItem</span>
 QVBoxLayout *layout = new QVBoxLayout;
 layout-&gt;inherits("QObject");        <span class="comment">// returns true</span>
 layout-&gt;inherits("QLayoutItem");    <span class="comment">// returns true (even though QLayoutItem is not a QObject)</span>
</pre>
<p>If you need to determine whether an object is an instance of a
particular class for the purpose of casting it, consider using
qobject_cast&lt;Type *&gt;(object) instead.</p>
<p>See also <a href="qobject.html#metaObject">metaObject</a>() and
<a href="qobject.html#qobject_cast">qobject_cast</a>().</p>


<h3 class="fn"><a name="installEventFilter" />QObject.installEventFilter (<i>self</i>, <a href="qobject.html">QObject</a>)</h3><p>Installs an event filter <i>filterObj</i> on this object. For
example:</p>
<pre class="highlightedCode brush: cpp">
 monitoredObj-&gt;installEventFilter(filterObj);
</pre>
<p>An event filter is an object that receives all events that are
sent to this object. The filter can either stop the event or
forward it to this object. The event filter <i>filterObj</i>
receives events via its <a href="qobject.html#eventFilter">eventFilter</a>() function. The <a href="qobject.html#eventFilter">eventFilter</a>() function must return
true if the event should be filtered, (i.e. stopped); otherwise it
must return false.</p>
<p>If multiple event filters are installed on a single object, the
filter that was installed last is activated first.</p>
<p>Here's a <tt>KeyPressEater</tt> class that eats the key presses
of its monitored objects:</p>
<pre class="highlightedCode brush: cpp">
 class KeyPressEater : public QObject
 {
     Q_OBJECT
     ...

 protected:
     bool eventFilter(QObject *obj, QEvent *event);
 };

 bool KeyPressEater.eventFilter(QObject *obj, QEvent *event)
 {
     if (event-&gt;type() == QEvent.KeyPress) {
         QKeyEvent *keyEvent = static_cast&lt;QKeyEvent *&gt;(event);
         qDebug("Ate key press %d", keyEvent-&gt;key());
         return true;
     } else {
         <span class="comment">// standard event processing</span>
         return QObject.eventFilter(obj, event);
     }
 }
</pre>
<p>And here's how to install it on two widgets:</p>
<pre class="highlightedCode brush: cpp">
 KeyPressEater *keyPressEater = new KeyPressEater(this);
 QPushButton *pushButton = new QPushButton(this);
 QListView *listView = new QListView(this);

 pushButton-&gt;installEventFilter(keyPressEater);
 listView-&gt;installEventFilter(keyPressEater);
</pre>
<p>The <a href="qshortcut.html">QShortcut</a> class, for example,
uses this technique to intercept shortcut key presses.</p>
<p><b>Warning:</b> If you delete the receiver object in your
<a href="qobject.html#eventFilter">eventFilter</a>() function, be
sure to return true. If you return false, Qt sends the event to the
deleted object and the program will crash.</p>
<p>Note that the filtering object must be in the same thread as
this object. If <i>filterObj</i> is in a different thread, this
function does nothing. If either <i>filterObj</i> or this object
are moved to a different thread after calling this function, the
event filter will not be called until both objects have the same
thread affinity again (it is <i>not</i> removed).</p>
<p>See also <a href="qobject.html#removeEventFilter">removeEventFilter</a>(), <a href="qobject.html#eventFilter">eventFilter</a>(), and <a href="qobject.html#event">event</a>().</p>


<h3 class="fn"><a name="isWidgetType" />bool QObject.isWidgetType (<i>self</i>)</h3><p>Returns true if the object is a widget; otherwise returns
false.</p>
<p>Calling this function is equivalent to calling
inherits("<a href="qwidget.html">QWidget</a>"), except that it is
much faster.</p>


<h3 class="fn"><a name="killTimer" />QObject.killTimer (<i>self</i>, int&#160;<i>id</i>)</h3><p>Kills the timer with timer identifier, <i>id</i>.</p>
<p>The timer identifier is returned by <a href="qobject.html#startTimer">startTimer</a>() when a timer event is
started.</p>
<p>See also <a href="qobject.html#timerEvent">timerEvent</a>() and
<a href="qobject.html#startTimer">startTimer</a>().</p>


<h3 class="fn"><a name="metaObject" /><a href="qmetaobject.html">QMetaObject</a> QObject.metaObject (<i>self</i>)</h3><p>Returns a pointer to the meta-object of this object.</p>
<p>A meta-object contains information about a class that inherits
<a href="qobject.html">QObject</a>, e.g. class name, superclass
name, properties, signals and slots. Every <a href="qobject.html">QObject</a> subclass that contains the <a href="qobject.html#Q_OBJECT">Q_OBJECT</a> macro will have a
meta-object.</p>
<p>The meta-object information is required by the signal/slot
connection mechanism and the property system. The <a href="qobject.html#inherits">inherits</a>() function also makes use of
the meta-object.</p>
<p>If you have no pointer to an actual object instance but still
want to access the meta-object of a class, you can use <a href="qobject.html#staticMetaObject-var">staticMetaObject</a>.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp">
 QObject *obj = new QPushButton;
 obj-&gt;metaObject()-&gt;className();             <span class="comment">// returns "QPushButton"</span>

 QPushButton.staticMetaObject.className();  <span class="comment">// returns "QPushButton"</span>
</pre>
<p>See also <a href="qobject.html#staticMetaObject-var">staticMetaObject</a>.</p>


<h3 class="fn"><a name="moveToThread" />QObject.moveToThread (<i>self</i>, <a href="qthread.html">QThread</a>&#160;<i>thread</i>)</h3><p>Changes the thread affinity for this object and its children.
The object cannot be moved if it has a parent. Event processing
will continue in the <i>targetThread</i>.</p>
<p>To move an object to the main thread, use <a href="qcoreapplication.html#instance">QApplication.instance</a>() to
retrieve a pointer to the current application, and then use
<a href="qobject.html#thread">QApplication.thread</a>() to
retrieve the thread in which the application lives. For
example:</p>
<pre class="highlightedCode brush: cpp">
 myObject-&gt;moveToThread(QApplication.instance()-&gt;thread());
</pre>
<p>If <i>targetThread</i> is zero, all event processing for this
object and its children stops.</p>
<p>Note that all active timers for the object will be reset. The
timers are first stopped in the current thread and restarted (with
the same interval) in the <i>targetThread</i>. As a result,
constantly moving an object between threads can postpone timer
events indefinitely.</p>
<p>A <a href="qevent.html#Type-enum">QEvent.ThreadChange</a> event
is sent to this object just before the thread affinity is changed.
You can handle this event to perform any special processing. Note
that any new events that are posted to this object will be handled
in the <i>targetThread</i>.</p>
<p><b>Warning:</b> This function is <i>not</i> thread-safe; the
current thread must be same as the current thread affinity. In
other words, this function can only "push" an object from the
current thread to another thread, it cannot "pull" an object from
any arbitrary thread to the current thread.</p>
<p>See also <a href="qobject.html#thread">thread</a>().</p>


<h3 class="fn"><a name="objectName" />QString QObject.objectName (<i>self</i>)</h3><h3 class="fn"><a name="parent" /><a href="qobject.html">QObject</a> QObject.parent (<i>self</i>)</h3><p>Returns a pointer to the parent object.</p>
<p>See also <a href="qobject.html#setParent">setParent</a>() and
<a href="qobject.html#children">children</a>().</p>


<h3 class="fn"><a name="property" />QVariant QObject.property (<i>self</i>, str&#160;<i>name</i>)</h3><p>Returns the value of the object's <i>name</i> property.</p>
<p>If no such property exists, the returned variant is invalid.</p>
<p>Information about all available properties is provided through
the <a href="qobject.html#metaObject">metaObject</a>() and <a href="qobject.html#dynamicPropertyNames">dynamicPropertyNames</a>().</p>
<p>See also <a href="qobject.html#setProperty">setProperty</a>(),
<a href="qvariant.html#isValid">QVariant.isValid</a>(), <a href="qobject.html#metaObject">metaObject</a>(), and <a href="qobject.html#dynamicPropertyNames">dynamicPropertyNames</a>().</p>


<h3 class="fn"><a name="pyqtConfigure" />QObject.pyqtConfigure (<i>self</i>, object)</h3><h3 class="fn"><a name="receivers" />int QObject.receivers (<i>self</i>, SIGNAL()&#160;<i>signal</i>)</h3><p>Returns the number of receivers connected to the
<i>signal</i>.</p>
<p>Since both slots and signals can be used as receivers for
signals, and the same connections can be made many times, the
number of receivers is the same as the number of connections made
from this signal.</p>
<p>When calling this function, you can use the <tt>SIGNAL()</tt>
macro to pass a specific signal:</p>
<pre class="highlightedCode brush: cpp">
 if (receivers(SIGNAL(valueChanged(QByteArray))) &gt; 0) {
     QByteArray data;
     get_the_value(&amp;data);       <span class="comment">// expensive operation</span>
     emit valueChanged(data);
 }
</pre>
<p>As the code snippet above illustrates, you can use this function
to avoid emitting a signal that nobody listens to.</p>
<p><b>Warning:</b> This function violates the object-oriented
principle of modularity. However, it might be useful when you need
to perform expensive initialization only if something is connected
to a signal.</p>


<h3 class="fn"><a name="removeEventFilter" />QObject.removeEventFilter (<i>self</i>, <a href="qobject.html">QObject</a>)</h3><p>Removes an event filter object <i>obj</i> from this object. The
request is ignored if such an event filter has not been
installed.</p>
<p>All event filters for this object are automatically removed when
this object is destroyed.</p>
<p>It is always safe to remove an event filter, even during event
filter activation (i.e. from the <a href="qobject.html#eventFilter">eventFilter</a>() function).</p>
<p>See also <a href="qobject.html#installEventFilter">installEventFilter</a>(),
<a href="qobject.html#eventFilter">eventFilter</a>(), and <a href="qobject.html#event">event</a>().</p>


<h3 class="fn"><a name="sender" /><a href="qobject.html">QObject</a> QObject.sender (<i>self</i>)</h3><p>Returns a pointer to the object that sent the signal, if called
in a slot activated by a signal; otherwise it returns 0. The
pointer is valid only during the execution of the slot that calls
this function from this object's thread context.</p>
<p>The pointer returned by this function becomes invalid if the
sender is destroyed, or if the slot is disconnected from the
sender's signal.</p>
<p><b>Warning:</b> This function violates the object-oriented
principle of modularity. However, getting access to the sender
might be useful when many signals are connected to a single
slot.</p>
<p><b>Warning:</b> As mentioned above, the return value of this
function is not valid when the slot is called via a <a href="qt.html#ConnectionType-enum">Qt.DirectConnection</a> from a
thread different from this object's thread. Do not use this
function in this type of scenario.</p>
<p>See also <a href="qsignalmapper.html">QSignalMapper</a>.</p>


<h3 class="fn"><a name="setObjectName" />QObject.setObjectName (<i>self</i>, QString&#160;<i>name</i>)</h3><h3 class="fn"><a name="setParent" />QObject.setParent (<i>self</i>, <a href="qobject.html">QObject</a>)</h3><p>The <i>QObject</i> argument, if not None, causes <i>self</i> to be owned by Qt instead of PyQt.</p><p>Makes the object a child of <i>parent</i>.</p>
<p>See also <a href="qobject.html#parent">parent</a>() and <a href="qwidget.html#setParent">QWidget.setParent</a>().</p>


<h3 class="fn"><a name="setProperty" />bool QObject.setProperty (<i>self</i>, str&#160;<i>name</i>, QVariant&#160;<i>value</i>)</h3><p>Sets the value of the object's <i>name</i> property to
<i>value</i>.</p>
<p>If the property is defined in the class using Q_PROPERTY then
true is returned on success and false otherwise. If the property is
not defined using Q_PROPERTY, and therefore not listed in the
meta-object, it is added as a dynamic property and false is
returned.</p>
<p>Information about all available properties is provided through
the <a href="qobject.html#metaObject">metaObject</a>() and <a href="qobject.html#dynamicPropertyNames">dynamicPropertyNames</a>().</p>
<p>Dynamic properties can be queried again using <a href="qobject.html#property">property</a>() and can be removed by
setting the property value to an invalid <a href="qvariant.html">QVariant</a>. Changing the value of a dynamic
property causes a <a href="qdynamicpropertychangeevent.html">QDynamicPropertyChangeEvent</a>
to be sent to the object.</p>
<p><b>Note:</b> Dynamic properties starting with "_q_" are reserved
for internal purposes.</p>
<p>See also <a href="qobject.html#property">property</a>(),
<a href="qobject.html#metaObject">metaObject</a>(), and <a href="qobject.html#dynamicPropertyNames">dynamicPropertyNames</a>().</p>


<h3 class="fn"><a name="signalsBlocked" />bool QObject.signalsBlocked (<i>self</i>)</h3><p>Returns true if signals are blocked; otherwise returns
false.</p>
<p>Signals are not blocked by default.</p>
<p>See also <a href="qobject.html#blockSignals">blockSignals</a>().</p>


<h3 class="fn"><a name="startTimer" />int QObject.startTimer (<i>self</i>, int&#160;<i>interval</i>)</h3><p>Starts a timer and returns a timer identifier, or returns zero
if it could not start a timer.</p>
<p>A timer event will occur every <i>interval</i> milliseconds
until <a href="qobject.html#killTimer">killTimer</a>() is called.
If <i>interval</i> is 0, then the timer event occurs once every
time there are no more window system events to process.</p>
<p>The virtual <a href="qobject.html#timerEvent">timerEvent</a>()
function is called with the <a href="qtimerevent.html">QTimerEvent</a> event parameter class when a
timer event occurs. Reimplement this function to get timer
events.</p>
<p>If multiple timers are running, the <a href="qtimerevent.html#timerId">QTimerEvent.timerId</a>() can be used
to find out which timer was activated.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp">
 class MyObject : public QObject
 {
     Q_OBJECT

 public:
     MyObject(QObject *parent = 0);

 protected:
     void timerEvent(QTimerEvent *event);
 };

 MyObject.MyObject(QObject *parent)
     : QObject(parent)
 {
     startTimer(50);     <span class="comment">// 50-millisecond timer</span>
     startTimer(1000);   <span class="comment">// 1-second timer</span>
     startTimer(60000);  <span class="comment">// 1-minute timer</span>
 }

 void MyObject.timerEvent(QTimerEvent *event)
 {
     qDebug() &lt;&lt; "Timer ID:" &lt;&lt; event-&gt;timerId();
 }
</pre>
<p>Note that <a href="qtimer.html">QTimer</a>'s accuracy depends on
the underlying operating system and hardware. Most platforms
support an accuracy of 20 milliseconds; some provide more. If Qt is
unable to deliver the requested number of timer events, it will
silently discard some.</p>
<p>The <a href="qtimer.html">QTimer</a> class provides a high-level
programming interface with single-shot timers and timer signals
instead of events. There is also a <a href="qbasictimer.html">QBasicTimer</a> class that is more lightweight
than <a href="qtimer.html">QTimer</a> and less clumsy than using
timer IDs directly.</p>
<p>See also <a href="qobject.html#timerEvent">timerEvent</a>(),
<a href="qobject.html#killTimer">killTimer</a>(), and <a href="qtimer.html#singleShot">QTimer.singleShot</a>().</p>


<h3 class="fn"><a name="thread" /><a href="qthread.html">QThread</a> QObject.thread (<i>self</i>)</h3><p>Returns the thread in which the object lives.</p>
<p>See also <a href="qobject.html#moveToThread">moveToThread</a>().</p>


<h3 class="fn"><a name="timerEvent" />QObject.timerEvent (<i>self</i>, <a href="qtimerevent.html">QTimerEvent</a>)</h3><p>This event handler can be reimplemented in a subclass to receive
timer events for the object.</p>
<p><a href="qtimer.html">QTimer</a> provides a higher-level
interface to the timer functionality, and also more general
information about timers. The timer event is passed in the
<i>event</i> parameter.</p>
<p>See also <a href="qobject.html#startTimer">startTimer</a>(),
<a href="qobject.html#killTimer">killTimer</a>(), and <a href="qobject.html#event">event</a>().</p>


<h3 class="fn"><a name="tr" />QString QObject.tr (<i>self</i>, str&#160;<i>sourceText</i>, str&#160;<i>disambiguation</i>&#160;=&#160;None, int&#160;<i>n</i>&#160;=&#160;-1)</h3><p>Returns a translated version of <i>sourceText</i>, optionally
based on a <i>disambiguation</i> string and value of <i>n</i> for
strings containing plurals; otherwise returns <i>sourceText</i>
itself if no appropriate translated string is available.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp">
 void MainWindow.createMenus()
 {
     fileMenu = menuBar()-&gt;addMenu(tr("&amp;File"));
     ...
</pre>
<p>If the same <i>sourceText</i> is used in different roles within
the same context, an additional identifying string may be passed in
<i>disambiguation</i> (0 by default). In Qt 4.4 and earlier, this
was the preferred way to pass comments to translators.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp">
 MyWindow.MyWindow()
 {
     QLabel *senderLabel = new QLabel(tr("Name:"));
     QLabel *recipientLabel = new QLabel(tr("Name:", "recipient"));
     ...
</pre>
<p>See <a href="i18n-source-translation.html">Writing Source Code
for Translation</a> for a detailed description of Qt's translation
mechanisms in general, and the <a href="i18n-source-translation.html#disambiguation">Disambiguation</a>
section for information on disambiguation.</p>
<p><b>Warning:</b> This method is reentrant only if all translators
are installed <i>before</i> calling this method. Installing or
removing translators while performing translations is not
supported. Doing so will probably result in crashes or other
undesirable behavior.</p>
<p>See also <a href="qobject.html#trUtf8">trUtf8</a>(), <a href="qcoreapplication.html#translate">QApplication.translate</a>(),
<a href="qtextcodec.html#setCodecForTr">QTextCodec.setCodecForTr</a>(),
and <a href="internationalization.html">Internationalization with
Qt</a>.</p>


<h3 class="fn"><a name="trUtf8" />QString QObject.trUtf8 (<i>self</i>, str&#160;<i>sourceText</i>, str&#160;<i>disambiguation</i>&#160;=&#160;None, int&#160;<i>n</i>&#160;=&#160;-1)</h3><p>Returns a translated version of <i>sourceText</i>, or
QString.fromUtf8(<i>sourceText</i>) if there is no appropriate
version. It is otherwise identical to tr(<i>sourceText</i>,
<i>disambiguation</i>, <i>n</i>).</p>
<p>Note that using the Utf8 variants of the translation functions
is not required if <tt>CODECFORTR</tt> is already set to UTF-8 in
the qmake project file and QTextCodec.setCodecForTr("UTF-8") is
used.</p>
<p><b>Warning:</b> This method is reentrant only if all translators
are installed <i>before</i> calling this method. Installing or
removing translators while performing translations is not
supported. Doing so will probably result in crashes or other
undesirable behavior.</p>
<p><b>Warning:</b> For portability reasons, we recommend that you
use escape sequences for specifying non-ASCII characters in string
literals to trUtf8(). For example:</p>
<pre class="highlightedCode brush: cpp">
 label-&gt;setText(tr("F\374r \310lise"));
</pre>
<p>See also <a href="qobject.html#tr">tr</a>(), <a href="qcoreapplication.html#translate">QApplication.translate</a>(),
and <a href="internationalization.html">Internationalization with
Qt</a>.</p>
<h3 class="fn"><a name="__getattr__" />object QObject.__getattr__ (<i>self</i>, str&#160;<i>name</i>)</h3><hr /><h2>Qt Signal Documentation</h2><h3 class="fn"><a name="destroyed" />void destroyed (QObject * = 0)</h3><p>This is the default overload of this signal.</p><p>This signal is emitted immediately before the object <i>obj</i>
is destroyed, and can not be blocked.</p>
<p>All the objects's children are destroyed immediately after this
signal is emitted.</p>
<p>See also <a href="qobject.html#deleteLater">deleteLater</a>()
and <a href="qpointer.html">QPointer</a>.</p>


<hr /><h2>Member Documentation</h2><h3 class="fn"><a name="staticMetaObject-var" /><a href="qmetaobject.html">QMetaObject</a> staticMetaObject</h3><p>This member should be treated as a constant.</p><p>This variable stores the meta-object for the class.</p>
<p>A meta-object contains information about a class that inherits
<a href="qobject.html">QObject</a>, e.g. class name, superclass
name, properties, signals and slots. Every class that contains the
<a href="qobject.html#Q_OBJECT">Q_OBJECT</a> macro will also have a
meta-object.</p>
<p>The meta-object information is required by the signal/slot
connection mechanism and the property system. The <a href="qobject.html#inherits">inherits</a>() function also makes use of
the meta-object.</p>
<p>If you have a pointer to an object, you can use <a href="qobject.html#metaObject">metaObject</a>() to retrieve the
meta-object associated with that object.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp">
 QPushButton.staticMetaObject.className();  <span class="comment">// returns "QPushButton"</span>

 QObject *obj = new QPushButton;
 obj-&gt;metaObject()-&gt;className();             <span class="comment">// returns "QPushButton"</span>
</pre>
<p>See also <a href="qobject.html#metaObject">metaObject</a>().</p>
<address><hr /><div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address"><td align="left" width="25%">PyQt&#160;4.8.3 for Windows</td><td align="center" width="50%">Copyright &#169; <a href="http://www.riverbankcomputing.com">Riverbank&#160;Computing&#160;Ltd</a> and <a href="http://www.qtsoftware.com">Nokia</a> 2011</td><td align="right" width="25%">Qt&#160;4.7.1</td></tr></table></div></address></body></html>