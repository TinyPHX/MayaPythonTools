<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html><head><title>QByteArray Class Reference</title><style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style></head><body><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr /><td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" width="32" /></td><td width="1">&#160;&#160;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&#160;&#183; <a href="classes.html"><font color="#004faf">All Classes</font></a>&#160;&#183; <a href="modules.html"><font color="#004faf">Modules</font></a></td></table><h1 align="center">QByteArray Class Reference<br /><sup><sup>[<a href="qtcore.html">QtCore</a> module]</sup></sup></h1><p>The QByteArray class provides an array of bytes. <a href="#details">More...</a></p>

<h3>Methods</h3><ul><li><div class="fn" /><b><a href="qbytearray.html#QByteArray">__init__</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qbytearray.html#QByteArray-2">__init__</a></b> (<i>self</i>, int&#160;<i>size</i>, str&#160;<i>c</i>)</li><li><div class="fn" /><b><a href="qbytearray.html#QByteArray-3">__init__</a></b> (<i>self</i>, QByteArray&#160;<i>a</i>)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#append">append</a></b> (<i>self</i>, QByteArray&#160;<i>a</i>)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#append-2">append</a></b> (<i>self</i>, QString&#160;<i>s</i>)</li><li><div class="fn" />str <b><a href="qbytearray.html#at">at</a></b> (<i>self</i>, int&#160;<i>i</i>)</li><li><div class="fn" />int <b><a href="qbytearray.html#capacity">capacity</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qbytearray.html#chop">chop</a></b> (<i>self</i>, int&#160;<i>n</i>)</li><li><div class="fn" /><b><a href="qbytearray.html#clear">clear</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qbytearray.html#contains">contains</a></b> (<i>self</i>, QByteArray&#160;<i>a</i>)</li><li><div class="fn" />int <b><a href="qbytearray.html#count">count</a></b> (<i>self</i>, QByteArray&#160;<i>a</i>)</li><li><div class="fn" />int <b><a href="qbytearray.html#count-2">count</a></b> (<i>self</i>)</li><li><div class="fn" />str <b><a href="qbytearray.html#data">data</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qbytearray.html#endsWith">endsWith</a></b> (<i>self</i>, QByteArray&#160;<i>a</i>)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#fill">fill</a></b> (<i>self</i>, str&#160;<i>ch</i>, int&#160;<i>size</i>&#160;=&#160;-1)</li><li><div class="fn" />int <b><a href="qbytearray.html#indexOf">indexOf</a></b> (<i>self</i>, QByteArray&#160;<i>ba</i>, int&#160;<i>from</i>&#160;=&#160;0)</li><li><div class="fn" />int <b><a href="qbytearray.html#indexOf-2">indexOf</a></b> (<i>self</i>, QString&#160;<i>str</i>, int&#160;<i>from</i>&#160;=&#160;0)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#insert">insert</a></b> (<i>self</i>, int&#160;<i>i</i>, QByteArray&#160;<i>a</i>)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#insert-2">insert</a></b> (<i>self</i>, int&#160;<i>i</i>, QString&#160;<i>s</i>)</li><li><div class="fn" />bool <b><a href="qbytearray.html#isEmpty">isEmpty</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qbytearray.html#isNull">isNull</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qbytearray.html#lastIndexOf">lastIndexOf</a></b> (<i>self</i>, QByteArray&#160;<i>ba</i>, int&#160;<i>from</i>&#160;=&#160;-1)</li><li><div class="fn" />int <b><a href="qbytearray.html#lastIndexOf-2">lastIndexOf</a></b> (<i>self</i>, QString&#160;<i>str</i>, int&#160;<i>from</i>&#160;=&#160;-1)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#left">left</a></b> (<i>self</i>, int&#160;<i>len</i>)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#leftJustified">leftJustified</a></b> (<i>self</i>, int&#160;<i>width</i>, str&#160;<i>fill</i>&#160;=&#160;' ', bool&#160;<i>truncate</i>&#160;=&#160;False)</li><li><div class="fn" />int <b><a href="qbytearray.html#length">length</a></b> (<i>self</i>)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#mid">mid</a></b> (<i>self</i>, int&#160;<i>pos</i>, int&#160;<i>length</i>&#160;=&#160;-1)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#prepend">prepend</a></b> (<i>self</i>, QByteArray&#160;<i>a</i>)</li><li><div class="fn" /><b><a href="qbytearray.html#push_back">push_back</a></b> (<i>self</i>, QByteArray&#160;<i>a</i>)</li><li><div class="fn" /><b><a href="qbytearray.html#push_front">push_front</a></b> (<i>self</i>, QByteArray&#160;<i>a</i>)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#remove">remove</a></b> (<i>self</i>, int&#160;<i>index</i>, int&#160;<i>len</i>)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#repeated">repeated</a></b> (<i>self</i>, int&#160;<i>times</i>)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#replace">replace</a></b> (<i>self</i>, int&#160;<i>index</i>, int&#160;<i>len</i>, QByteArray&#160;<i>s</i>)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#replace-2">replace</a></b> (<i>self</i>, QByteArray&#160;<i>before</i>, QByteArray&#160;<i>after</i>)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#replace-3">replace</a></b> (<i>self</i>, QString&#160;<i>before</i>, QByteArray&#160;<i>after</i>)</li><li><div class="fn" /><b><a href="qbytearray.html#reserve">reserve</a></b> (<i>self</i>, int&#160;<i>size</i>)</li><li><div class="fn" /><b><a href="qbytearray.html#resize">resize</a></b> (<i>self</i>, int&#160;<i>size</i>)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#right">right</a></b> (<i>self</i>, int&#160;<i>len</i>)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#rightJustified">rightJustified</a></b> (<i>self</i>, int&#160;<i>width</i>, str&#160;<i>fill</i>&#160;=&#160;' ', bool&#160;<i>truncate</i>&#160;=&#160;False)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#setNum">setNum</a></b> (<i>self</i>, int&#160;<i>n</i>, int&#160;<i>base</i>&#160;=&#160;10)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#setNum-2">setNum</a></b> (<i>self</i>, float&#160;<i>n</i>, str&#160;<i>format</i>&#160;=&#160;'g', int&#160;<i>precision</i>&#160;=&#160;6)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#setNum-3">setNum</a></b> (<i>self</i>, int&#160;<i>n</i>, int&#160;<i>base</i>&#160;=&#160;10)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#setNum-4">setNum</a></b> (<i>self</i>, int&#160;<i>n</i>, int&#160;<i>base</i>&#160;=&#160;10)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#simplified">simplified</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qbytearray.html#size">size</a></b> (<i>self</i>)</li><li><div class="fn" />list-of-QByteArray <b><a href="qbytearray.html#split">split</a></b> (<i>self</i>, str&#160;<i>sep</i>)</li><li><div class="fn" /><b><a href="qbytearray.html#squeeze">squeeze</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qbytearray.html#startsWith">startsWith</a></b> (<i>self</i>, QByteArray&#160;<i>a</i>)</li><li><div class="fn" /><b><a href="qbytearray.html#swap">swap</a></b> (<i>self</i>, QByteArray&#160;<i>other</i>)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#toBase64">toBase64</a></b> (<i>self</i>)</li><li><div class="fn" />(float, bool&#160;<i>ok</i>) <b><a href="qbytearray.html#toDouble">toDouble</a></b> (<i>self</i>)</li><li><div class="fn" />(float, bool&#160;<i>ok</i>) <b><a href="qbytearray.html#toFloat">toFloat</a></b> (<i>self</i>)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#toHex">toHex</a></b> (<i>self</i>)</li><li><div class="fn" />(int, bool&#160;<i>ok</i>) <b><a href="qbytearray.html#toInt">toInt</a></b> (<i>self</i>, int&#160;<i>base</i>&#160;=&#160;10)</li><li><div class="fn" />(int, bool&#160;<i>ok</i>) <b><a href="qbytearray.html#toLong">toLong</a></b> (<i>self</i>, int&#160;<i>base</i>&#160;=&#160;10)</li><li><div class="fn" />(int, bool&#160;<i>ok</i>) <b><a href="qbytearray.html#toLongLong">toLongLong</a></b> (<i>self</i>, int&#160;<i>base</i>&#160;=&#160;10)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#toLower">toLower</a></b> (<i>self</i>)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#toPercentEncoding">toPercentEncoding</a></b> (<i>self</i>, QByteArray&#160;<i>exclude</i>&#160;=&#160;QByteArray(), QByteArray&#160;<i>include</i>&#160;=&#160;QByteArray(), str&#160;<i>percent</i>&#160;=&#160;'%')</li><li><div class="fn" />(int, bool&#160;<i>ok</i>) <b><a href="qbytearray.html#toShort">toShort</a></b> (<i>self</i>, int&#160;<i>base</i>&#160;=&#160;10)</li><li><div class="fn" />(int, bool&#160;<i>ok</i>) <b><a href="qbytearray.html#toUInt">toUInt</a></b> (<i>self</i>, int&#160;<i>base</i>&#160;=&#160;10)</li><li><div class="fn" />(int, bool&#160;<i>ok</i>) <b><a href="qbytearray.html#toULong">toULong</a></b> (<i>self</i>, int&#160;<i>base</i>&#160;=&#160;10)</li><li><div class="fn" />(int, bool&#160;<i>ok</i>) <b><a href="qbytearray.html#toULongLong">toULongLong</a></b> (<i>self</i>, int&#160;<i>base</i>&#160;=&#160;10)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#toUpper">toUpper</a></b> (<i>self</i>)</li><li><div class="fn" />(int, bool&#160;<i>ok</i>) <b><a href="qbytearray.html#toUShort">toUShort</a></b> (<i>self</i>, int&#160;<i>base</i>&#160;=&#160;10)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#trimmed">trimmed</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qbytearray.html#truncate">truncate</a></b> (<i>self</i>, int&#160;<i>pos</i>)</li></ul><h3>Static Methods</h3><ul><li><div class="fn" />QByteArray <b><a href="qbytearray.html#fromBase64">fromBase64</a></b> (QByteArray&#160;<i>base64</i>)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#fromHex">fromHex</a></b> (QByteArray&#160;<i>hexEncoded</i>)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#fromPercentEncoding">fromPercentEncoding</a></b> (QByteArray&#160;<i>input</i>, str&#160;<i>percent</i>&#160;=&#160;'%')</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#fromRawData">fromRawData</a></b> (str)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#number">number</a></b> (int&#160;<i>n</i>, int&#160;<i>base</i>&#160;=&#160;10)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#number-2">number</a></b> (float&#160;<i>n</i>, str&#160;<i>format</i>&#160;=&#160;'g', int&#160;<i>precision</i>&#160;=&#160;6)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#number-3">number</a></b> (int&#160;<i>n</i>, int&#160;<i>base</i>&#160;=&#160;10)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#number-4">number</a></b> (int&#160;<i>n</i>, int&#160;<i>base</i>&#160;=&#160;10)</li></ul><h3>Special Methods</h3><ul><li><div class="fn" />QByteArray <b><a href="qbytearray.html#__add__">__add__</a></b> (<i>self</i>, QByteArray&#160;<i>a2</i>)</li><li><div class="fn" />QString <b><a href="qbytearray.html#__add__-2">__add__</a></b> (<i>self</i>, QString&#160;<i>s</i>)</li><li><div class="fn" />int <b><a href="qbytearray.html#__contains__">__contains__</a></b> (<i>self</i>, QByteArray&#160;<i>a</i>)</li><li><div class="fn" />bool <b><a href="qbytearray.html#__eq__">__eq__</a></b> (<i>self</i>, QString&#160;<i>s2</i>)</li><li><div class="fn" />bool <b><a href="qbytearray.html#__eq__-2">__eq__</a></b> (<i>self</i>, QByteArray&#160;<i>a2</i>)</li><li><div class="fn" />bool <b><a href="qbytearray.html#__ge__">__ge__</a></b> (<i>self</i>, QString&#160;<i>s2</i>)</li><li><div class="fn" />bool <b><a href="qbytearray.html#__ge__-2">__ge__</a></b> (<i>self</i>, QByteArray&#160;<i>a2</i>)</li><li><div class="fn" />str <b><a href="qbytearray.html#__getitem__">__getitem__</a></b> (<i>self</i>, int&#160;<i>i</i>)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#__getitem__-2">__getitem__</a></b> (<i>self</i>, slice&#160;<i>slice</i>)</li><li><div class="fn" />bool <b><a href="qbytearray.html#__gt__">__gt__</a></b> (<i>self</i>, QString&#160;<i>s2</i>)</li><li><div class="fn" />bool <b><a href="qbytearray.html#__gt__-2">__gt__</a></b> (<i>self</i>, QByteArray&#160;<i>a2</i>)</li><li><div class="fn" />int <b><a href="qbytearray.html#__hash__">__hash__</a></b> (<i>self</i>)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#__iadd__">__iadd__</a></b> (<i>self</i>, QByteArray&#160;<i>a</i>)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#__iadd__-2">__iadd__</a></b> (<i>self</i>, QString&#160;<i>s</i>)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#__imul__">__imul__</a></b> (<i>self</i>, int&#160;<i>m</i>)</li><li><div class="fn" />bool <b><a href="qbytearray.html#__le__">__le__</a></b> (<i>self</i>, QString&#160;<i>s2</i>)</li><li><div class="fn" />bool <b><a href="qbytearray.html#__le__-2">__le__</a></b> (<i>self</i>, QByteArray&#160;<i>a2</i>)</li><li><div class="fn" /> <b><a href="qbytearray.html#__len__">__len__</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qbytearray.html#__lt__">__lt__</a></b> (<i>self</i>, QString&#160;<i>s2</i>)</li><li><div class="fn" />bool <b><a href="qbytearray.html#__lt__-2">__lt__</a></b> (<i>self</i>, QByteArray&#160;<i>a2</i>)</li><li><div class="fn" />QByteArray <b><a href="qbytearray.html#__mul__">__mul__</a></b> (<i>self</i>, int&#160;<i>m</i>)</li><li><div class="fn" />bool <b><a href="qbytearray.html#__ne__">__ne__</a></b> (<i>self</i>, QString&#160;<i>s2</i>)</li><li><div class="fn" />bool <b><a href="qbytearray.html#__ne__-2">__ne__</a></b> (<i>self</i>, QByteArray&#160;<i>a2</i>)</li><li><div class="fn" />str <b><a href="qbytearray.html#__repr__">__repr__</a></b> (<i>self</i>)</li><li><div class="fn" />str <b><a href="qbytearray.html#__str__">__str__</a></b> (<i>self</i>)</li></ul><a name="details" /><hr /><h2>Detailed Description</h2><p>This class can be pickled.</p><p>A Python string object
    may be used whenever a
    <a href="qbytearray.html">QByteArray</a>
    is expected.</p>
  <p>The QByteArray class provides an array of bytes.</p>
<p>QByteArray can be used to store both raw bytes (including '\0's)
and traditional 8-bit '\0'-terminated strings. Using QByteArray is
much more convenient than using <tt>const char *</tt>. Behind the
scenes, it always ensures that the data is followed by a '\0'
terminator, and uses <a href="implicit-sharing.html">implicit
sharing</a> (copy-on-write) to reduce memory usage and avoid
needless copying of data.</p>
<p>In addition to QByteArray, Qt also provides the <a href="qstring.html">QString</a> class to store string data. For most
purposes, <a href="qstring.html">QString</a> is the class you want
to use. It stores 16-bit Unicode characters, making it easy to
store non-ASCII/non-Latin-1 characters in your application.
Furthermore, <a href="qstring.html">QString</a> is used throughout
in the Qt API. The two main cases where QByteArray is appropriate
are when you need to store raw binary data, and when memory
conservation is critical (e.g., with Qt for Embedded Linux).</p>
<p>One way to initialize a QByteArray is simply to pass a <tt>const
char *</tt> to its constructor. For example, the following code
creates a byte array of size 5 containing the data "Hello":</p>
<pre class="cpp">
 <span class="type">QByteArray</span> ba(<span class="string">"Hello"</span>);
</pre>
<p>Although the <a href="qbytearray.html#size">size</a>() is 5, the
byte array also maintains an extra '\0' character at the end so
that if a function is used that asks for a pointer to the
underlying data (e.g. a call to <a href="qbytearray.html#data">data</a>()), the data pointed to is
guaranteed to be '\0'-terminated.</p>
<p>QByteArray makes a deep copy of the <tt>const char *</tt> data,
so you can modify it later without experiencing side effects. (If
for performance reasons you don't want to take a deep copy of the
character data, use <a href="qbytearray.html#fromRawData">QByteArray.fromRawData</a>()
instead.)</p>
<p>Another approach is to set the size of the array using <a href="qbytearray.html#resize">resize</a>() and to initialize the data
byte per byte. QByteArray uses 0-based indexes, just like C++
arrays. To access the byte at a particular index position, you can
use operator[](). On non-const byte arrays, operator[]() returns a
reference to a byte that can be used on the left side of an
assignment. For example:</p>
<pre class="cpp">
 <span class="type">QByteArray</span> ba;
 ba<span class="operator">.</span>resize(<span class="number">5</span>);
 ba<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0x3c</span>;
 ba<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xb8</span>;
 ba<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0x64</span>;
 ba<span class="operator">[</span><span class="number">3</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0x18</span>;
 ba<span class="operator">[</span><span class="number">4</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xca</span>;
</pre>
<p>For read-only access, an alternative syntax is to use <a href="qbytearray.html#at">at</a>():</p>
<pre class="cpp">
 <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> ba<span class="operator">.</span>size(); <span class="operator">+</span><span class="operator">+</span>i) {
     <span class="keyword">if</span> (ba<span class="operator">.</span>at(i) <span class="operator">&gt;</span><span class="operator">=</span> <span class="char">'a'</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> ba<span class="operator">.</span>at(i) <span class="operator">&lt;</span><span class="operator">=</span> <span class="char">'f'</span>)
         cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"Found character in range [a-f]"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> endl;
 }
</pre>
<p><a href="qbytearray.html#at">at</a>() can be faster than
operator[](), because it never causes a <a href="implicit-sharing.html#deep-copy">deep copy</a> to occur.</p>
<p>To extract many bytes at a time, use <a href="qbytearray.html#left">left</a>(), <a href="qbytearray.html#right">right</a>(), or <a href="qbytearray.html#mid">mid</a>().</p>
<p>A QByteArray can embed '\0' bytes. The <a href="qbytearray.html#size">size</a>() function always returns the size
of the whole array, including embedded '\0' bytes. If you want to
obtain the length of the data up to and excluding the first '\0'
character, call <a href="qtcore.html#qstrlen">qstrlen</a>() on
the byte array.</p>
<p>After a call to <a href="qbytearray.html#resize">resize</a>(),
newly allocated bytes have undefined values. To set all the bytes
to a particular value, call <a href="qbytearray.html#fill">fill</a>().</p>
<p>To obtain a pointer to the actual character data, call <a href="qbytearray.html#data">data</a>() or <a href="qbytearray.html#constData">constData</a>(). These functions return
a pointer to the beginning of the data. The pointer is guaranteed
to remain valid until a non-const function is called on the
QByteArray. It is also guaranteed that the data ends with a '\0'
byte unless the QByteArray was created from a <a href="qbytearray.html#fromRawData">raw data</a>. This '\0' byte is
automatically provided by QByteArray and is not counted in <a href="qbytearray.html#size">size</a>().</p>
<p>QByteArray provides the following basic functions for modifying
the byte data: <a href="qbytearray.html#append">append</a>(),
<a href="qbytearray.html#prepend">prepend</a>(), <a href="qbytearray.html#insert">insert</a>(), <a href="qbytearray.html#replace">replace</a>(), and <a href="qbytearray.html#remove">remove</a>(). For example:</p>
<pre class="cpp">
 <span class="type">QByteArray</span> x(<span class="string">"and"</span>);
 x<span class="operator">.</span>prepend(<span class="string">"rock "</span>);         <span class="comment">// x == "rock and"</span>
 x<span class="operator">.</span>append(<span class="string">" roll"</span>);          <span class="comment">// x == "rock and roll"</span>
 x<span class="operator">.</span>replace(<span class="number">5</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="string">"&amp;"</span>);       <span class="comment">// x == "rock &amp; roll"</span>
</pre>
<p>The <a href="qbytearray.html#replace">replace</a>() and <a href="qbytearray.html#remove">remove</a>() functions' first two
arguments are the position from which to start erasing and the
number of bytes that should be erased.</p>
<p>When you <a href="qbytearray.html#append">append</a>() data to a
non-empty array, the array will be reallocated and the new data
copied to it. You can avoid this behavior by calling <a href="qbytearray.html#reserve">reserve</a>(), which preallocates a
certain amount of memory. You can also call <a href="qbytearray.html#capacity">capacity</a>() to find out how much
memory QByteArray actually allocated. Data appended to an empty
array is not copied.</p>
<p>A frequent requirement is to remove whitespace characters from a
byte array ('\n', '\t', ' ', etc.). If you want to remove
whitespace from both ends of a QByteArray, use <a href="qbytearray.html#trimmed">trimmed</a>(). If you want to remove
whitespace from both ends and replace multiple consecutive
whitespaces with a single space character within the byte array,
use <a href="qbytearray.html#simplified">simplified</a>().</p>
<p>If you want to find all occurrences of a particular character or
substring in a QByteArray, use <a href="qbytearray.html#indexOf">indexOf</a>() or <a href="qbytearray.html#lastIndexOf">lastIndexOf</a>(). The former
searches forward starting from a given index position, the latter
searches backward. Both return the index position of the character
or substring if they find it; otherwise, they return -1. For
example, here's a typical loop that finds all occurrences of a
particular substring:</p>
<pre class="cpp">
 <span class="type">QByteArray</span> ba(<span class="string">"We must be &lt;b&gt;bold&lt;/b&gt;, very &lt;b&gt;bold&lt;/b&gt;"</span>);
 <span class="type">int</span> j <span class="operator">=</span> <span class="number">0</span>;
 <span class="keyword">while</span> ((j <span class="operator">=</span> ba<span class="operator">.</span>indexOf(<span class="string">"&lt;b&gt;"</span><span class="operator">,</span> j)) <span class="operator">!</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>) {
     cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"Found &lt;b&gt; tag at index position "</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> j <span class="operator">&lt;</span><span class="operator">&lt;</span> endl;
     <span class="operator">+</span><span class="operator">+</span>j;
 }
</pre>
<p>If you simply want to check whether a QByteArray contains a
particular character or substring, use <a href="qbytearray.html#contains">contains</a>(). If you want to find out
how many times a particular character or substring occurs in the
byte array, use <a href="qbytearray.html#count">count</a>(). If you
want to replace all occurrences of a particular value with another,
use one of the two-parameter <a href="qbytearray.html#replace">replace</a>() overloads.</p>
<p>QByteArrays can be compared using overloaded operators such as
operator&lt;(), operator&lt;=(), operator==(), operator&gt;=(), and
so on. The comparison is based exclusively on the numeric values of
the characters and is very fast, but is not what a human would
expect. <a href="qstring.html#localeAwareCompare">QString.localeAwareCompare</a>()
is a better choice for sorting user-interface strings.</p>
<p>For historical reasons, QByteArray distinguishes between a null
byte array and an empty byte array. A <i>null</i> byte array is a
byte array that is initialized using QByteArray's default
constructor or by passing (const char *)0 to the constructor. An
<i>empty</i> byte array is any byte array with size 0. A null byte
array is always empty, but an empty byte array isn't necessarily
null:</p>
<pre class="cpp">
 <span class="type">QByteArray</span>()<span class="operator">.</span>isNull();          <span class="comment">// returns true</span>
 <span class="type">QByteArray</span>()<span class="operator">.</span>isEmpty();         <span class="comment">// returns true</span>

 <span class="type">QByteArray</span>(<span class="string">""</span>)<span class="operator">.</span>isNull();        <span class="comment">// returns false</span>
 <span class="type">QByteArray</span>(<span class="string">""</span>)<span class="operator">.</span>isEmpty();       <span class="comment">// returns true</span>

 <span class="type">QByteArray</span>(<span class="string">"abc"</span>)<span class="operator">.</span>isNull();     <span class="comment">// returns false</span>
 <span class="type">QByteArray</span>(<span class="string">"abc"</span>)<span class="operator">.</span>isEmpty();    <span class="comment">// returns false</span>
</pre>
<p>All functions except <a href="qbytearray.html#isNull">isNull</a>() treat null byte arrays the
same as empty byte arrays. For example, <a href="qbytearray.html#data">data</a>() returns a pointer to a '\0'
character for a null byte array (<i>not</i> a null pointer), and
<a href="qbytearray.html#QByteArray">QByteArray</a>() compares
equal to QByteArray(""). We recommend that you always use <a href="qbytearray.html#isEmpty">isEmpty</a>() and avoid <a href="qbytearray.html#isNull">isNull</a>().</p>
<a id="notes-on-locale" name="notes-on-locale" />
<h3>Notes on Locale</h3>
<a id="number-string-conversions" name="number-string-conversions" />
<h4>Number-String Conversions</h4>
<p>Functions that perform conversions between numeric data types
and strings are performed in the C locale, irrespective of the
user's locale settings. Use <a href="qstring.html">QString</a> to
perform locale-aware conversions between numbers and strings.</p>
<a name="8-bit-character-comparisons" />
<h4>8-bit Character Comparisons</h4>
<p>In QByteArray, the notion of uppercase and lowercase and of
which character is greater than or less than another character is
locale dependent. This affects functions that support a case
insensitive option or that compare or lowercase or uppercase their
arguments. Case insensitive operations and comparisons will be
accurate if both strings contain only ASCII characters. (If
<tt>$LC_CTYPE</tt> is set, most Unix systems do "the right thing".)
Functions that this affects include <a href="qbytearray.html#contains">contains</a>(), <a href="qbytearray.html#indexOf">indexOf</a>(), <a href="qbytearray.html#lastIndexOf">lastIndexOf</a>(), operator&lt;(),
operator&lt;=(), operator&gt;(), operator&gt;=(), <a href="qbytearray.html#toLower">toLower</a>() and <a href="qbytearray.html#toUpper">toUpper</a>().</p>
<p>This issue does not apply to QStrings since they represent
characters using Unicode.</p>
<hr /><h2>Method Documentation</h2><h3 class="fn"><a name="QByteArray" />QByteArray.__init__ (<i>self</i>)</h3><p>Constructs an empty byte array.</p>
<p><b>See also</b> <a href="qbytearray.html#isEmpty">isEmpty</a>().</p>


<h3 class="fn"><a name="QByteArray-2" />QByteArray.__init__ (<i>self</i>, int&#160;<i>size</i>, str&#160;<i>c</i>)</h3><p>Constructs a byte array initialized with the string
<i>str</i>.</p>
<p><a href="qbytearray.html">QByteArray</a> makes a deep copy of
the string data.</p>


<h3 class="fn"><a name="QByteArray-3" />QByteArray.__init__ (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>a</i>)</h3><p>Constructs a byte array containing the first <i>size</i> bytes
of array <i>data</i>.</p>
<p>If <i>data</i> is 0, a null byte array is constructed.</p>
<p><a href="qbytearray.html">QByteArray</a> makes a deep copy of
the string data.</p>
<p><b>See also</b> <a href="qbytearray.html#fromRawData">fromRawData</a>().</p>


<h3 class="fn"><a name="append" /><a href="qbytearray.html">QByteArray</a> QByteArray.append (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>a</i>)</h3><p>Appends the byte array <i>ba</i> onto the end of this byte
array.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> x(<span class="string">"free"</span>);
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> y(<span class="string">"dom"</span>);
 x<span class="operator">.</span>append(y);
 <span class="comment">// x == "freedom"</span>
</pre>
<p>This is the same as insert(<a href="qbytearray.html#size">size</a>(), <i>ba</i>).</p>
<p>Note: <a href="qbytearray.html">QByteArray</a> is an <a href="implicit-sharing.html#implicitly-shared">implicitly shared</a>
class. Consequently, if <i>this</i> is an empty <a href="qbytearray.html">QByteArray</a>, then <i>this</i> will just share
the data held in <i>ba</i>. In this case, no copying of data is
done, taking <a href="containers.html#constant-time">constant
time</a>. If a shared instance is modified, it will be copied
(copy-on-write), taking <a href="containers.html#linear-time">linear time</a>.</p>
<p>If <i>this</i> is not an empty <a href="qbytearray.html">QByteArray</a>, a deep copy of the data is
performed, taking <a href="containers.html#linear-time">linear
time</a>.</p>
<p>This operation typically does not suffer from allocation
overhead, because <a href="qbytearray.html">QByteArray</a>
preallocates extra space at the end of the data so that it may grow
without reallocating for each append operation.</p>
<p><b>See also</b> <a href="qbytearray.html#operator-2b-eq">operator+=</a>(), <a href="qbytearray.html#prepend">prepend</a>(), and <a href="qbytearray.html#insert">insert</a>().</p>


<h3 class="fn"><a name="append-2" /><a href="qbytearray.html">QByteArray</a> QByteArray.append (<i>self</i>, QString&#160;<i>s</i>)</h3><p>This is an overloaded function.</p>
<p>Appends the string <i>str</i> to this byte array. The Unicode
data is converted into 8-bit characters using <a href="qstring.html#toAscii">QString.toAscii</a>().</p>
<p>If the <a href="qstring.html">QString</a> contains non-ASCII
Unicode characters, using this function can lead to loss of
information. You can disable this function by defining
<tt>QT_NO_CAST_TO_ASCII</tt> when you compile your applications.
You then need to call <a href="qstring.html#toAscii">QString.toAscii</a>() (or <a href="qstring.html#toLatin1">QString.toLatin1</a>() or <a href="qstring.html#toUtf8">QString.toUtf8</a>() or <a href="qstring.html#toLocal8Bit">QString.toLocal8Bit</a>()) explicitly
if you want to convert the data to <tt>const char *</tt>.</p>


<h3 class="fn"><a name="at" />str QByteArray.at (<i>self</i>, int&#160;<i>i</i>)</h3><p>Returns the character at index position <i>i</i> in the byte
array.</p>
<p><i>i</i> must be a valid index position in the byte array (i.e.,
0 &lt;= <i>i</i> &lt; <a href="qbytearray.html#size">size</a>()).</p>
<p><b>See also</b> <a href="qbytearray.html#operator-5b-5d">operator[]</a>().</p>


<h3 class="fn"><a name="capacity" />int QByteArray.capacity (<i>self</i>)</h3><p>Returns the maximum number of bytes that can be stored in the
byte array without forcing a reallocation.</p>
<p>The sole purpose of this function is to provide a means of fine
tuning <a href="qbytearray.html">QByteArray</a>'s memory usage. In
general, you will rarely ever need to call this function. If you
want to know how many bytes are in the byte array, call <a href="qbytearray.html#size">size</a>().</p>
<p><b>See also</b> <a href="qbytearray.html#reserve">reserve</a>()
and <a href="qbytearray.html#squeeze">squeeze</a>().</p>


<h3 class="fn"><a name="chop" />QByteArray.chop (<i>self</i>, int&#160;<i>n</i>)</h3><p>Removes <i>n</i> bytes from the end of the byte array.</p>
<p>If <i>n</i> is greater than <a href="qbytearray.html#size">size</a>(), the result is an empty byte
array.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> ba(<span class="string">"STARTTLS\r\n"</span>);
 ba<span class="operator">.</span>chop(<span class="number">2</span>);                 <span class="comment">// ba == "STARTTLS"</span>
</pre>
<p><b>See also</b> <a href="qbytearray.html#truncate">truncate</a>(), <a href="qbytearray.html#resize">resize</a>(), and <a href="qbytearray.html#left">left</a>().</p>


<h3 class="fn"><a name="clear" />QByteArray.clear (<i>self</i>)</h3><p>Clears the contents of the byte array and makes it empty.</p>
<p><b>See also</b> <a href="qbytearray.html#resize">resize</a>()
and <a href="qbytearray.html#isEmpty">isEmpty</a>().</p>


<h3 class="fn"><a name="contains" />bool QByteArray.contains (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>a</i>)</h3><p>Returns true if the byte array contains an occurrence of the
byte array <i>ba</i>; otherwise returns false.</p>
<p><b>See also</b> <a href="qbytearray.html#indexOf">indexOf</a>()
and <a href="qbytearray.html#count">count</a>().</p>


<h3 class="fn"><a name="count" />int QByteArray.count (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>a</i>)</h3><p>Returns the number of (potentially overlapping) occurrences of
byte array <i>ba</i> in this byte array.</p>
<p><b>See also</b> <a href="qbytearray.html#contains">contains</a>() and <a href="qbytearray.html#indexOf">indexOf</a>().</p>


<h3 class="fn"><a name="count-2" />int QByteArray.count (<i>self</i>)</h3><p>This is an overloaded function.</p>
<p>Returns the number of (potentially overlapping) occurrences of
string <i>str</i> in the byte array.</p>


<h3 class="fn"><a name="data" />str QByteArray.data (<i>self</i>)</h3><p>Returns a pointer to the data stored in the byte array. The
pointer can be used to access and modify the bytes that compose the
array. The data is '\0'-terminated, i.e. the number of bytes in the
returned character string is <a href="qbytearray.html#size">size</a>() + 1 for the '\0' terminator.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> ba(<span class="string">"Hello world"</span>);
 <span class="type">char</span> <span class="operator">*</span>data <span class="operator">=</span> ba<span class="operator">.</span>data();
 <span class="keyword">while</span> (<span class="operator">*</span>data) {
     cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"["</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="operator">*</span>data <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"]"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> endl;
     <span class="operator">+</span><span class="operator">+</span>data;
 }
</pre>
<p>The pointer remains valid as long as the byte array isn't
reallocated or destroyed. For read-only access, <a href="qbytearray.html#constData">constData</a>() is faster because it
never causes a <a href="implicit-sharing.html#deep-copy">deep
copy</a> to occur.</p>
<p>This function is mostly useful to pass a byte array to a
function that accepts a <tt>const char *</tt>.</p>
<p>The following example makes a copy of the char* returned by
data(), but it will corrupt the heap and cause a crash because it
does not allocate a byte for the '\0' at the end:</p>
<pre class="cpp">
 <span class="type"><a href="qstring.html">QString</a></span> tmp <span class="operator">=</span> <span class="string">"test"</span>;
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> text <span class="operator">=</span> tmp<span class="operator">.</span>toLocal8Bit();
 <span class="type">char</span> <span class="operator">*</span>data <span class="operator">=</span> <span class="keyword">new</span> <span class="type">char</span><span class="operator">[</span>text<span class="operator">.</span>size()<span class="operator">]</span>
 strcpy(data<span class="operator">,</span> text<span class="operator">.</span>data());
 <span class="keyword">delete</span> <span class="operator">[</span><span class="operator">]</span> data;
</pre>
<p>This one allocates the correct amount of space:</p>
<pre class="cpp">
 <span class="type"><a href="qstring.html">QString</a></span> tmp <span class="operator">=</span> <span class="string">"test"</span>;
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> text <span class="operator">=</span> tmp<span class="operator">.</span>toLocal8Bit();
 <span class="type">char</span> <span class="operator">*</span>data <span class="operator">=</span> <span class="keyword">new</span> <span class="type">char</span><span class="operator">[</span>text<span class="operator">.</span>size() <span class="operator">+</span> <span class="number">1</span><span class="operator">]</span>
 strcpy(data<span class="operator">,</span> text<span class="operator">.</span>data());
 <span class="keyword">delete</span> <span class="operator">[</span><span class="operator">]</span> data;
</pre>
<p>Note: A <a href="qbytearray.html">QByteArray</a> can store any
byte values including '\0's, but most functions that take <tt>char
*</tt> arguments assume that the data ends at the first '\0' they
encounter.</p>
<p><b>See also</b> <a href="qbytearray.html#constData">constData</a>() and <a href="qbytearray.html#operator-5b-5d">operator[]</a>().</p>


<h3 class="fn"><a name="endsWith" />bool QByteArray.endsWith (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>a</i>)</h3><p>Returns true if this byte array ends with byte array <i>ba</i>;
otherwise returns false.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> url(<span class="string">"http://qt.nokia.com/index.html"</span>);
 <span class="keyword">if</span> (url<span class="operator">.</span>endsWith(<span class="string">".html"</span>))
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
</pre>
<p><b>See also</b> <a href="qbytearray.html#startsWith">startsWith</a>() and <a href="qbytearray.html#right">right</a>().</p>


<h3 class="fn"><a name="fill" /><a href="qbytearray.html">QByteArray</a> QByteArray.fill (<i>self</i>, str&#160;<i>ch</i>, int&#160;<i>size</i>&#160;=&#160;-1)</h3><p>Sets every byte in the byte array to character <i>ch</i>. If
<i>size</i> is different from -1 (the default), the byte array is
resized to size <i>size</i> beforehand.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> ba(<span class="string">"Istambul"</span>);
 ba<span class="operator">.</span>fill(<span class="char">'o'</span>);
 <span class="comment">// ba == "oooooooo"</span>

 ba<span class="operator">.</span>fill(<span class="char">'X'</span><span class="operator">,</span> <span class="number">2</span>);
 <span class="comment">// ba == "XX"</span>
</pre>
<p><b>See also</b> <a href="qbytearray.html#resize">resize</a>().</p>


<h3 class="fn"><a name="fromBase64" /><a href="qbytearray.html">QByteArray</a> QByteArray.fromBase64 (<a href="qbytearray.html">QByteArray</a>&#160;<i>base64</i>)</h3><p>Returns a decoded copy of the Base64 array <i>base64</i>. Input
is not checked for validity; invalid characters in the input are
skipped, enabling the decoding process to continue with subsequent
characters.</p>
<p>For example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> text <span class="operator">=</span> <span class="type"><a href="qbytearray.html">QByteArray</a></span><span class="operator">.</span>fromBase64(<span class="string">"UXQgaXMgZ3JlYXQh"</span>);
 text<span class="operator">.</span>data();            <span class="comment">// returns "Qt is great!"</span>
</pre>
<p>The algorithm used to decode Base64-encoded data is defined in
<a href="http://www.rfc-editor.org/rfc/rfc2045.txt">RFC
2045</a>.</p>
<p><b>See also</b> <a href="qbytearray.html#toBase64">toBase64</a>().</p>


<h3 class="fn"><a name="fromHex" /><a href="qbytearray.html">QByteArray</a> QByteArray.fromHex (<a href="qbytearray.html">QByteArray</a>&#160;<i>hexEncoded</i>)</h3><p>Returns a decoded copy of the hex encoded array
<i>hexEncoded</i>. Input is not checked for validity; invalid
characters in the input are skipped, enabling the decoding process
to continue with subsequent characters.</p>
<p>For example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> text <span class="operator">=</span> <span class="type"><a href="qbytearray.html">QByteArray</a></span><span class="operator">.</span>fromHex(<span class="string">"517420697320677265617421"</span>);
 text<span class="operator">.</span>data();            <span class="comment">// returns "Qt is great!"</span>
</pre>
<p><b>See also</b> <a href="qbytearray.html#toHex">toHex</a>().</p>


<h3 class="fn"><a name="fromPercentEncoding" /><a href="qbytearray.html">QByteArray</a> QByteArray.fromPercentEncoding (<a href="qbytearray.html">QByteArray</a>&#160;<i>input</i>, str&#160;<i>percent</i>&#160;=&#160;'%')</h3><p>Returns a decoded copy of the URI/URL-style percent-encoded
<i>input</i>. The <i>percent</i> parameter allows you to replace
the '%' character for another (for instance, '<a href="index.html">_</a>' or '=').</p>
<p>For example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> text <span class="operator">=</span> <span class="type"><a href="qbytearray.html">QByteArray</a></span><span class="operator">.</span>fromPercentEncoding(<span class="string">"Qt%20is%20great%33"</span>);
 text<span class="operator">.</span><a href="qbytearray.html#data">data</a>();            <span class="comment">// returns "Qt is great!"</span>
</pre>
<p>This function was introduced in Qt 4.4.</p>
<p><b>See also</b> <a href="qbytearray.html#toPercentEncoding">toPercentEncoding</a>() and
<a href="qurl.html#fromPercentEncoding">QUrl.fromPercentEncoding</a>().</p>


<h3 class="fn"><a name="fromRawData" /><a href="qbytearray.html">QByteArray</a> QByteArray.fromRawData (str)</h3><p>Constructs a <a href="qbytearray.html">QByteArray</a> that uses
the first <i>size</i> bytes of the <i>data</i> array. The bytes are
<i>not</i> copied. The <a href="qbytearray.html">QByteArray</a>
will contain the <i>data</i> pointer. The caller guarantees that
<i>data</i> will not be deleted or modified as long as this
<a href="qbytearray.html">QByteArray</a> and any copies of it exist
that have not been modified. In other words, because <a href="qbytearray.html">QByteArray</a> is an <a href="implicit-sharing.html#implicitly-shared">implicitly shared</a>
class and the instance returned by this function contains the
<i>data</i> pointer, the caller must not delete <i>data</i> or
modify it directly as long as the returned <a href="qbytearray.html">QByteArray</a> and any copies exist. However,
<a href="qbytearray.html">QByteArray</a> does not take ownership of
<i>data</i>, so the <a href="qbytearray.html">QByteArray</a>
destructor will never delete the raw <i>data</i>, even when the
last <a href="qbytearray.html">QByteArray</a> referring to
<i>data</i> is destroyed.</p>
<p>A subsequent attempt to modify the contents of the returned
<a href="qbytearray.html">QByteArray</a> or any copy made from it
will cause it to create a deep copy of the <i>data</i> array before
doing the modification. This ensures that the raw <i>data</i> array
itself will never be modified by <a href="qbytearray.html">QByteArray</a>.</p>
<p>Here is an example of how to read data using a <a href="qdatastream.html">QDataStream</a> on raw data in memory without
copying the raw data into a <a href="qbytearray.html">QByteArray</a>:</p>
<pre class="cpp">
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="type">char</span> mydata<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {
     <span class="number">0x00</span><span class="operator">,</span> <span class="number">0x00</span><span class="operator">,</span> <span class="number">0x03</span><span class="operator">,</span> <span class="number">0x84</span><span class="operator">,</span> <span class="number">0x78</span><span class="operator">,</span> <span class="number">0x9c</span><span class="operator">,</span> <span class="number">0x3b</span><span class="operator">,</span> <span class="number">0x76</span><span class="operator">,</span>
     <span class="number">0xec</span><span class="operator">,</span> <span class="number">0x18</span><span class="operator">,</span> <span class="number">0xc3</span><span class="operator">,</span> <span class="number">0x31</span><span class="operator">,</span> <span class="number">0x0a</span><span class="operator">,</span> <span class="number">0xf1</span><span class="operator">,</span> <span class="number">0xcc</span><span class="operator">,</span> <span class="number">0x99</span><span class="operator">,</span>
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     <span class="number">0x6d</span><span class="operator">,</span> <span class="number">0x5b</span>
 };

 <span class="type"><a href="qbytearray.html">QByteArray</a></span> data <span class="operator">=</span> <span class="type"><a href="qbytearray.html">QByteArray</a></span><span class="operator">.</span>fromRawData(mydata<span class="operator">,</span> <span class="keyword">sizeof</span>(mydata));
 <span class="type"><a href="qdatastream.html">QDataStream</a></span> in(<span class="operator">&amp;</span>data<span class="operator">,</span> <span class="type"><a href="qiodevice.html">QIODevice</a></span><span class="operator">.</span>ReadOnly);
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
</pre>
<p><b>Warning:</b> A byte array created with fromRawData() is
<i>not</i> null-terminated, unless the raw data contains a 0
character at position <i>size</i>. While that does not matter for
<a href="qdatastream.html">QDataStream</a> or functions like
<a href="qbytearray.html#indexOf">indexOf</a>(), passing the byte
array to a function accepting a <tt>const char *</tt> expected to
be '\0'-terminated will fail.</p>
<p><b>See also</b> <a href="qbytearray.html#setRawData">setRawData</a>(), <a href="qbytearray.html#data">data</a>(), and <a href="qbytearray.html#constData">constData</a>().</p>


<h3 class="fn"><a name="indexOf" />int QByteArray.indexOf (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>ba</i>, int&#160;<i>from</i>&#160;=&#160;0)</h3><p>Returns the index position of the first occurrence of the byte
array <i>ba</i> in this byte array, searching forward from index
position <i>from</i>. Returns -1 if <i>ba</i> could not be
found.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> x(<span class="string">"sticky question"</span>);
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> y(<span class="string">"sti"</span>);
 x<span class="operator">.</span>indexOf(y);               <span class="comment">// returns 0</span>
 x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">1</span>);            <span class="comment">// returns 10</span>
 x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">10</span>);           <span class="comment">// returns 10</span>
 x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">11</span>);           <span class="comment">// returns -1</span>
</pre>
<p><b>See also</b> <a href="qbytearray.html#lastIndexOf">lastIndexOf</a>(), <a href="qbytearray.html#contains">contains</a>(), and <a href="qbytearray.html#count">count</a>().</p>


<h3 class="fn"><a name="indexOf-2" />int QByteArray.indexOf (<i>self</i>, QString&#160;<i>str</i>, int&#160;<i>from</i>&#160;=&#160;0)</h3><p>This is an overloaded function.</p>
<p>Returns the index position of the first occurrence of the string
<i>str</i> in the byte array, searching forward from index position
<i>from</i>. Returns -1 if <i>str</i> could not be found.</p>
<p>The Unicode data is converted into 8-bit characters using
<a href="qstring.html#toAscii">QString.toAscii</a>().</p>
<p>If the <a href="qstring.html">QString</a> contains non-ASCII
Unicode characters, using this function can lead to loss of
information. You can disable this function by defining
<tt>QT_NO_CAST_TO_ASCII</tt> when you compile your applications.
You then need to call <a href="qstring.html#toAscii">QString.toAscii</a>() (or <a href="qstring.html#toLatin1">QString.toLatin1</a>() or <a href="qstring.html#toUtf8">QString.toUtf8</a>() or <a href="qstring.html#toLocal8Bit">QString.toLocal8Bit</a>()) explicitly
if you want to convert the data to <tt>const char *</tt>.</p>


<h3 class="fn"><a name="insert" /><a href="qbytearray.html">QByteArray</a> QByteArray.insert (<i>self</i>, int&#160;<i>i</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>a</i>)</h3><p>Inserts the byte array <i>ba</i> at index position <i>i</i> and
returns a reference to this byte array.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> ba(<span class="string">"Meal"</span>);
 ba<span class="operator">.</span>insert(<span class="number">1</span><span class="operator">,</span> <span class="type"><a href="qbytearray.html">QByteArray</a></span>(<span class="string">"ontr"</span>));
 <span class="comment">// ba == "Montreal"</span>
</pre>
<p><b>See also</b> <a href="qbytearray.html#append">append</a>(),
<a href="qbytearray.html#prepend">prepend</a>(), <a href="qbytearray.html#replace">replace</a>(), and <a href="qbytearray.html#remove">remove</a>().</p>


<h3 class="fn"><a name="insert-2" /><a href="qbytearray.html">QByteArray</a> QByteArray.insert (<i>self</i>, int&#160;<i>i</i>, QString&#160;<i>s</i>)</h3><p>This is an overloaded function.</p>
<p>Inserts the string <i>str</i> at index position <i>i</i> in the
byte array. The Unicode data is converted into 8-bit characters
using <a href="qstring.html#toAscii">QString.toAscii</a>().</p>
<p>If <i>i</i> is greater than <a href="qbytearray.html#size">size</a>(), the array is first extended
using <a href="qbytearray.html#resize">resize</a>().</p>
<p>If the <a href="qstring.html">QString</a> contains non-ASCII
Unicode characters, using this function can lead to loss of
information. You can disable this function by defining
<tt>QT_NO_CAST_TO_ASCII</tt> when you compile your applications.
You then need to call <a href="qstring.html#toAscii">QString.toAscii</a>() (or <a href="qstring.html#toLatin1">QString.toLatin1</a>() or <a href="qstring.html#toUtf8">QString.toUtf8</a>() or <a href="qstring.html#toLocal8Bit">QString.toLocal8Bit</a>()) explicitly
if you want to convert the data to <tt>const char *</tt>.</p>


<h3 class="fn"><a name="isEmpty" />bool QByteArray.isEmpty (<i>self</i>)</h3><p>Returns true if the byte array has size 0; otherwise returns
false.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span>()<span class="operator">.</span>isEmpty();         <span class="comment">// returns true</span>
 <span class="type"><a href="qbytearray.html">QByteArray</a></span>(<span class="string">""</span>)<span class="operator">.</span>isEmpty();       <span class="comment">// returns true</span>
 <span class="type"><a href="qbytearray.html">QByteArray</a></span>(<span class="string">"abc"</span>)<span class="operator">.</span>isEmpty();    <span class="comment">// returns false</span>
</pre>
<p><b>See also</b> <a href="qbytearray.html#size">size</a>().</p>


<h3 class="fn"><a name="isNull" />bool QByteArray.isNull (<i>self</i>)</h3><p>Returns true if this byte array is null; otherwise returns
false.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span>()<span class="operator">.</span>isNull();          <span class="comment">// returns true</span>
 <span class="type"><a href="qbytearray.html">QByteArray</a></span>(<span class="string">""</span>)<span class="operator">.</span>isNull();        <span class="comment">// returns false</span>
 <span class="type"><a href="qbytearray.html">QByteArray</a></span>(<span class="string">"abc"</span>)<span class="operator">.</span>isNull();     <span class="comment">// returns false</span>
</pre>
<p>Qt makes a distinction between null byte arrays and empty byte
arrays for historical reasons. For most applications, what matters
is whether or not a byte array contains any data, and this can be
determined using <a href="qbytearray.html#isEmpty">isEmpty</a>().</p>
<p><b>See also</b> <a href="qbytearray.html#isEmpty">isEmpty</a>().</p>


<h3 class="fn"><a name="lastIndexOf" />int QByteArray.lastIndexOf (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>ba</i>, int&#160;<i>from</i>&#160;=&#160;-1)</h3><p>Returns the index position of the last occurrence of the byte
array <i>ba</i> in this byte array, searching backward from index
position <i>from</i>. If <i>from</i> is -1 (the default), the
search starts at the last byte. Returns -1 if <i>ba</i> could not
be found.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> x(<span class="string">"crazy azimuths"</span>);
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> y(<span class="string">"az"</span>);
 x<span class="operator">.</span>lastIndexOf(y);           <span class="comment">// returns 6</span>
 x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">6</span>);        <span class="comment">// returns 6</span>
 x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">5</span>);        <span class="comment">// returns 2</span>
 x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">1</span>);        <span class="comment">// returns -1</span>
</pre>
<p><b>See also</b> <a href="qbytearray.html#indexOf">indexOf</a>(),
<a href="qbytearray.html#contains">contains</a>(), and <a href="qbytearray.html#count">count</a>().</p>


<h3 class="fn"><a name="lastIndexOf-2" />int QByteArray.lastIndexOf (<i>self</i>, QString&#160;<i>str</i>, int&#160;<i>from</i>&#160;=&#160;-1)</h3><p>This is an overloaded function.</p>
<p>Returns the index position of the last occurrence of the string
<i>str</i> in the byte array, searching backward from index
position <i>from</i>. If <i>from</i> is -1 (the default), the
search starts at the last (<a href="qbytearray.html#size">size</a>() - 1) byte. Returns -1 if
<i>str</i> could not be found.</p>
<p>The Unicode data is converted into 8-bit characters using
<a href="qstring.html#toAscii">QString.toAscii</a>().</p>
<p>If the <a href="qstring.html">QString</a> contains non-ASCII
Unicode characters, using this function can lead to loss of
information. You can disable this function by defining
<tt>QT_NO_CAST_TO_ASCII</tt> when you compile your applications.
You then need to call <a href="qstring.html#toAscii">QString.toAscii</a>() (or <a href="qstring.html#toLatin1">QString.toLatin1</a>() or <a href="qstring.html#toUtf8">QString.toUtf8</a>() or <a href="qstring.html#toLocal8Bit">QString.toLocal8Bit</a>()) explicitly
if you want to convert the data to <tt>const char *</tt>.</p>


<h3 class="fn"><a name="left" /><a href="qbytearray.html">QByteArray</a> QByteArray.left (<i>self</i>, int&#160;<i>len</i>)</h3><p>Returns a byte array that contains the leftmost <i>len</i> bytes
of this byte array.</p>
<p>The entire byte array is returned if <i>len</i> is greater than
<a href="qbytearray.html#size">size</a>().</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> x(<span class="string">"Pineapple"</span>);
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>left(<span class="number">4</span>);
 <span class="comment">// y == "Pine"</span>
</pre>
<p><b>See also</b> <a href="qbytearray.html#right">right</a>(),
<a href="qbytearray.html#mid">mid</a>(), <a href="qbytearray.html#startsWith">startsWith</a>(), and <a href="qbytearray.html#truncate">truncate</a>().</p>


<h3 class="fn"><a name="leftJustified" /><a href="qbytearray.html">QByteArray</a> QByteArray.leftJustified (<i>self</i>, int&#160;<i>width</i>, str&#160;<i>fill</i>&#160;=&#160;' ', bool&#160;<i>truncate</i>&#160;=&#160;False)</h3><p>Returns a byte array of size <i>width</i> that contains this
byte array padded by the <i>fill</i> character.</p>
<p>If <i>truncate</i> is false and the <a href="qbytearray.html#size">size</a>() of the byte array is more than
<i>width</i>, then the returned byte array is a copy of this byte
array.</p>
<p>If <i>truncate</i> is true and the <a href="qbytearray.html#size">size</a>() of the byte array is more than
<i>width</i>, then any bytes in a copy of the byte array after
position <i>width</i> are removed, and the copy is returned.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> x(<span class="string">"apple"</span>);
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>leftJustified(<span class="number">8</span><span class="operator">,</span> <span class="char">'.'</span>);   <span class="comment">// y == "apple..."</span>
</pre>
<p><b>See also</b> <a href="qbytearray.html#rightJustified">rightJustified</a>().</p>


<h3 class="fn"><a name="length" />int QByteArray.length (<i>self</i>)</h3><p>Same as <a href="qbytearray.html#size">size</a>().</p>


<h3 class="fn"><a name="mid" /><a href="qbytearray.html">QByteArray</a> QByteArray.mid (<i>self</i>, int&#160;<i>pos</i>, int&#160;<i>length</i>&#160;=&#160;-1)</h3><p>Returns a byte array containing <i>len</i> bytes from this byte
array, starting at position <i>pos</i>.</p>
<p>If <i>len</i> is -1 (the default), or <i>pos</i> + <i>len</i>
&gt;= <a href="qbytearray.html#size">size</a>(), returns a byte
array containing all bytes starting at position <i>pos</i> until
the end of the byte array.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> x(<span class="string">"Five pineapples"</span>);
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>mid(<span class="number">5</span><span class="operator">,</span> <span class="number">4</span>);     <span class="comment">// y == "pine"</span>
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> z <span class="operator">=</span> x<span class="operator">.</span>mid(<span class="number">5</span>);        <span class="comment">// z == "pineapples"</span>
</pre>
<p><b>See also</b> <a href="qbytearray.html#left">left</a>() and
<a href="qbytearray.html#right">right</a>().</p>


<h3 class="fn"><a name="number" /><a href="qbytearray.html">QByteArray</a> QByteArray.number (int&#160;<i>n</i>, int&#160;<i>base</i>&#160;=&#160;10)</h3><p>Returns a byte array containing the string equivalent of the
number <i>n</i> to base <i>base</i> (10 by default). The
<i>base</i> can be any value between 2 and 36.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type">int</span> n <span class="operator">=</span> <span class="number">63</span>;
 <span class="type"><a href="qbytearray.html">QByteArray</a></span><span class="operator">.</span>number(n);              <span class="comment">// returns "63"</span>
 <span class="type"><a href="qbytearray.html">QByteArray</a></span><span class="operator">.</span>number(n<span class="operator">,</span> <span class="number">16</span>);          <span class="comment">// returns "3f"</span>
 <span class="type"><a href="qbytearray.html">QByteArray</a></span><span class="operator">.</span>number(n<span class="operator">,</span> <span class="number">16</span>)<span class="operator">.</span>toUpper();  <span class="comment">// returns "3F"</span>
</pre>
<p><b>Note:</b> The format of the number is not localized; the
default C locale is used irrespective of the user's locale.</p>
<p><b>See also</b> <a href="qbytearray.html#setNum">setNum</a>()
and <a href="qbytearray.html#toInt">toInt</a>().</p>


<h3 class="fn"><a name="number-2" /><a href="qbytearray.html">QByteArray</a> QByteArray.number (float&#160;<i>n</i>, str&#160;<i>format</i>&#160;=&#160;'g', int&#160;<i>precision</i>&#160;=&#160;6)</h3><p>This is an overloaded function.</p>
<p><b>See also</b> <a href="qbytearray.html#toUInt">toUInt</a>().</p>


<h3 class="fn"><a name="number-3" /><a href="qbytearray.html">QByteArray</a> QByteArray.number (int&#160;<i>n</i>, int&#160;<i>base</i>&#160;=&#160;10)</h3><p>This is an overloaded function.</p>
<p><b>See also</b> <a href="qbytearray.html#toLongLong">toLongLong</a>().</p>


<h3 class="fn"><a name="number-4" /><a href="qbytearray.html">QByteArray</a> QByteArray.number (int&#160;<i>n</i>, int&#160;<i>base</i>&#160;=&#160;10)</h3><p>This is an overloaded function.</p>
<p><b>See also</b> <a href="qbytearray.html#toULongLong">toULongLong</a>().</p>


<h3 class="fn"><a name="prepend" /><a href="qbytearray.html">QByteArray</a> QByteArray.prepend (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>a</i>)</h3><p>Prepends the byte array <i>ba</i> to this byte array and returns
a reference to this byte array.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> x(<span class="string">"ship"</span>);
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> y(<span class="string">"air"</span>);
 x<span class="operator">.</span>prepend(y);
 <span class="comment">// x == "airship"</span>
</pre>
<p>This is the same as insert(0, <i>ba</i>).</p>
<p>Note: <a href="qbytearray.html">QByteArray</a> is an <a href="implicit-sharing.html#implicitly-shared">implicitly shared</a>
class. Consequently, if <i>this</i> is an empty <a href="qbytearray.html">QByteArray</a>, then <i>this</i> will just share
the data held in <i>ba</i>. In this case, no copying of data is
done, taking <a href="containers.html#constant-time">constant
time</a>. If a shared instance is modified, it will be copied
(copy-on-write), taking <a href="containers.html#linear-time">linear time</a>.</p>
<p>If <i>this</i> is not an empty <a href="qbytearray.html">QByteArray</a>, a deep copy of the data is
performed, taking <a href="containers.html#linear-time">linear
time</a>.</p>
<p><b>See also</b> <a href="qbytearray.html#append">append</a>()
and <a href="qbytearray.html#insert">insert</a>().</p>


<h3 class="fn"><a name="push_back" />QByteArray.push_back (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>a</i>)</h3><p>This function is provided for STL compatibility. It is
equivalent to append(<i>other</i>).</p>


<h3 class="fn"><a name="push_front" />QByteArray.push_front (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>a</i>)</h3><p>This function is provided for STL compatibility. It is
equivalent to prepend(<i>other</i>).</p>


<h3 class="fn"><a name="remove" /><a href="qbytearray.html">QByteArray</a> QByteArray.remove (<i>self</i>, int&#160;<i>index</i>, int&#160;<i>len</i>)</h3><p>Removes <i>len</i> bytes from the array, starting at index
position <i>pos</i>, and returns a reference to the array.</p>
<p>If <i>pos</i> is out of range, nothing happens. If <i>pos</i> is
valid, but <i>pos</i> + <i>len</i> is larger than the size of the
array, the array is truncated at position <i>pos</i>.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> ba(<span class="string">"Montreal"</span>);
 ba<span class="operator">.</span>remove(<span class="number">1</span><span class="operator">,</span> <span class="number">4</span>);
 <span class="comment">// ba == "Meal"</span>
</pre>
<p><b>See also</b> <a href="qbytearray.html#insert">insert</a>()
and <a href="qbytearray.html#replace">replace</a>().</p>


<h3 class="fn"><a name="repeated" /><a href="qbytearray.html">QByteArray</a> QByteArray.repeated (<i>self</i>, int&#160;<i>times</i>)</h3><p>Returns a copy of this byte array repeated the specified number
of <i>times</i>.</p>
<p>If <i>times</i> is less than 1, an empty byte array is
returned.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> ba(<span class="string">"ab"</span>);
 ba<span class="operator">.</span>repeated(<span class="number">4</span>);             <span class="comment">// returns "abababab"</span>
</pre>
<p>This function was introduced in Qt 4.5.</p>


<h3 class="fn"><a name="replace" /><a href="qbytearray.html">QByteArray</a> QByteArray.replace (<i>self</i>, int&#160;<i>index</i>, int&#160;<i>len</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>s</i>)</h3><p>Replaces <i>len</i> bytes from index position <i>pos</i> with
the byte array <i>after</i>, and returns a reference to this byte
array.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> x(<span class="string">"Say yes!"</span>);
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> y(<span class="string">"no"</span>);
 x<span class="operator">.</span>replace(<span class="number">4</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> y);
 <span class="comment">// x == "Say no!"</span>
</pre>
<p><b>See also</b> <a href="qbytearray.html#insert">insert</a>()
and <a href="qbytearray.html#remove">remove</a>().</p>


<h3 class="fn"><a name="replace-2" /><a href="qbytearray.html">QByteArray</a> QByteArray.replace (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>before</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>after</i>)</h3><p>This is an overloaded function.</p>
<p>Replaces <i>len</i> bytes from index position <i>pos</i> with
the zero terminated string <i>after</i>.</p>
<p>Notice: this can change the length of the byte array.</p>


<h3 class="fn"><a name="replace-3" /><a href="qbytearray.html">QByteArray</a> QByteArray.replace (<i>self</i>, QString&#160;<i>before</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>after</i>)</h3><p>This is an overloaded function.</p>
<p>Replaces <i>len</i> bytes from index position <i>pos</i> with
<i>alen</i> bytes from the string <i>after</i>. <i>after</i> is
allowed to have '\0' characters.</p>
<p>This function was introduced in Qt 4.7.</p>


<h3 class="fn"><a name="reserve" />QByteArray.reserve (<i>self</i>, int&#160;<i>size</i>)</h3><p>Attempts to allocate memory for at least <i>size</i> bytes. If
you know in advance how large the byte array will be, you can call
this function, and if you call <a href="qbytearray.html#resize">resize</a>() often you are likely to get
better performance. If <i>size</i> is an underestimate, the worst
that will happen is that the <a href="qbytearray.html">QByteArray</a> will be a bit slower.</p>
<p>The sole purpose of this function is to provide a means of fine
tuning <a href="qbytearray.html">QByteArray</a>'s memory usage. In
general, you will rarely ever need to call this function. If you
want to change the size of the byte array, call <a href="qbytearray.html#resize">resize</a>().</p>
<p><b>See also</b> <a href="qbytearray.html#squeeze">squeeze</a>()
and <a href="qbytearray.html#capacity">capacity</a>().</p>


<h3 class="fn"><a name="resize" />QByteArray.resize (<i>self</i>, int&#160;<i>size</i>)</h3><p>Sets the size of the byte array to <i>size</i> bytes.</p>
<p>If <i>size</i> is greater than the current size, the byte array
is extended to make it <i>size</i> bytes with the extra bytes added
to the end. The new bytes are uninitialized.</p>
<p>If <i>size</i> is less than the current size, bytes are removed
from the end.</p>
<p><b>See also</b> <a href="qbytearray.html#size">size</a>() and
<a href="qbytearray.html#truncate">truncate</a>().</p>


<h3 class="fn"><a name="right" /><a href="qbytearray.html">QByteArray</a> QByteArray.right (<i>self</i>, int&#160;<i>len</i>)</h3><p>Returns a byte array that contains the rightmost <i>len</i>
bytes of this byte array.</p>
<p>The entire byte array is returned if <i>len</i> is greater than
<a href="qbytearray.html#size">size</a>().</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> x(<span class="string">"Pineapple"</span>);
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>right(<span class="number">5</span>);
 <span class="comment">// y == "apple"</span>
</pre>
<p><b>See also</b> <a href="qbytearray.html#endsWith">endsWith</a>(), <a href="qbytearray.html#left">left</a>(), and <a href="qbytearray.html#mid">mid</a>().</p>


<h3 class="fn"><a name="rightJustified" /><a href="qbytearray.html">QByteArray</a> QByteArray.rightJustified (<i>self</i>, int&#160;<i>width</i>, str&#160;<i>fill</i>&#160;=&#160;' ', bool&#160;<i>truncate</i>&#160;=&#160;False)</h3><p>Returns a byte array of size <i>width</i> that contains the
<i>fill</i> character followed by this byte array.</p>
<p>If <i>truncate</i> is false and the size of the byte array is
more than <i>width</i>, then the returned byte array is a copy of
this byte array.</p>
<p>If <i>truncate</i> is true and the size of the byte array is
more than <i>width</i>, then the resulting byte array is truncated
at position <i>width</i>.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> x(<span class="string">"apple"</span>);
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>rightJustified(<span class="number">8</span><span class="operator">,</span> <span class="char">'.'</span>);    <span class="comment">// y == "...apple"</span>
</pre>
<p><b>See also</b> <a href="qbytearray.html#leftJustified">leftJustified</a>().</p>


<h3 class="fn"><a name="setNum" /><a href="qbytearray.html">QByteArray</a> QByteArray.setNum (<i>self</i>, int&#160;<i>n</i>, int&#160;<i>base</i>&#160;=&#160;10)</h3><p>Sets the byte array to the printed value of <i>n</i> in base
<i>base</i> (10 by default) and returns a reference to the byte
array. The <i>base</i> can be any value between 2 and 36.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> ba;
 <span class="type">int</span> n <span class="operator">=</span> <span class="number">63</span>;
 ba<span class="operator">.</span>setNum(n);           <span class="comment">// ba == "63"</span>
 ba<span class="operator">.</span>setNum(n<span class="operator">,</span> <span class="number">16</span>);       <span class="comment">// ba == "3f"</span>
</pre>
<p><b>Note:</b> The format of the number is not localized; the
default C locale is used irrespective of the user's locale.</p>
<p><b>See also</b> <a href="qbytearray.html#number">number</a>()
and <a href="qbytearray.html#toInt">toInt</a>().</p>


<h3 class="fn"><a name="setNum-2" /><a href="qbytearray.html">QByteArray</a> QByteArray.setNum (<i>self</i>, float&#160;<i>n</i>, str&#160;<i>format</i>&#160;=&#160;'g', int&#160;<i>precision</i>&#160;=&#160;6)</h3><p>This is an overloaded function.</p>
<p><b>See also</b> <a href="qbytearray.html#toUInt">toUInt</a>().</p>


<h3 class="fn"><a name="setNum-3" /><a href="qbytearray.html">QByteArray</a> QByteArray.setNum (<i>self</i>, int&#160;<i>n</i>, int&#160;<i>base</i>&#160;=&#160;10)</h3><p>This is an overloaded function.</p>
<p><b>See also</b> <a href="qbytearray.html#toShort">toShort</a>().</p>


<h3 class="fn"><a name="setNum-4" /><a href="qbytearray.html">QByteArray</a> QByteArray.setNum (<i>self</i>, int&#160;<i>n</i>, int&#160;<i>base</i>&#160;=&#160;10)</h3><p>This is an overloaded function.</p>
<p><b>See also</b> <a href="qbytearray.html#toUShort">toUShort</a>().</p>


<h3 class="fn"><a name="simplified" /><a href="qbytearray.html">QByteArray</a> QByteArray.simplified (<i>self</i>)</h3><p>Returns a byte array that has whitespace removed from the start
and the end, and which has each sequence of internal whitespace
replaced with a single space.</p>
<p>Whitespace means any character for which the standard C++
isspace() function returns true. This includes the ASCII characters
'\t', '\n', '\v', '\f', '\r', and ' '.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> ba(<span class="string">"  lots\t of\nwhitespace\r\n "</span>);
 ba <span class="operator">=</span> ba<span class="operator">.</span>simplified();
 <span class="comment">// ba == "lots of whitespace";</span>
</pre>
<p><b>See also</b> <a href="qbytearray.html#trimmed">trimmed</a>().</p>


<h3 class="fn"><a name="size" />int QByteArray.size (<i>self</i>)</h3><p>Returns the number of bytes in this byte array.</p>
<p>The last byte in the byte array is at position size() - 1. In
addition, <a href="qbytearray.html">QByteArray</a> ensures that the
byte at position size() is always '\0', so that you can use the
return value of <a href="qbytearray.html#data">data</a>() and
<a href="qbytearray.html#constData">constData</a>() as arguments to
functions that expect '\0'-terminated strings. If the <a href="qbytearray.html">QByteArray</a> object was created from a <a href="qbytearray.html#fromRawData">raw data</a> that didn't include the
trailing null-termination character then <a href="qbytearray.html">QByteArray</a> doesn't add it automaticall unless
the <a href="implicit-sharing.html#deep-copy">deep copy</a> is
created.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> ba(<span class="string">"Hello"</span>);
 <span class="type">int</span> n <span class="operator">=</span> ba<span class="operator">.</span>size();          <span class="comment">// n == 5</span>
 ba<span class="operator">.</span>data()<span class="operator">[</span><span class="number">0</span><span class="operator">]</span>;               <span class="comment">// returns 'H'</span>
 ba<span class="operator">.</span>data()<span class="operator">[</span><span class="number">4</span><span class="operator">]</span>;               <span class="comment">// returns 'o'</span>
 ba<span class="operator">.</span>data()<span class="operator">[</span><span class="number">5</span><span class="operator">]</span>;               <span class="comment">// returns '\0'</span>
</pre>
<p><b>See also</b> <a href="qbytearray.html#isEmpty">isEmpty</a>()
and <a href="qbytearray.html#resize">resize</a>().</p>


<h3 class="fn"><a name="split" />list-of-QByteArray QByteArray.split (<i>self</i>, str&#160;<i>sep</i>)</h3><p>Splits the byte array into subarrays wherever <i>sep</i> occurs,
and returns the list of those arrays. If <i>sep</i> does not match
anywhere in the byte array, split() returns a single-element list
containing this byte array.</p>


<h3 class="fn"><a name="squeeze" />QByteArray.squeeze (<i>self</i>)</h3><p>Releases any memory not required to store the array's data.</p>
<p>The sole purpose of this function is to provide a means of fine
tuning <a href="qbytearray.html">QByteArray</a>'s memory usage. In
general, you will rarely ever need to call this function.</p>
<p><b>See also</b> <a href="qbytearray.html#reserve">reserve</a>()
and <a href="qbytearray.html#capacity">capacity</a>().</p>


<h3 class="fn"><a name="startsWith" />bool QByteArray.startsWith (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>a</i>)</h3><p>Returns true if this byte array starts with byte array
<i>ba</i>; otherwise returns false.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> url(<span class="string">"ftp://ftp.qt.nokia.com/"</span>);
 <span class="keyword">if</span> (url<span class="operator">.</span>startsWith(<span class="string">"ftp:"</span>))
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
</pre>
<p><b>See also</b> <a href="qbytearray.html#endsWith">endsWith</a>() and <a href="qbytearray.html#left">left</a>().</p>


<h3 class="fn"><a name="swap" />QByteArray.swap (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>other</i>)</h3><p>Swaps byte array <i>other</i> with this byte array. This
operation is very fast and never fails.</p>
<p>This function was introduced in Qt 4.8.</p>


<h3 class="fn"><a name="toBase64" /><a href="qbytearray.html">QByteArray</a> QByteArray.toBase64 (<i>self</i>)</h3><p>Returns a copy of the byte array, encoded as Base64.</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> text(<span class="string">"Qt is great!"</span>);
 text<span class="operator">.</span>toBase64();        <span class="comment">// returns "UXQgaXMgZ3JlYXQh"</span>
</pre>
<p>The algorithm used to encode Base64-encoded data is defined in
<a href="http://www.rfc-editor.org/rfc/rfc2045.txt">RFC
2045</a>.</p>
<p><b>See also</b> <a href="qbytearray.html#fromBase64">fromBase64</a>().</p>


<h3 class="fn"><a name="toDouble" />(float, bool&#160;<i>ok</i>) QByteArray.toDouble (<i>self</i>)</h3><p>Returns the byte array converted to a <tt>double</tt> value.</p>
<p>Returns 0.0 if the conversion fails.</p>
<p>If <i>ok</i> is not 0: if a conversion error occurs, *<i>ok</i>
is set to false; otherwise *<i>ok</i> is set to true.</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> string(<span class="string">"1234.56"</span>);
 <span class="type">double</span> a <span class="operator">=</span> string<span class="operator">.</span>toDouble();   <span class="comment">// a == 1234.56</span>
</pre>
<p><b>Note:</b> The conversion of the number is performed in the
default C locale, irrespective of the user's locale.</p>
<p><b>See also</b> <a href="qbytearray.html#number">number</a>().</p>


<h3 class="fn"><a name="toFloat" />(float, bool&#160;<i>ok</i>) QByteArray.toFloat (<i>self</i>)</h3><p>Returns the byte array converted to a <tt>float</tt> value.</p>
<p>Returns 0.0 if the conversion fails.</p>
<p>If <i>ok</i> is not 0: if a conversion error occurs, *<i>ok</i>
is set to false; otherwise *<i>ok</i> is set to true.</p>
<p><b>Note:</b> The conversion of the number is performed in the
default C locale, irrespective of the user's locale.</p>
<p><b>See also</b> <a href="qbytearray.html#number">number</a>().</p>


<h3 class="fn"><a name="toHex" /><a href="qbytearray.html">QByteArray</a> QByteArray.toHex (<i>self</i>)</h3><p>Returns a hex encoded copy of the byte array. The hex encoding
uses the numbers 0-9 and the letters a-f.</p>
<p><b>See also</b> <a href="qbytearray.html#fromHex">fromHex</a>().</p>


<h3 class="fn"><a name="toInt" />(int, bool&#160;<i>ok</i>) QByteArray.toInt (<i>self</i>, int&#160;<i>base</i>&#160;=&#160;10)</h3><p>Returns the byte array converted to an <tt>int</tt> using base
<i>base</i>, which is 10 by default and must be between 2 and 36,
or 0.</p>
<p>If <i>base</i> is 0, the base is determined automatically using
the following rules: If the byte array begins with "0x", it is
assumed to be hexadecimal; if it begins with "0", it is assumed to
be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not 0: if a conversion error occurs, *<i>ok</i>
is set to false; otherwise *<i>ok</i> is set to true.</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> str(<span class="string">"FF"</span>);
 <span class="type">bool</span> ok;
 <span class="type">int</span> hex <span class="operator">=</span> str<span class="operator">.</span>toInt(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);     <span class="comment">// hex == 255, ok == true</span>
 <span class="type">int</span> dec <span class="operator">=</span> str<span class="operator">.</span>toInt(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);     <span class="comment">// dec == 0, ok == false</span>
</pre>
<p><b>Note:</b> The conversion of the number is performed in the
default C locale, irrespective of the user's locale.</p>
<p><b>See also</b> <a href="qbytearray.html#number">number</a>().</p>


<h3 class="fn"><a name="toLong" />(int, bool&#160;<i>ok</i>) QByteArray.toLong (<i>self</i>, int&#160;<i>base</i>&#160;=&#160;10)</h3><p>Returns the byte array converted to a <tt>long</tt> int using
base <i>base</i>, which is 10 by default and must be between 2 and
36, or 0.</p>
<p>If <i>base</i> is 0, the base is determined automatically using
the following rules: If the byte array begins with "0x", it is
assumed to be hexadecimal; if it begins with "0", it is assumed to
be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not 0: if a conversion error occurs, *<i>ok</i>
is set to false; otherwise *<i>ok</i> is set to true.</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> str(<span class="string">"FF"</span>);
 <span class="type">bool</span> ok;
 <span class="type">long</span> hex <span class="operator">=</span> str<span class="operator">.</span>toLong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);   <span class="comment">// hex == 255, ok == true</span>
 <span class="type">long</span> dec <span class="operator">=</span> str<span class="operator">.</span>toLong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);   <span class="comment">// dec == 0, ok == false</span>
</pre>
<p><b>Note:</b> The conversion of the number is performed in the
default C locale, irrespective of the user's locale.</p>
<p>This function was introduced in Qt 4.1.</p>
<p><b>See also</b> <a href="qbytearray.html#number">number</a>().</p>


<h3 class="fn"><a name="toLongLong" />(int, bool&#160;<i>ok</i>) QByteArray.toLongLong (<i>self</i>, int&#160;<i>base</i>&#160;=&#160;10)</h3><p>Returns the byte array converted to a <tt>long long</tt> using
base <i>base</i>, which is 10 by default and must be between 2 and
36, or 0.</p>
<p>If <i>base</i> is 0, the base is determined automatically using
the following rules: If the byte array begins with "0x", it is
assumed to be hexadecimal; if it begins with "0", it is assumed to
be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not 0: if a conversion error occurs, *<i>ok</i>
is set to false; otherwise *<i>ok</i> is set to true.</p>
<p><b>Note:</b> The conversion of the number is performed in the
default C locale, irrespective of the user's locale.</p>
<p><b>See also</b> <a href="qbytearray.html#number">number</a>().</p>


<h3 class="fn"><a name="toLower" /><a href="qbytearray.html">QByteArray</a> QByteArray.toLower (<i>self</i>)</h3><p>Returns a lowercase copy of the byte array. The bytearray is
interpreted as a Latin-1 encoded string.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> x(<span class="string">"Qt by NOKIA"</span>);
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>toLower();
 <span class="comment">// y == "qt by nokia"</span>
</pre>
<p><b>See also</b> <a href="qbytearray.html#toUpper">toUpper</a>()
and <a href="qbytearray.html#8-bit-character-comparisons">8-bit
Character Comparisons</a>.</p>


<h3 class="fn"><a name="toPercentEncoding" /><a href="qbytearray.html">QByteArray</a> QByteArray.toPercentEncoding (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>exclude</i>&#160;=&#160;QByteArray(), <a href="qbytearray.html">QByteArray</a>&#160;<i>include</i>&#160;=&#160;QByteArray(), str&#160;<i>percent</i>&#160;=&#160;'%')</h3><p>Returns a URI/URL-style percent-encoded copy of this byte array.
The <i>percent</i> parameter allows you to override the default '%'
character for another.</p>
<p>By default, this function will encode all characters that are
not one of the following:</p>
<p>ALPHA ("a" to "z" and "A" to "Z") / DIGIT (0 to 9) / "-" / "." /
"<a href="index.html">_</a>" / "~"</p>
<p>To prevent characters from being encoded pass them to
<i>exclude</i>. To force characters to be encoded pass them to
<i>include</i>. The <i>percent</i> character is always encoded.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> text <span class="operator">=</span> <span class="string">"{a fishy string?}"</span>;
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> ba <span class="operator">=</span> text<span class="operator">.</span>toPercentEncoding(<span class="string">"{}"</span><span class="operator">,</span> <span class="string">"s"</span>);
 <a href="qtcore.html#qDebug">qDebug</a>(ba<span class="operator">.</span>constData());
 <span class="comment">// prints "{a fi%73hy %73tring%3F}"</span>
</pre>
<p>The hex encoding uses the numbers 0-9 and the uppercase letters
A-F.</p>
<p>This function was introduced in Qt 4.4.</p>
<p><b>See also</b> <a href="qbytearray.html#fromPercentEncoding">fromPercentEncoding</a>() and
<a href="qurl.html#toPercentEncoding">QUrl.toPercentEncoding</a>().</p>


<h3 class="fn"><a name="toShort" />(int, bool&#160;<i>ok</i>) QByteArray.toShort (<i>self</i>, int&#160;<i>base</i>&#160;=&#160;10)</h3><p>Returns the byte array converted to a <tt>short</tt> using base
<i>base</i>, which is 10 by default and must be between 2 and 36,
or 0.</p>
<p>If <i>base</i> is 0, the base is determined automatically using
the following rules: If the byte array begins with "0x", it is
assumed to be hexadecimal; if it begins with "0", it is assumed to
be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not 0: if a conversion error occurs, *<i>ok</i>
is set to false; otherwise *<i>ok</i> is set to true.</p>
<p><b>Note:</b> The conversion of the number is performed in the
default C locale, irrespective of the user's locale.</p>
<p><b>See also</b> <a href="qbytearray.html#number">number</a>().</p>


<h3 class="fn"><a name="toUInt" />(int, bool&#160;<i>ok</i>) QByteArray.toUInt (<i>self</i>, int&#160;<i>base</i>&#160;=&#160;10)</h3><p>Returns the byte array converted to an <tt>unsigned int</tt>
using base <i>base</i>, which is 10 by default and must be between
2 and 36, or 0.</p>
<p>If <i>base</i> is 0, the base is determined automatically using
the following rules: If the byte array begins with "0x", it is
assumed to be hexadecimal; if it begins with "0", it is assumed to
be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not 0: if a conversion error occurs, *<i>ok</i>
is set to false; otherwise *<i>ok</i> is set to true.</p>
<p><b>Note:</b> The conversion of the number is performed in the
default C locale, irrespective of the user's locale.</p>
<p><b>See also</b> <a href="qbytearray.html#number">number</a>().</p>


<h3 class="fn"><a name="toULong" />(int, bool&#160;<i>ok</i>) QByteArray.toULong (<i>self</i>, int&#160;<i>base</i>&#160;=&#160;10)</h3><p>Returns the byte array converted to an <tt>unsigned long
int</tt> using base <i>base</i>, which is 10 by default and must be
between 2 and 36, or 0.</p>
<p>If <i>base</i> is 0, the base is determined automatically using
the following rules: If the byte array begins with "0x", it is
assumed to be hexadecimal; if it begins with "0", it is assumed to
be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not 0: if a conversion error occurs, *<i>ok</i>
is set to false; otherwise *<i>ok</i> is set to true.</p>
<p><b>Note:</b> The conversion of the number is performed in the
default C locale, irrespective of the user's locale.</p>
<p>This function was introduced in Qt 4.1.</p>
<p><b>See also</b> <a href="qbytearray.html#number">number</a>().</p>


<h3 class="fn"><a name="toULongLong" />(int, bool&#160;<i>ok</i>) QByteArray.toULongLong (<i>self</i>, int&#160;<i>base</i>&#160;=&#160;10)</h3><p>Returns the byte array converted to an <tt>unsigned long
long</tt> using base <i>base</i>, which is 10 by default and must
be between 2 and 36, or 0.</p>
<p>If <i>base</i> is 0, the base is determined automatically using
the following rules: If the byte array begins with "0x", it is
assumed to be hexadecimal; if it begins with "0", it is assumed to
be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not 0: if a conversion error occurs, *<i>ok</i>
is set to false; otherwise *<i>ok</i> is set to true.</p>
<p><b>Note:</b> The conversion of the number is performed in the
default C locale, irrespective of the user's locale.</p>
<p><b>See also</b> <a href="qbytearray.html#number">number</a>().</p>


<h3 class="fn"><a name="toUpper" /><a href="qbytearray.html">QByteArray</a> QByteArray.toUpper (<i>self</i>)</h3><p>Returns an uppercase copy of the byte array. The bytearray is
interpreted as a Latin-1 encoded string.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> x(<span class="string">"Qt by NOKIA"</span>);
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>toUpper();
 <span class="comment">// y == "QT BY NOKIA"</span>
</pre>
<p><b>See also</b> <a href="qbytearray.html#toLower">toLower</a>()
and <a href="qbytearray.html#8-bit-character-comparisons">8-bit
Character Comparisons</a>.</p>


<h3 class="fn"><a name="toUShort" />(int, bool&#160;<i>ok</i>) QByteArray.toUShort (<i>self</i>, int&#160;<i>base</i>&#160;=&#160;10)</h3><p>Returns the byte array converted to an <tt>unsigned short</tt>
using base <i>base</i>, which is 10 by default and must be between
2 and 36, or 0.</p>
<p>If <i>base</i> is 0, the base is determined automatically using
the following rules: If the byte array begins with "0x", it is
assumed to be hexadecimal; if it begins with "0", it is assumed to
be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not 0: if a conversion error occurs, *<i>ok</i>
is set to false; otherwise *<i>ok</i> is set to true.</p>
<p><b>Note:</b> The conversion of the number is performed in the
default C locale, irrespective of the user's locale.</p>
<p><b>See also</b> <a href="qbytearray.html#number">number</a>().</p>


<h3 class="fn"><a name="trimmed" /><a href="qbytearray.html">QByteArray</a> QByteArray.trimmed (<i>self</i>)</h3><p>Returns a byte array that has whitespace removed from the start
and the end.</p>
<p>Whitespace means any character for which the standard C++
isspace() function returns true. This includes the ASCII characters
'\t', '\n', '\v', '\f', '\r', and ' '.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> ba(<span class="string">"  lots\t of\nwhitespace\r\n "</span>);
 ba <span class="operator">=</span> ba<span class="operator">.</span>trimmed();
 <span class="comment">// ba == "lots\t of\nwhitespace";</span>
</pre>
<p>Unlike <a href="qbytearray.html#simplified">simplified</a>(),
trimmed() leaves internal whitespace alone.</p>
<p><b>See also</b> <a href="qbytearray.html#simplified">simplified</a>().</p>


<h3 class="fn"><a name="truncate" />QByteArray.truncate (<i>self</i>, int&#160;<i>pos</i>)</h3><p>Truncates the byte array at index position <i>pos</i>.</p>
<p>If <i>pos</i> is beyond the end of the array, nothing
happens.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html">QByteArray</a></span> ba(<span class="string">"Stockholm"</span>);
 ba<span class="operator">.</span>truncate(<span class="number">5</span>);             <span class="comment">// ba == "Stock"</span>
</pre>
<p><b>See also</b> <a href="qbytearray.html#chop">chop</a>(),
<a href="qbytearray.html#resize">resize</a>(), and <a href="qbytearray.html#left">left</a>().</p>


<h3 class="fn"><a name="__add__" /><a href="qbytearray.html">QByteArray</a> QByteArray.__add__ (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>a2</i>)</h3><h3 class="fn"><a name="__add__-2" />QString QByteArray.__add__ (<i>self</i>, QString&#160;<i>s</i>)</h3><h3 class="fn"><a name="__contains__" />int QByteArray.__contains__ (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>a</i>)</h3><h3 class="fn"><a name="__eq__" />bool QByteArray.__eq__ (<i>self</i>, QString&#160;<i>s2</i>)</h3><h3 class="fn"><a name="__eq__-2" />bool QByteArray.__eq__ (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>a2</i>)</h3><h3 class="fn"><a name="__ge__" />bool QByteArray.__ge__ (<i>self</i>, QString&#160;<i>s2</i>)</h3><h3 class="fn"><a name="__ge__-2" />bool QByteArray.__ge__ (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>a2</i>)</h3><h3 class="fn"><a name="__getitem__" />str QByteArray.__getitem__ (<i>self</i>, int&#160;<i>i</i>)</h3><h3 class="fn"><a name="__getitem__-2" /><a href="qbytearray.html">QByteArray</a> QByteArray.__getitem__ (<i>self</i>, slice&#160;<i>slice</i>)</h3><h3 class="fn"><a name="__gt__" />bool QByteArray.__gt__ (<i>self</i>, QString&#160;<i>s2</i>)</h3><h3 class="fn"><a name="__gt__-2" />bool QByteArray.__gt__ (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>a2</i>)</h3><h3 class="fn"><a name="__hash__" />int QByteArray.__hash__ (<i>self</i>)</h3><h3 class="fn"><a name="__iadd__" /><a href="qbytearray.html">QByteArray</a> QByteArray.__iadd__ (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>a</i>)</h3><h3 class="fn"><a name="__iadd__-2" /><a href="qbytearray.html">QByteArray</a> QByteArray.__iadd__ (<i>self</i>, QString&#160;<i>s</i>)</h3><h3 class="fn"><a name="__imul__" /><a href="qbytearray.html">QByteArray</a> QByteArray.__imul__ (<i>self</i>, int&#160;<i>m</i>)</h3><h3 class="fn"><a name="__le__" />bool QByteArray.__le__ (<i>self</i>, QString&#160;<i>s2</i>)</h3><h3 class="fn"><a name="__le__-2" />bool QByteArray.__le__ (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>a2</i>)</h3><h3 class="fn"><a name="__len__" /> QByteArray.__len__ (<i>self</i>)</h3><h3 class="fn"><a name="__lt__" />bool QByteArray.__lt__ (<i>self</i>, QString&#160;<i>s2</i>)</h3><h3 class="fn"><a name="__lt__-2" />bool QByteArray.__lt__ (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>a2</i>)</h3><h3 class="fn"><a name="__mul__" /><a href="qbytearray.html">QByteArray</a> QByteArray.__mul__ (<i>self</i>, int&#160;<i>m</i>)</h3><h3 class="fn"><a name="__ne__" />bool QByteArray.__ne__ (<i>self</i>, QString&#160;<i>s2</i>)</h3><h3 class="fn"><a name="__ne__-2" />bool QByteArray.__ne__ (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>a2</i>)</h3><h3 class="fn"><a name="__repr__" />str QByteArray.__repr__ (<i>self</i>)</h3><h3 class="fn"><a name="__str__" />str QByteArray.__str__ (<i>self</i>)</h3><address><hr /><div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address"><td align="left" width="25%">PyQt&#160;4.10 for Windows</td><td align="center" width="50%">Copyright &#169; <a href="http://www.riverbankcomputing.com">Riverbank&#160;Computing&#160;Ltd</a> and <a href="http://www.qtsoftware.com">Nokia</a> 2012</td><td align="right" width="25%">Qt&#160;4.8.4</td></tr></table></div></address></body></html>