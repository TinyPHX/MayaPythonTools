<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html><head><title>QVideoFrame Class Reference</title><style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style></head><body><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr /><td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" width="32" /></td><td width="1">&#160;&#160;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&#160;&#183; <a href="classes.html"><font color="#004faf">All Classes</font></a>&#160;&#183; <a href="modules.html"><font color="#004faf">Modules</font></a></td></table><h1 align="center">QVideoFrame Class Reference<br /><sup><sup>[<a href="qtmultimedia.html">QtMultimedia</a> module]</sup></sup></h1><p>The QVideoFrame class provides a representation of a frame of
video data. <a href="#details">More...</a></p>

<h3>Types</h3><ul><li><div class="fn" />enum <b><a href="qvideoframe.html#FieldType-enum">FieldType</a></b> { ProgressiveFrame, TopField, BottomField, InterlacedFrame }</li><li><div class="fn" />enum <b><a href="qvideoframe.html#PixelFormat-enum">PixelFormat</a></b> { Format_Invalid, Format_ARGB32, Format_ARGB32_Premultiplied, Format_RGB32, ..., Format_User }</li></ul><h3>Methods</h3><ul><li><div class="fn" /><b><a href="qvideoframe.html#QVideoFrame">__init__</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qvideoframe.html#QVideoFrame-2">__init__</a></b> (<i>self</i>, QAbstractVideoBuffer&#160;<i>buffer</i>, QSize&#160;<i>size</i>, PixelFormat&#160;<i>format</i>)</li><li><div class="fn" /><b><a href="qvideoframe.html#QVideoFrame-3">__init__</a></b> (<i>self</i>, int&#160;<i>bytes</i>, QSize&#160;<i>size</i>, int&#160;<i>bytesPerLine</i>, PixelFormat&#160;<i>format</i>)</li><li><div class="fn" /><b><a href="qvideoframe.html#QVideoFrame-4">__init__</a></b> (<i>self</i>, QImage&#160;<i>image</i>)</li><li><div class="fn" /><b><a href="qvideoframe.html#QVideoFrame-5">__init__</a></b> (<i>self</i>, QVideoFrame&#160;<i>other</i>)</li><li><div class="fn" />sip.voidptr <b><a href="qvideoframe.html#bits">bits</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qvideoframe.html#bytesPerLine">bytesPerLine</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qvideoframe.html#endTime">endTime</a></b> (<i>self</i>)</li><li><div class="fn" />FieldType <b><a href="qvideoframe.html#fieldType">fieldType</a></b> (<i>self</i>)</li><li><div class="fn" />QVariant <b><a href="qvideoframe.html#handle">handle</a></b> (<i>self</i>)</li><li><div class="fn" />QAbstractVideoBuffer.HandleType <b><a href="qvideoframe.html#handleType">handleType</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qvideoframe.html#height">height</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qvideoframe.html#isMapped">isMapped</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qvideoframe.html#isReadable">isReadable</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qvideoframe.html#isValid">isValid</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qvideoframe.html#isWritable">isWritable</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qvideoframe.html#map">map</a></b> (<i>self</i>, QAbstractVideoBuffer.MapMode&#160;<i>mode</i>)</li><li><div class="fn" />QAbstractVideoBuffer.MapMode <b><a href="qvideoframe.html#mapMode">mapMode</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qvideoframe.html#mappedBytes">mappedBytes</a></b> (<i>self</i>)</li><li><div class="fn" />PixelFormat <b><a href="qvideoframe.html#pixelFormat">pixelFormat</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qvideoframe.html#setEndTime">setEndTime</a></b> (<i>self</i>, int&#160;<i>time</i>)</li><li><div class="fn" /><b><a href="qvideoframe.html#setFieldType">setFieldType</a></b> (<i>self</i>, FieldType)</li><li><div class="fn" /><b><a href="qvideoframe.html#setStartTime">setStartTime</a></b> (<i>self</i>, int&#160;<i>time</i>)</li><li><div class="fn" />QSize <b><a href="qvideoframe.html#size">size</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qvideoframe.html#startTime">startTime</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qvideoframe.html#unmap">unmap</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qvideoframe.html#width">width</a></b> (<i>self</i>)</li></ul><h3>Static Methods</h3><ul><li><div class="fn" />QImage.Format <b><a href="qvideoframe.html#imageFormatFromPixelFormat">imageFormatFromPixelFormat</a></b> (PixelFormat&#160;<i>format</i>)</li><li><div class="fn" />PixelFormat <b><a href="qvideoframe.html#pixelFormatFromImageFormat">pixelFormatFromImageFormat</a></b> (QImage.Format&#160;<i>format</i>)</li></ul><a name="details" /><hr /><h2>Detailed Description</h2><p>The QVideoFrame class provides a representation of a frame of
video data.</p>
<p>A QVideoFrame encapsulates the data of a video frame, and
information about the frame.</p>
<p>The contents of a video frame can be mapped to memory using the
<a href="qvideoframe.html#map">map</a>() function. While mapped the
video data can accessed using the <a href="qvideoframe.html#bits">bits</a>() function which returns a pointer
to a buffer, the total size of which is given by the <a href="qvideoframe.html#mappedBytes">mappedBytes</a>(), and the size of
each line is given by <a href="qvideoframe.html#bytesPerLine">bytesPerLine</a>(). The return
value of the <a href="qvideoframe.html#handle">handle</a>()
function may be used to access frame data using the internal
buffer's native APIs.</p>
<p>The video data in a QVideoFrame is encapsulated in a <a href="qabstractvideobuffer.html">QAbstractVideoBuffer</a>. A QVideoFrame
may be constructed from any buffer type by subclassing the <a href="qabstractvideobuffer.html">QAbstractVideoBuffer</a> class.</p>
<p><b>Note:</b> QVideoFrame is explicitly shared, any change made
to video frame will also apply to any copies.</p>
<hr /><h2>Type Documentation</h2><h3 class="fn"><a name="FieldType-enum" />QVideoFrame.FieldType</h3><p>Specifies the field an interlaced video frame belongs to.</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.ProgressiveFrame</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">The frame is not interlaced.</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.TopField</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">The frame contains a top field.</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.BottomField</tt></td>
<td class="topAlign"><tt>2</tt></td>
<td class="topAlign">The frame contains a bottom field.</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.InterlacedFrame</tt></td>
<td class="topAlign"><tt>3</tt></td>
<td class="topAlign">The frame contains a merged top and bottom
field.</td>
</tr>
</table>


<h3 class="fn"><a name="PixelFormat-enum" />QVideoFrame.PixelFormat</h3><p>Enumerates video data types.</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_Invalid</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">The frame is invalid.</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_ARGB32</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">The frame is stored using a 32-bit ARGB format
(0xAARRGGBB). This is equivalent to <a href="qimage.html#Format-enum">QImage.Format_ARGB32</a>.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QVideoFrame.Format_ARGB32_Premultiplied</tt></td>
<td class="topAlign"><tt>2</tt></td>
<td class="topAlign">The frame stored using a premultiplied 32-bit
ARGB format (0xAARRGGBB). This is equivalent to <a href="qimage.html#Format-enum">QImage.Format_ARGB32_Premultiplied</a>.</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_RGB32</tt></td>
<td class="topAlign"><tt>3</tt></td>
<td class="topAlign">The frame stored using a 32-bit RGB format
(0xffRRGGBB). This is equivalent to <a href="qimage.html#Format-enum">QImage.Format_RGB32</a></td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_RGB24</tt></td>
<td class="topAlign"><tt>4</tt></td>
<td class="topAlign">The frame is stored using a 24-bit RGB format
(8-8-8). This is equivalent to <a href="qimage.html#Format-enum">QImage.Format_RGB888</a></td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_RGB565</tt></td>
<td class="topAlign"><tt>5</tt></td>
<td class="topAlign">The frame is stored using a 16-bit RGB format
(5-6-5). This is equivalent to <a href="qimage.html#Format-enum">QImage.Format_RGB16</a>.</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_RGB555</tt></td>
<td class="topAlign"><tt>6</tt></td>
<td class="topAlign">The frame is stored using a 16-bit RGB format
(5-5-5). This is equivalent to <a href="qimage.html#Format-enum">QImage.Format_RGB555</a>.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QVideoFrame.Format_ARGB8565_Premultiplied</tt></td>
<td class="topAlign"><tt>7</tt></td>
<td class="topAlign">The frame is stored using a 24-bit
premultiplied ARGB format (8-6-6-5).</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_BGRA32</tt></td>
<td class="topAlign"><tt>8</tt></td>
<td class="topAlign">The frame is stored using a 32-bit ARGB format
(0xBBGGRRAA).</td>
</tr>
<tr>
<td class="topAlign">
<tt>QVideoFrame.Format_BGRA32_Premultiplied</tt></td>
<td class="topAlign"><tt>9</tt></td>
<td class="topAlign">The frame is stored using a premultiplied
32bit BGRA format.</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_BGR32</tt></td>
<td class="topAlign"><tt>10</tt></td>
<td class="topAlign">The frame is stored using a 32-bit BGR format
(0xBBGGRRff).</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_BGR24</tt></td>
<td class="topAlign"><tt>11</tt></td>
<td class="topAlign">The frame is stored using a 24-bit BGR format
(0xBBGGRR).</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_BGR565</tt></td>
<td class="topAlign"><tt>12</tt></td>
<td class="topAlign">The frame is stored using a 16-bit BGR format
(5-6-5).</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_BGR555</tt></td>
<td class="topAlign"><tt>13</tt></td>
<td class="topAlign">The frame is stored using a 16-bit BGR format
(5-5-5).</td>
</tr>
<tr>
<td class="topAlign">
<tt>QVideoFrame.Format_BGRA5658_Premultiplied</tt></td>
<td class="topAlign"><tt>14</tt></td>
<td class="topAlign">The frame is stored using a 24-bit
premultiplied BGRA format (5-6-5-8).</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_AYUV444</tt></td>
<td class="topAlign"><tt>15</tt></td>
<td class="topAlign">The frame is stored using a packed 32-bit AYUV
format (0xAAYYUUVV).</td>
</tr>
<tr>
<td class="topAlign">
<tt>QVideoFrame.Format_AYUV444_Premultiplied</tt></td>
<td class="topAlign"><tt>16</tt></td>
<td class="topAlign">The frame is stored using a packed
premultiplied 32-bit AYUV format (0xAAYYUUVV).</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_YUV444</tt></td>
<td class="topAlign"><tt>17</tt></td>
<td class="topAlign">The frame is stored using a 24-bit packed YUV
format (8-8-8).</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_YUV420P</tt></td>
<td class="topAlign"><tt>18</tt></td>
<td class="topAlign">The frame is stored using an 8-bit per
component planar YUV format with the U and V planes horizontally
and vertically sub-sampled, i.e. the height and width of the U and
V planes are half that of the Y plane.</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_YV12</tt></td>
<td class="topAlign"><tt>19</tt></td>
<td class="topAlign">The frame is stored using an 8-bit per
component planar YVU format with the V and U planes horizontally
and vertically sub-sampled, i.e. the height and width of the V and
U planes are half that of the Y plane.</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_UYVY</tt></td>
<td class="topAlign"><tt>20</tt></td>
<td class="topAlign">The frame is stored using an 8-bit per
component packed YUV format with the U and V planes horizontally
sub-sampled (U-Y-V-Y), i.e. two horizontally adjacent pixels are
stored as a 32-bit macropixel which has a Y value for each pixel
and common U and V values.</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_YUYV</tt></td>
<td class="topAlign"><tt>21</tt></td>
<td class="topAlign">The frame is stored using an 8-bit per
component packed YUV format with the U and V planes horizontally
sub-sampled (Y-U-Y-V), i.e. two horizontally adjacent pixels are
stored as a 32-bit macropixel which has a Y value for each pixel
and common U and V values.</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_NV12</tt></td>
<td class="topAlign"><tt>22</tt></td>
<td class="topAlign">The frame is stored using an 8-bit per
component semi-planar YUV format with a Y plane (Y) followed by a
horizontally and vertically sub-sampled, packed UV plane
(U-V).</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_NV21</tt></td>
<td class="topAlign"><tt>23</tt></td>
<td class="topAlign">The frame is stored using an 8-bit per
component semi-planar YUV format with a Y plane (Y) followed by a
horizontally and vertically sub-sampled, packed VU plane
(V-U).</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_IMC1</tt></td>
<td class="topAlign"><tt>24</tt></td>
<td class="topAlign">The frame is stored using an 8-bit per
component planar YUV format with the U and V planes horizontally
and vertically sub-sampled. This is similar to the Format_YUV420P
type, except that the bytes per line of the U and V planes are
padded out to the same stride as the Y plane.</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_IMC2</tt></td>
<td class="topAlign"><tt>25</tt></td>
<td class="topAlign">The frame is stored using an 8-bit per
component planar YUV format with the U and V planes horizontally
and vertically sub-sampled. This is similar to the Format_YUV420P
type, except that the lines of the U and V planes are interleaved,
i.e. each line of U data is followed by a line of V data creating a
single line of the same stride as the Y data.</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_IMC3</tt></td>
<td class="topAlign"><tt>26</tt></td>
<td class="topAlign">The frame is stored using an 8-bit per
component planar YVU format with the V and U planes horizontally
and vertically sub-sampled. This is similar to the Format_YV12
type, except that the bytes per line of the V and U planes are
padded out to the same stride as the Y plane.</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_IMC4</tt></td>
<td class="topAlign"><tt>27</tt></td>
<td class="topAlign">The frame is stored using an 8-bit per
component planar YVU format with the V and U planes horizontally
and vertically sub-sampled. This is similar to the Format_YV12
type, except that the lines of the V and U planes are interleaved,
i.e. each line of V data is followed by a line of U data creating a
single line of the same stride as the Y data.</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_Y8</tt></td>
<td class="topAlign"><tt>28</tt></td>
<td class="topAlign">The frame is stored using an 8-bit greyscale
format.</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_Y16</tt></td>
<td class="topAlign"><tt>29</tt></td>
<td class="topAlign">The frame is stored using a 16-bit linear
greyscale format. Little endian.</td>
</tr>
<tr>
<td class="topAlign"><tt>QVideoFrame.Format_User</tt></td>
<td class="topAlign"><tt>1000</tt></td>
<td class="topAlign">Start value for user defined pixel
formats.</td>
</tr>
</table>
<hr /><h2>Method Documentation</h2><h3 class="fn"><a name="QVideoFrame" />QVideoFrame.__init__ (<i>self</i>)</h3><p>Constructs a null video frame.</p>


<h3 class="fn"><a name="QVideoFrame-2" />QVideoFrame.__init__ (<i>self</i>, <a href="qabstractvideobuffer.html">QAbstractVideoBuffer</a>&#160;<i>buffer</i>, <a href="qsize.html">QSize</a>&#160;<i>size</i>, <a href="qvideoframe.html#PixelFormat-enum">PixelFormat</a>&#160;<i>format</i>)</h3><p>Constructs a video frame from a <i>buffer</i> of the given pixel
<i>format</i> and <i>size</i> in pixels.</p>
<p><b>Note:</b> This doesn't increment the reference count of the
video buffer.</p>


<h3 class="fn"><a name="QVideoFrame-3" />QVideoFrame.__init__ (<i>self</i>, int&#160;<i>bytes</i>, <a href="qsize.html">QSize</a>&#160;<i>size</i>, int&#160;<i>bytesPerLine</i>, <a href="qvideoframe.html#PixelFormat-enum">PixelFormat</a>&#160;<i>format</i>)</h3><p>Constructs a video frame of the given pixel <i>format</i> and
<i>size</i> in pixels.</p>
<p>The <i>bytesPerLine</i> (stride) is the length of each scan line
in bytes, and <i>bytes</i> is the total number of bytes that must
be allocated for the frame.</p>


<h3 class="fn"><a name="QVideoFrame-4" />QVideoFrame.__init__ (<i>self</i>, <a href="qimage.html">QImage</a>&#160;<i>image</i>)</h3><p>Constructs a video frame from an <i>image</i>.</p>
<p><b>Note:</b> This will construct an invalid video frame if there
is no frame type equivalent to the image format.</p>
<p><b>See also</b> <a href="qvideoframe.html#pixelFormatFromImageFormat">pixelFormatFromImageFormat</a>().</p>


<h3 class="fn"><a name="QVideoFrame-5" />QVideoFrame.__init__ (<i>self</i>, <a href="qvideoframe.html">QVideoFrame</a>&#160;<i>other</i>)</h3><p>Constructs a copy of <i>other</i>.</p>


<h3 class="fn"><a name="bits" />sip.voidptr QVideoFrame.bits (<i>self</i>)</h3><p>Returns a pointer to the start of the frame data buffer.</p>
<p>This value is only valid while the frame data is <a href="qvideoframe.html#map">mapped</a>.</p>
<p><b>See also</b> <a href="qvideoframe.html#map">map</a>(),
<a href="qvideoframe.html#mappedBytes">mappedBytes</a>(), and
<a href="qvideoframe.html#bytesPerLine">bytesPerLine</a>().</p>


<h3 class="fn"><a name="bytesPerLine" />int QVideoFrame.bytesPerLine (<i>self</i>)</h3><p>Returns the number of bytes in a scan line.</p>
<p><b>Note:</b> This is the bytes per line of the first plane only.
The bytes per line of subsequent planes should be calculated as per
the frame type.</p>
<p>This value is only valid while the frame data is <a href="qvideoframe.html#map">mapped</a>.</p>
<p><b>See also</b> <a href="qvideoframe.html#bits">bits</a>(),
<a href="qvideoframe.html#map">map</a>(), and <a href="qvideoframe.html#mappedBytes">mappedBytes</a>().</p>


<h3 class="fn"><a name="endTime" />int QVideoFrame.endTime (<i>self</i>)</h3><p>Returns the presentation time when a frame should stop being
displayed.</p>
<p><b>See also</b> <a href="qvideoframe.html#setEndTime">setEndTime</a>().</p>


<h3 class="fn"><a name="fieldType" /><a href="qvideoframe.html#FieldType-enum">FieldType</a> QVideoFrame.fieldType (<i>self</i>)</h3><p>Returns the field an interlaced video frame belongs to.</p>
<p>If the video is not interlaced this will return WholeFrame.</p>
<p><b>See also</b> <a href="qvideoframe.html#setFieldType">setFieldType</a>().</p>


<h3 class="fn"><a name="handle" />QVariant QVideoFrame.handle (<i>self</i>)</h3><p>Returns a type specific handle to a video frame's buffer.</p>
<p>For an OpenGL texture this would be the texture ID.</p>
<p><b>See also</b> <a href="qabstractvideobuffer.html#handle">QAbstractVideoBuffer.handle</a>().</p>


<h3 class="fn"><a name="handleType" /><a href="qabstractvideobuffer.html#HandleType-enum">QAbstractVideoBuffer.HandleType</a> QVideoFrame.handleType (<i>self</i>)</h3><p>Returns the type of a video frame's handle.</p>


<h3 class="fn"><a name="height" />int QVideoFrame.height (<i>self</i>)</h3><p>Returns the height of a video frame.</p>


<h3 class="fn"><a name="imageFormatFromPixelFormat" /><a href="qimage.html#Format-enum">QImage.Format</a> QVideoFrame.imageFormatFromPixelFormat (<a href="qvideoframe.html#PixelFormat-enum">PixelFormat</a>&#160;<i>format</i>)</h3><p>Returns an image format equivalent to a video frame pixel
<i>format</i>. If there is no equivalent format <a href="qimage.html#Format-enum">QImage.Format_Invalid</a> is returned
instead.</p>


<h3 class="fn"><a name="isMapped" />bool QVideoFrame.isMapped (<i>self</i>)</h3><p>Identifies if a video frame's contents are currently mapped to
system memory.</p>
<p>This is a convenience function which checks that the <a href="qabstractvideobuffer.html#MapMode-enum">MapMode</a> of the frame
is not equal to <a href="qabstractvideobuffer.html#MapMode-enum">QAbstractVideoBuffer.NotMapped</a>.</p>
<p>Returns true if the contents of the video frame are mapped to
system memory, and false otherwise.</p>
<p><b>See also</b> <a href="qvideoframe.html#mapMode">mapMode</a>()
and <a href="qabstractvideobuffer.html#MapMode-enum">QAbstractVideoBuffer.MapMode</a>.</p>


<h3 class="fn"><a name="isReadable" />bool QVideoFrame.isReadable (<i>self</i>)</h3><p>Identifies if the mapped contents of a video frame were read
from the frame when it was mapped.</p>
<p>This is a convenience function which checks if the <a href="qabstractvideobuffer.html#MapMode-enum">MapMode</a> contains the
<a href="qabstractvideobuffer.html#MapMode-enum">QAbstractVideoBuffer.WriteOnly</a>
flag.</p>
<p>Returns true if the contents of the mapped memory were read from
the video frame, and false otherwise.</p>
<p><b>See also</b> <a href="qvideoframe.html#mapMode">mapMode</a>()
and <a href="qabstractvideobuffer.html#MapMode-enum">QAbstractVideoBuffer.MapMode</a>.</p>


<h3 class="fn"><a name="isValid" />bool QVideoFrame.isValid (<i>self</i>)</h3><p>Identifies whether a video frame is valid.</p>
<p>An invalid frame has no video buffer associated with it.</p>
<p>Returns true if the frame is valid, and false if it is not.</p>


<h3 class="fn"><a name="isWritable" />bool QVideoFrame.isWritable (<i>self</i>)</h3><p>Identifies if the mapped contents of a video frame will be
persisted when the frame is unmapped.</p>
<p>This is a convenience function which checks if the <a href="qabstractvideobuffer.html#MapMode-enum">MapMode</a> contains the
<a href="qabstractvideobuffer.html#MapMode-enum">QAbstractVideoBuffer.WriteOnly</a>
flag.</p>
<p>Returns true if the video frame will be updated when unmapped,
and false otherwise.</p>
<p><b>Note:</b> The result of altering the data of a frame that is
mapped in read-only mode is undefined. Depending on the buffer
implementation the changes may be persisted, or worse alter a
shared buffer.</p>
<p><b>See also</b> <a href="qvideoframe.html#mapMode">mapMode</a>()
and <a href="qabstractvideobuffer.html#MapMode-enum">QAbstractVideoBuffer.MapMode</a>.</p>


<h3 class="fn"><a name="map" />bool QVideoFrame.map (<i>self</i>, <a href="qabstractvideobuffer.html#MapMode-enum">QAbstractVideoBuffer.MapMode</a>&#160;<i>mode</i>)</h3><p>Maps the contents of a video frame to memory.</p>
<p>The map <i>mode</i> indicates whether the contents of the mapped
memory should be read from and/or written to the frame. If the map
mode includes the <a href="qabstractvideobuffer.html#MapMode-enum">QAbstractVideoBuffer.ReadOnly</a>
flag the mapped memory will be populated with the content of the
video frame when mapped. If the map mode inclues the <a href="qabstractvideobuffer.html#MapMode-enum">QAbstractVideoBuffer.WriteOnly</a>
flag the content of the mapped memory will be persisted in the
frame when unmapped.</p>
<p>While mapped the contents of a video frame can be accessed
directly through the pointer returned by the <a href="qvideoframe.html#bits">bits</a>() function.</p>
<p>When access to the data is no longer needed be sure to call the
<a href="qvideoframe.html#unmap">unmap</a>() function to release
the mapped memory.</p>
<p>Returns true if the buffer was mapped to memory in the given
<i>mode</i> and false otherwise.</p>
<p><b>See also</b> <a href="qvideoframe.html#unmap">unmap</a>(),
<a href="qvideoframe.html#mapMode">mapMode</a>(), and <a href="qvideoframe.html#bits">bits</a>().</p>


<h3 class="fn"><a name="mapMode" /><a href="qabstractvideobuffer.html#MapMode-enum">QAbstractVideoBuffer.MapMode</a> QVideoFrame.mapMode (<i>self</i>)</h3><p>Returns the mode a video frame was mapped to system memory
in.</p>
<p><b>See also</b> <a href="qvideoframe.html#map">map</a>() and
<a href="qabstractvideobuffer.html#MapMode-enum">QAbstractVideoBuffer.MapMode</a>.</p>


<h3 class="fn"><a name="mappedBytes" />int QVideoFrame.mappedBytes (<i>self</i>)</h3><p>Returns the number of bytes occupied by the mapped frame
data.</p>
<p>This value is only valid while the frame data is <a href="qvideoframe.html#map">mapped</a>.</p>
<p><b>See also</b> <a href="qvideoframe.html#map">map</a>().</p>


<h3 class="fn"><a name="pixelFormat" /><a href="qvideoframe.html#PixelFormat-enum">PixelFormat</a> QVideoFrame.pixelFormat (<i>self</i>)</h3><p>Returns the color format of a video frame.</p>


<h3 class="fn"><a name="pixelFormatFromImageFormat" /><a href="qvideoframe.html#PixelFormat-enum">PixelFormat</a> QVideoFrame.pixelFormatFromImageFormat (<a href="qimage.html#Format-enum">QImage.Format</a>&#160;<i>format</i>)</h3><p>Returns an video pixel format equivalent to an image
<i>format</i>. If there is no equivalent format
QVideoFrame.InvalidType is returned instead.</p>


<h3 class="fn"><a name="setEndTime" />QVideoFrame.setEndTime (<i>self</i>, int&#160;<i>time</i>)</h3><p>Sets the presentation <i>time</i> when a frame should stop being
displayed.</p>
<p><b>See also</b> <a href="qvideoframe.html#endTime">endTime</a>().</p>


<h3 class="fn"><a name="setFieldType" />QVideoFrame.setFieldType (<i>self</i>, <a href="qvideoframe.html#FieldType-enum">FieldType</a>)</h3><p>Sets the <i>field</i> an interlaced video frame belongs to.</p>
<p><b>See also</b> <a href="qvideoframe.html#fieldType">fieldType</a>().</p>


<h3 class="fn"><a name="setStartTime" />QVideoFrame.setStartTime (<i>self</i>, int&#160;<i>time</i>)</h3><p>Sets the presentation <i>time</i> when the frame should be
displayed.</p>
<p><b>See also</b> <a href="qvideoframe.html#startTime">startTime</a>().</p>


<h3 class="fn"><a name="size" /><a href="qsize.html">QSize</a> QVideoFrame.size (<i>self</i>)</h3><p>Returns the size of a video frame.</p>


<h3 class="fn"><a name="startTime" />int QVideoFrame.startTime (<i>self</i>)</h3><p>Returns the presentation time when the frame should be
displayed.</p>
<p><b>See also</b> <a href="qvideoframe.html#setStartTime">setStartTime</a>().</p>


<h3 class="fn"><a name="unmap" />QVideoFrame.unmap (<i>self</i>)</h3><p>Releases the memory mapped by the <a href="qvideoframe.html#map">map</a>() function.</p>
<p>If the <a href="qabstractvideobuffer.html#MapMode-enum">MapMode</a> included the
<a href="qabstractvideobuffer.html#MapMode-enum">QAbstractVideoBuffer.WriteOnly</a>
flag this will persist the current content of the mapped memory to
the video frame.</p>
<p><b>See also</b> <a href="qvideoframe.html#map">map</a>().</p>


<h3 class="fn"><a name="width" />int QVideoFrame.width (<i>self</i>)</h3><p>Returns the width of a video frame.</p>


<address><hr /><div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address"><td align="left" width="25%">PyQt&#160;4.10 for Windows</td><td align="center" width="50%">Copyright &#169; <a href="http://www.riverbankcomputing.com">Riverbank&#160;Computing&#160;Ltd</a> and <a href="http://www.qtsoftware.com">Nokia</a> 2012</td><td align="right" width="25%">Qt&#160;4.8.4</td></tr></table></div></address></body></html>