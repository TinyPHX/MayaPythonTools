<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html><head><title>QWidget Class Reference</title><style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style></head><body><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr /><td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" width="32" /></td><td width="1">&#160;&#160;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&#160;&#183; <a href="classes.html"><font color="#004faf">All Classes</font></a>&#160;&#183; <a href="modules.html"><font color="#004faf">Modules</font></a></td></table><h1 align="center">QWidget Class Reference<br /><sup><sup>[<a href="qtgui.html">QtGui</a> module]</sup></sup></h1><p>The QWidget class is the base class of all user interface
objects. <a href="#details">More...</a></p>

<p>Inherits <a href="qobject.html">QObject</a> and <a href="qpaintdevice.html">QPaintDevice</a>.</p><p>Inherited by <a href="phonon-effectwidget.html">EffectWidget</a>, <a href="phonon-seekslider.html">SeekSlider</a>, <a href="phonon-videoplayer.html">VideoPlayer</a>, <a href="phonon-videowidget.html">VideoWidget</a>, <a href="phonon-volumeslider.html">VolumeSlider</a>, <a href="qabstractbutton.html">QAbstractButton</a>, <a href="qabstractslider.html">QAbstractSlider</a>, <a href="qabstractspinbox.html">QAbstractSpinBox</a>, <a href="qaxwidget.html">QAxWidget</a>, <a href="qcalendarwidget.html">QCalendarWidget</a>, <a href="qcombobox.html">QComboBox</a>, <a href="qdesigneractioneditorinterface.html">QDesignerActionEditorInterface</a>, <a href="qdesignerformwindowinterface.html">QDesignerFormWindowInterface</a>, <a href="qdesignerobjectinspectorinterface.html">QDesignerObjectInspectorInterface</a>, <a href="qdesignerpropertyeditorinterface.html">QDesignerPropertyEditorInterface</a>, <a href="qdesignerwidgetboxinterface.html">QDesignerWidgetBoxInterface</a>, <a href="qdesktopwidget.html">QDesktopWidget</a>, <a href="qdialog.html">QDialog</a>, <a href="qdialogbuttonbox.html">QDialogButtonBox</a>, <a href="qdockwidget.html">QDockWidget</a>, <a href="qfocusframe.html">QFocusFrame</a>, <a href="qframe.html">QFrame</a>, <a href="qglwidget.html">QGLWidget</a>, <a href="qgroupbox.html">QGroupBox</a>, <a href="qhelpsearchquerywidget.html">QHelpSearchQueryWidget</a>, <a href="qhelpsearchresultwidget.html">QHelpSearchResultWidget</a>, <a href="qlineedit.html">QLineEdit</a>, <a href="qmainwindow.html">QMainWindow</a>, <a href="qmdisubwindow.html">QMdiSubWindow</a>, <a href="qmenu.html">QMenu</a>, <a href="qmenubar.html">QMenuBar</a>, <a href="qprintpreviewwidget.html">QPrintPreviewWidget</a>, <a href="qprogressbar.html">QProgressBar</a>, <a href="qrubberband.html">QRubberBand</a>, <a href="qsizegrip.html">QSizeGrip</a>, <a href="qsplashscreen.html">QSplashScreen</a>, <a href="qsplitterhandle.html">QSplitterHandle</a>, <a href="qstatusbar.html">QStatusBar</a>, <a href="qsvgwidget.html">QSvgWidget</a>, <a href="qtabbar.html">QTabBar</a>, <a href="qtabwidget.html">QTabWidget</a>, <a href="qtoolbar.html">QToolBar</a>, <a href="qwebinspector.html">QWebInspector</a>, <a href="qwebview.html">QWebView</a>, <a href="qwizardpage.html">QWizardPage</a> and <a href="qworkspace.html">QWorkspace</a>.</p><h3>Types</h3><ul><li><div class="fn" />enum <b><a href="qwidget.html#RenderFlag-enum">RenderFlag</a></b> { DrawWindowBackground, DrawChildren, IgnoreMask }</li><li><div class="fn" />class <b><a href="qwidget-renderflags.html">RenderFlags</a></b></li></ul><h3>Methods</h3><ul><li><div class="fn" /><b><a href="qwidget.html#QWidget">__init__</a></b> (<i>self</i>, QWidget&#160;<i>parent</i>&#160;=&#160;None, Qt.WindowFlags&#160;<i>flags</i>&#160;=&#160;0)</li><li><div class="fn" />bool <b><a href="qwidget.html#acceptDrops">acceptDrops</a></b> (<i>self</i>)</li><li><div class="fn" />QString <b><a href="qwidget.html#accessibleDescription">accessibleDescription</a></b> (<i>self</i>)</li><li><div class="fn" />QString <b><a href="qwidget.html#accessibleName">accessibleName</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#actionEvent">actionEvent</a></b> (<i>self</i>, QActionEvent)</li><li><div class="fn" />list-of-QAction <b><a href="qwidget.html#actions">actions</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#activateWindow">activateWindow</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#addAction">addAction</a></b> (<i>self</i>, QAction&#160;<i>action</i>)</li><li><div class="fn" /><b><a href="qwidget.html#addActions">addActions</a></b> (<i>self</i>, list-of-QAction&#160;<i>actions</i>)</li><li><div class="fn" /><b><a href="qwidget.html#adjustSize">adjustSize</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qwidget.html#autoFillBackground">autoFillBackground</a></b> (<i>self</i>)</li><li><div class="fn" />QPalette.ColorRole <b><a href="qwidget.html#backgroundRole">backgroundRole</a></b> (<i>self</i>)</li><li><div class="fn" />QSize <b><a href="qwidget.html#baseSize">baseSize</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#changeEvent">changeEvent</a></b> (<i>self</i>, QEvent)</li><li><div class="fn" />QWidget <b><a href="qwidget.html#childAt">childAt</a></b> (<i>self</i>, QPoint&#160;<i>p</i>)</li><li><div class="fn" />QWidget <b><a href="qwidget.html#childAt-2">childAt</a></b> (<i>self</i>, int&#160;<i>ax</i>, int&#160;<i>ay</i>)</li><li><div class="fn" />QRect <b><a href="qwidget.html#childrenRect">childrenRect</a></b> (<i>self</i>)</li><li><div class="fn" />QRegion <b><a href="qwidget.html#childrenRegion">childrenRegion</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#clearFocus">clearFocus</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#clearMask">clearMask</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qwidget.html#close">close</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#closeEvent">closeEvent</a></b> (<i>self</i>, QCloseEvent)</li><li><div class="fn" />QMargins <b><a href="qwidget.html#contentsMargins">contentsMargins</a></b> (<i>self</i>)</li><li><div class="fn" />QRect <b><a href="qwidget.html#contentsRect">contentsRect</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#contextMenuEvent">contextMenuEvent</a></b> (<i>self</i>, QContextMenuEvent)</li><li><div class="fn" />Qt.ContextMenuPolicy <b><a href="qwidget.html#contextMenuPolicy">contextMenuPolicy</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#create">create</a></b> (<i>self</i>, sip.voidptr&#160;<i>window</i>&#160;=&#160;None, bool&#160;<i>initializeWindow</i>&#160;=&#160;True, bool&#160;<i>destroyOldWindow</i>&#160;=&#160;True)</li><li><div class="fn" />QCursor <b><a href="qwidget.html#cursor">cursor</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#destroy">destroy</a></b> (<i>self</i>, bool&#160;<i>destroyWindow</i>&#160;=&#160;True, bool&#160;<i>destroySubWindows</i>&#160;=&#160;True)</li><li><div class="fn" />int <b><a href="qwidget.html#devType">devType</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#dragEnterEvent">dragEnterEvent</a></b> (<i>self</i>, QDragEnterEvent)</li><li><div class="fn" /><b><a href="qwidget.html#dragLeaveEvent">dragLeaveEvent</a></b> (<i>self</i>, QDragLeaveEvent)</li><li><div class="fn" /><b><a href="qwidget.html#dragMoveEvent">dragMoveEvent</a></b> (<i>self</i>, QDragMoveEvent)</li><li><div class="fn" /><b><a href="qwidget.html#dropEvent">dropEvent</a></b> (<i>self</i>, QDropEvent)</li><li><div class="fn" />sip.voidptr <b><a href="qwidget.html#effectiveWinId">effectiveWinId</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#enabledChange">enabledChange</a></b> (<i>self</i>, bool)</li><li><div class="fn" /><b><a href="qwidget.html#ensurePolished">ensurePolished</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#enterEvent">enterEvent</a></b> (<i>self</i>, QEvent)</li><li><div class="fn" />bool <b><a href="qwidget.html#event">event</a></b> (<i>self</i>, QEvent)</li><li><div class="fn" /><b><a href="qwidget.html#focusInEvent">focusInEvent</a></b> (<i>self</i>, QFocusEvent)</li><li><div class="fn" />bool <b><a href="qwidget.html#focusNextChild">focusNextChild</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qwidget.html#focusNextPrevChild">focusNextPrevChild</a></b> (<i>self</i>, bool&#160;<i>next</i>)</li><li><div class="fn" /><b><a href="qwidget.html#focusOutEvent">focusOutEvent</a></b> (<i>self</i>, QFocusEvent)</li><li><div class="fn" />Qt.FocusPolicy <b><a href="qwidget.html#focusPolicy">focusPolicy</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qwidget.html#focusPreviousChild">focusPreviousChild</a></b> (<i>self</i>)</li><li><div class="fn" />QWidget <b><a href="qwidget.html#focusProxy">focusProxy</a></b> (<i>self</i>)</li><li><div class="fn" />QWidget <b><a href="qwidget.html#focusWidget">focusWidget</a></b> (<i>self</i>)</li><li><div class="fn" />QFont <b><a href="qwidget.html#font">font</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#fontChange">fontChange</a></b> (<i>self</i>, QFont)</li><li><div class="fn" />QFontInfo <b><a href="qwidget.html#fontInfo">fontInfo</a></b> (<i>self</i>)</li><li><div class="fn" />QFontMetrics <b><a href="qwidget.html#fontMetrics">fontMetrics</a></b> (<i>self</i>)</li><li><div class="fn" />QPalette.ColorRole <b><a href="qwidget.html#foregroundRole">foregroundRole</a></b> (<i>self</i>)</li><li><div class="fn" />QRect <b><a href="qwidget.html#frameGeometry">frameGeometry</a></b> (<i>self</i>)</li><li><div class="fn" />QSize <b><a href="qwidget.html#frameSize">frameSize</a></b> (<i>self</i>)</li><li><div class="fn" />QRect <b><a href="qwidget.html#geometry">geometry</a></b> (<i>self</i>)</li><li><div class="fn" />(int&#160;<i>left</i>, int&#160;<i>top</i>, int&#160;<i>right</i>, int&#160;<i>bottom</i>) <b><a href="qwidget.html#getContentsMargins">getContentsMargins</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#grabGesture">grabGesture</a></b> (<i>self</i>, Qt.GestureType&#160;<i>type</i>, Qt.GestureFlags&#160;<i>flags</i>&#160;=&#160;Qt.GestureFlags(0))</li><li><div class="fn" /><b><a href="qwidget.html#grabKeyboard">grabKeyboard</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#grabMouse">grabMouse</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#grabMouse-2">grabMouse</a></b> (<i>self</i>, QCursor)</li><li><div class="fn" />int <b><a href="qwidget.html#grabShortcut">grabShortcut</a></b> (<i>self</i>, QKeySequence&#160;<i>key</i>, Qt.ShortcutContext&#160;<i>context</i>&#160;=&#160;Qt.WindowShortcut)</li><li><div class="fn" />QGraphicsEffect <b><a href="qwidget.html#graphicsEffect">graphicsEffect</a></b> (<i>self</i>)</li><li><div class="fn" />QGraphicsProxyWidget <b><a href="qwidget.html#graphicsProxyWidget">graphicsProxyWidget</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qwidget.html#hasFocus">hasFocus</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qwidget.html#hasMouseTracking">hasMouseTracking</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qwidget.html#height">height</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qwidget.html#heightForWidth">heightForWidth</a></b> (<i>self</i>, int)</li><li><div class="fn" /><b><a href="qwidget.html#hide">hide</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#hideEvent">hideEvent</a></b> (<i>self</i>, QHideEvent)</li><li><div class="fn" />QInputContext <b><a href="qwidget.html#inputContext">inputContext</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#inputMethodEvent">inputMethodEvent</a></b> (<i>self</i>, QInputMethodEvent)</li><li><div class="fn" />Qt.InputMethodHints <b><a href="qwidget.html#inputMethodHints">inputMethodHints</a></b> (<i>self</i>)</li><li><div class="fn" />QVariant <b><a href="qwidget.html#inputMethodQuery">inputMethodQuery</a></b> (<i>self</i>, Qt.InputMethodQuery)</li><li><div class="fn" /><b><a href="qwidget.html#insertAction">insertAction</a></b> (<i>self</i>, QAction&#160;<i>before</i>, QAction&#160;<i>action</i>)</li><li><div class="fn" /><b><a href="qwidget.html#insertActions">insertActions</a></b> (<i>self</i>, QAction&#160;<i>before</i>, list-of-QAction&#160;<i>actions</i>)</li><li><div class="fn" />bool <b><a href="qwidget.html#isActiveWindow">isActiveWindow</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qwidget.html#isAncestorOf">isAncestorOf</a></b> (<i>self</i>, QWidget&#160;<i>child</i>)</li><li><div class="fn" />bool <b><a href="qwidget.html#isEnabled">isEnabled</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qwidget.html#isEnabledTo">isEnabledTo</a></b> (<i>self</i>, QWidget)</li><li><div class="fn" />bool <b><a href="qwidget.html#isEnabledToTLW">isEnabledToTLW</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qwidget.html#isFullScreen">isFullScreen</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qwidget.html#isHidden">isHidden</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qwidget.html#isLeftToRight">isLeftToRight</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qwidget.html#isMaximized">isMaximized</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qwidget.html#isMinimized">isMinimized</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qwidget.html#isModal">isModal</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qwidget.html#isRightToLeft">isRightToLeft</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qwidget.html#isTopLevel">isTopLevel</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qwidget.html#isVisible">isVisible</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qwidget.html#isVisibleTo">isVisibleTo</a></b> (<i>self</i>, QWidget)</li><li><div class="fn" />bool <b><a href="qwidget.html#isWindow">isWindow</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qwidget.html#isWindowModified">isWindowModified</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#keyPressEvent">keyPressEvent</a></b> (<i>self</i>, QKeyEvent)</li><li><div class="fn" /><b><a href="qwidget.html#keyReleaseEvent">keyReleaseEvent</a></b> (<i>self</i>, QKeyEvent)</li><li><div class="fn" /><b><a href="qwidget.html#languageChange">languageChange</a></b> (<i>self</i>)</li><li><div class="fn" />QLayout <b><a href="qwidget.html#layout">layout</a></b> (<i>self</i>)</li><li><div class="fn" />Qt.LayoutDirection <b><a href="qwidget.html#layoutDirection">layoutDirection</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#leaveEvent">leaveEvent</a></b> (<i>self</i>, QEvent)</li><li><div class="fn" />QLocale <b><a href="qwidget.html#locale">locale</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#lower">lower</a></b> (<i>self</i>)</li><li><div class="fn" />QPoint <b><a href="qwidget.html#mapFrom">mapFrom</a></b> (<i>self</i>, QWidget, QPoint)</li><li><div class="fn" />QPoint <b><a href="qwidget.html#mapFromGlobal">mapFromGlobal</a></b> (<i>self</i>, QPoint)</li><li><div class="fn" />QPoint <b><a href="qwidget.html#mapFromParent">mapFromParent</a></b> (<i>self</i>, QPoint)</li><li><div class="fn" />QPoint <b><a href="qwidget.html#mapTo">mapTo</a></b> (<i>self</i>, QWidget, QPoint)</li><li><div class="fn" />QPoint <b><a href="qwidget.html#mapToGlobal">mapToGlobal</a></b> (<i>self</i>, QPoint)</li><li><div class="fn" />QPoint <b><a href="qwidget.html#mapToParent">mapToParent</a></b> (<i>self</i>, QPoint)</li><li><div class="fn" />QRegion <b><a href="qwidget.html#mask">mask</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qwidget.html#maximumHeight">maximumHeight</a></b> (<i>self</i>)</li><li><div class="fn" />QSize <b><a href="qwidget.html#maximumSize">maximumSize</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qwidget.html#maximumWidth">maximumWidth</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qwidget.html#metric">metric</a></b> (<i>self</i>, QPaintDevice.PaintDeviceMetric)</li><li><div class="fn" />int <b><a href="qwidget.html#minimumHeight">minimumHeight</a></b> (<i>self</i>)</li><li><div class="fn" />QSize <b><a href="qwidget.html#minimumSize">minimumSize</a></b> (<i>self</i>)</li><li><div class="fn" />QSize <b><a href="qwidget.html#minimumSizeHint">minimumSizeHint</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qwidget.html#minimumWidth">minimumWidth</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#mouseDoubleClickEvent">mouseDoubleClickEvent</a></b> (<i>self</i>, QMouseEvent)</li><li><div class="fn" /><b><a href="qwidget.html#mouseMoveEvent">mouseMoveEvent</a></b> (<i>self</i>, QMouseEvent)</li><li><div class="fn" /><b><a href="qwidget.html#mousePressEvent">mousePressEvent</a></b> (<i>self</i>, QMouseEvent)</li><li><div class="fn" /><b><a href="qwidget.html#mouseReleaseEvent">mouseReleaseEvent</a></b> (<i>self</i>, QMouseEvent)</li><li><div class="fn" /><b><a href="qwidget.html#move">move</a></b> (<i>self</i>, QPoint)</li><li><div class="fn" /><b><a href="qwidget.html#move-2">move</a></b> (<i>self</i>, int&#160;<i>ax</i>, int&#160;<i>ay</i>)</li><li><div class="fn" /><b><a href="qwidget.html#moveEvent">moveEvent</a></b> (<i>self</i>, QMoveEvent)</li><li><div class="fn" />QWidget <b><a href="qwidget.html#nativeParentWidget">nativeParentWidget</a></b> (<i>self</i>)</li><li><div class="fn" />QWidget <b><a href="qwidget.html#nextInFocusChain">nextInFocusChain</a></b> (<i>self</i>)</li><li><div class="fn" />QRect <b><a href="qwidget.html#normalGeometry">normalGeometry</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#overrideWindowFlags">overrideWindowFlags</a></b> (<i>self</i>, Qt.WindowFlags&#160;<i>type</i>)</li><li><div class="fn" /><b><a href="qwidget.html#overrideWindowState">overrideWindowState</a></b> (<i>self</i>, Qt.WindowStates&#160;<i>state</i>)</li><li><div class="fn" />QPaintEngine <b><a href="qwidget.html#paintEngine">paintEngine</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#paintEvent">paintEvent</a></b> (<i>self</i>, QPaintEvent)</li><li><div class="fn" />QPalette <b><a href="qwidget.html#palette">palette</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#paletteChange">paletteChange</a></b> (<i>self</i>, QPalette)</li><li><div class="fn" />QWidget <b><a href="qwidget.html#parentWidget">parentWidget</a></b> (<i>self</i>)</li><li><div class="fn" />QPoint <b><a href="qwidget.html#pos">pos</a></b> (<i>self</i>)</li><li><div class="fn" />QWidget <b><a href="qwidget.html#previousInFocusChain">previousInFocusChain</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#raise">raise_</a></b> (<i>self</i>)</li><li><div class="fn" />QRect <b><a href="qwidget.html#rect">rect</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#releaseKeyboard">releaseKeyboard</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#releaseMouse">releaseMouse</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#releaseShortcut">releaseShortcut</a></b> (<i>self</i>, int&#160;<i>id</i>)</li><li><div class="fn" /><b><a href="qwidget.html#removeAction">removeAction</a></b> (<i>self</i>, QAction&#160;<i>action</i>)</li><li><div class="fn" /><b><a href="qwidget.html#render">render</a></b> (<i>self</i>, QPaintDevice&#160;<i>target</i>, QPoint&#160;<i>targetOffset</i>&#160;=&#160;QPoint(), QRegion&#160;<i>sourceRegion</i>&#160;=&#160;QRegion(), RenderFlags&#160;<i>flags</i>&#160;=&#160;QWidget.DrawWindowBackground|QWidget.DrawChildren)</li><li><div class="fn" /><b><a href="qwidget.html#render-2">render</a></b> (<i>self</i>, QPainter&#160;<i>painter</i>, QPoint&#160;<i>targetOffset</i>&#160;=&#160;QPoint(), QRegion&#160;<i>sourceRegion</i>&#160;=&#160;QRegion(), RenderFlags&#160;<i>flags</i>&#160;=&#160;QWidget.DrawWindowBackground|QWidget.DrawChildren)</li><li><div class="fn" /><b><a href="qwidget.html#repaint">repaint</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#repaint-2">repaint</a></b> (<i>self</i>, int&#160;<i>x</i>, int&#160;<i>y</i>, int&#160;<i>w</i>, int&#160;<i>h</i>)</li><li><div class="fn" /><b><a href="qwidget.html#repaint-3">repaint</a></b> (<i>self</i>, QRect)</li><li><div class="fn" /><b><a href="qwidget.html#repaint-4">repaint</a></b> (<i>self</i>, QRegion)</li><li><div class="fn" /><b><a href="qwidget.html#resetInputContext">resetInputContext</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#resize">resize</a></b> (<i>self</i>, QSize)</li><li><div class="fn" /><b><a href="qwidget.html#resize-2">resize</a></b> (<i>self</i>, int&#160;<i>w</i>, int&#160;<i>h</i>)</li><li><div class="fn" /><b><a href="qwidget.html#resizeEvent">resizeEvent</a></b> (<i>self</i>, QResizeEvent)</li><li><div class="fn" />bool <b><a href="qwidget.html#restoreGeometry">restoreGeometry</a></b> (<i>self</i>, QByteArray&#160;<i>geometry</i>)</li><li><div class="fn" />QByteArray <b><a href="qwidget.html#saveGeometry">saveGeometry</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#scroll">scroll</a></b> (<i>self</i>, int&#160;<i>dx</i>, int&#160;<i>dy</i>)</li><li><div class="fn" /><b><a href="qwidget.html#scroll-2">scroll</a></b> (<i>self</i>, int&#160;<i>dx</i>, int&#160;<i>dy</i>, QRect)</li><li><div class="fn" /><b><a href="qwidget.html#setAcceptDrops">setAcceptDrops</a></b> (<i>self</i>, bool&#160;<i>on</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setAccessibleDescription">setAccessibleDescription</a></b> (<i>self</i>, QString&#160;<i>description</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setAccessibleName">setAccessibleName</a></b> (<i>self</i>, QString&#160;<i>name</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setAttribute">setAttribute</a></b> (<i>self</i>, Qt.WidgetAttribute&#160;<i>attribute</i>, bool&#160;<i>on</i>&#160;=&#160;True)</li><li><div class="fn" /><b><a href="qwidget.html#setAutoFillBackground">setAutoFillBackground</a></b> (<i>self</i>, bool&#160;<i>enabled</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setBackgroundRole">setBackgroundRole</a></b> (<i>self</i>, QPalette.ColorRole)</li><li><div class="fn" /><b><a href="qwidget.html#setBaseSize">setBaseSize</a></b> (<i>self</i>, int&#160;<i>basew</i>, int&#160;<i>baseh</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setBaseSize-2">setBaseSize</a></b> (<i>self</i>, QSize&#160;<i>s</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setContentsMargins">setContentsMargins</a></b> (<i>self</i>, int&#160;<i>left</i>, int&#160;<i>top</i>, int&#160;<i>right</i>, int&#160;<i>bottom</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setContentsMargins-2">setContentsMargins</a></b> (<i>self</i>, QMargins&#160;<i>margins</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setContextMenuPolicy">setContextMenuPolicy</a></b> (<i>self</i>, Qt.ContextMenuPolicy&#160;<i>policy</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setCursor">setCursor</a></b> (<i>self</i>, QCursor)</li><li><div class="fn" /><b><a href="qwidget.html#setDisabled">setDisabled</a></b> (<i>self</i>, bool)</li><li><div class="fn" /><b><a href="qwidget.html#setEnabled">setEnabled</a></b> (<i>self</i>, bool)</li><li><div class="fn" /><b><a href="qwidget.html#setFixedHeight">setFixedHeight</a></b> (<i>self</i>, int&#160;<i>h</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setFixedSize">setFixedSize</a></b> (<i>self</i>, QSize)</li><li><div class="fn" /><b><a href="qwidget.html#setFixedSize-2">setFixedSize</a></b> (<i>self</i>, int&#160;<i>w</i>, int&#160;<i>h</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setFixedWidth">setFixedWidth</a></b> (<i>self</i>, int&#160;<i>w</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setFocus">setFocus</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setFocus-2">setFocus</a></b> (<i>self</i>, Qt.FocusReason&#160;<i>reason</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setFocusPolicy">setFocusPolicy</a></b> (<i>self</i>, Qt.FocusPolicy&#160;<i>policy</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setFocusProxy">setFocusProxy</a></b> (<i>self</i>, QWidget)</li><li><div class="fn" /><b><a href="qwidget.html#setFont">setFont</a></b> (<i>self</i>, QFont)</li><li><div class="fn" /><b><a href="qwidget.html#setForegroundRole">setForegroundRole</a></b> (<i>self</i>, QPalette.ColorRole)</li><li><div class="fn" /><b><a href="qwidget.html#setGeometry">setGeometry</a></b> (<i>self</i>, QRect)</li><li><div class="fn" /><b><a href="qwidget.html#setGeometry-2">setGeometry</a></b> (<i>self</i>, int&#160;<i>ax</i>, int&#160;<i>ay</i>, int&#160;<i>aw</i>, int&#160;<i>ah</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setGraphicsEffect">setGraphicsEffect</a></b> (<i>self</i>, QGraphicsEffect&#160;<i>effect</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setHidden">setHidden</a></b> (<i>self</i>, bool&#160;<i>hidden</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setInputContext">setInputContext</a></b> (<i>self</i>, QInputContext)</li><li><div class="fn" /><b><a href="qwidget.html#setInputMethodHints">setInputMethodHints</a></b> (<i>self</i>, Qt.InputMethodHints&#160;<i>hints</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setLayout">setLayout</a></b> (<i>self</i>, QLayout)</li><li><div class="fn" /><b><a href="qwidget.html#setLayoutDirection">setLayoutDirection</a></b> (<i>self</i>, Qt.LayoutDirection&#160;<i>direction</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setLocale">setLocale</a></b> (<i>self</i>, QLocale&#160;<i>locale</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setMask">setMask</a></b> (<i>self</i>, QBitmap)</li><li><div class="fn" /><b><a href="qwidget.html#setMask-2">setMask</a></b> (<i>self</i>, QRegion)</li><li><div class="fn" /><b><a href="qwidget.html#setMaximumHeight">setMaximumHeight</a></b> (<i>self</i>, int&#160;<i>maxh</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setMaximumSize">setMaximumSize</a></b> (<i>self</i>, int&#160;<i>maxw</i>, int&#160;<i>maxh</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setMaximumSize-2">setMaximumSize</a></b> (<i>self</i>, QSize&#160;<i>s</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setMaximumWidth">setMaximumWidth</a></b> (<i>self</i>, int&#160;<i>maxw</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setMinimumHeight">setMinimumHeight</a></b> (<i>self</i>, int&#160;<i>minh</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setMinimumSize">setMinimumSize</a></b> (<i>self</i>, int&#160;<i>minw</i>, int&#160;<i>minh</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setMinimumSize-2">setMinimumSize</a></b> (<i>self</i>, QSize&#160;<i>s</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setMinimumWidth">setMinimumWidth</a></b> (<i>self</i>, int&#160;<i>minw</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setMouseTracking">setMouseTracking</a></b> (<i>self</i>, bool&#160;<i>enable</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setPalette">setPalette</a></b> (<i>self</i>, QPalette)</li><li><div class="fn" /><b><a href="qwidget.html#setParent">setParent</a></b> (<i>self</i>, QWidget&#160;<i>parent</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setParent-2">setParent</a></b> (<i>self</i>, QWidget&#160;<i>parent</i>, Qt.WindowFlags&#160;<i>f</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setShortcutAutoRepeat">setShortcutAutoRepeat</a></b> (<i>self</i>, int&#160;<i>id</i>, bool&#160;<i>enabled</i>&#160;=&#160;True)</li><li><div class="fn" /><b><a href="qwidget.html#setShortcutEnabled">setShortcutEnabled</a></b> (<i>self</i>, int&#160;<i>id</i>, bool&#160;<i>enabled</i>&#160;=&#160;True)</li><li><div class="fn" /><b><a href="qwidget.html#setShown">setShown</a></b> (<i>self</i>, bool&#160;<i>shown</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setSizeIncrement">setSizeIncrement</a></b> (<i>self</i>, int&#160;<i>w</i>, int&#160;<i>h</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setSizeIncrement-2">setSizeIncrement</a></b> (<i>self</i>, QSize&#160;<i>s</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setSizePolicy">setSizePolicy</a></b> (<i>self</i>, QSizePolicy)</li><li><div class="fn" /><b><a href="qwidget.html#setSizePolicy-2">setSizePolicy</a></b> (<i>self</i>, QSizePolicy.Policy&#160;<i>hor</i>, QSizePolicy.Policy&#160;<i>ver</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setStatusTip">setStatusTip</a></b> (<i>self</i>, QString)</li><li><div class="fn" /><b><a href="qwidget.html#setStyle">setStyle</a></b> (<i>self</i>, QStyle)</li><li><div class="fn" /><b><a href="qwidget.html#setStyleSheet">setStyleSheet</a></b> (<i>self</i>, QString&#160;<i>styleSheet</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setToolTip">setToolTip</a></b> (<i>self</i>, QString)</li><li><div class="fn" /><b><a href="qwidget.html#setUpdatesEnabled">setUpdatesEnabled</a></b> (<i>self</i>, bool&#160;<i>enable</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setVisible">setVisible</a></b> (<i>self</i>, bool&#160;<i>visible</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setWhatsThis">setWhatsThis</a></b> (<i>self</i>, QString)</li><li><div class="fn" /><b><a href="qwidget.html#setWindowFilePath">setWindowFilePath</a></b> (<i>self</i>, QString&#160;<i>filePath</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setWindowFlags">setWindowFlags</a></b> (<i>self</i>, Qt.WindowFlags&#160;<i>type</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setWindowIcon">setWindowIcon</a></b> (<i>self</i>, QIcon&#160;<i>icon</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setWindowIconText">setWindowIconText</a></b> (<i>self</i>, QString)</li><li><div class="fn" /><b><a href="qwidget.html#setWindowModality">setWindowModality</a></b> (<i>self</i>, Qt.WindowModality&#160;<i>windowModality</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setWindowModified">setWindowModified</a></b> (<i>self</i>, bool)</li><li><div class="fn" /><b><a href="qwidget.html#setWindowOpacity">setWindowOpacity</a></b> (<i>self</i>, float&#160;<i>level</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setWindowRole">setWindowRole</a></b> (<i>self</i>, QString)</li><li><div class="fn" /><b><a href="qwidget.html#setWindowState">setWindowState</a></b> (<i>self</i>, Qt.WindowStates&#160;<i>state</i>)</li><li><div class="fn" /><b><a href="qwidget.html#setWindowTitle">setWindowTitle</a></b> (<i>self</i>, QString)</li><li><div class="fn" /><b><a href="qwidget.html#show">show</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#showEvent">showEvent</a></b> (<i>self</i>, QShowEvent)</li><li><div class="fn" /><b><a href="qwidget.html#showFullScreen">showFullScreen</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#showMaximized">showMaximized</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#showMinimized">showMinimized</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#showNormal">showNormal</a></b> (<i>self</i>)</li><li><div class="fn" />QSize <b><a href="qwidget.html#size">size</a></b> (<i>self</i>)</li><li><div class="fn" />QSize <b><a href="qwidget.html#sizeHint">sizeHint</a></b> (<i>self</i>)</li><li><div class="fn" />QSize <b><a href="qwidget.html#sizeIncrement">sizeIncrement</a></b> (<i>self</i>)</li><li><div class="fn" />QSizePolicy <b><a href="qwidget.html#sizePolicy">sizePolicy</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#stackUnder">stackUnder</a></b> (<i>self</i>, QWidget)</li><li><div class="fn" />QString <b><a href="qwidget.html#statusTip">statusTip</a></b> (<i>self</i>)</li><li><div class="fn" />QStyle <b><a href="qwidget.html#style">style</a></b> (<i>self</i>)</li><li><div class="fn" />QString <b><a href="qwidget.html#styleSheet">styleSheet</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#tabletEvent">tabletEvent</a></b> (<i>self</i>, QTabletEvent)</li><li><div class="fn" />bool <b><a href="qwidget.html#testAttribute">testAttribute</a></b> (<i>self</i>, Qt.WidgetAttribute&#160;<i>attribute</i>)</li><li><div class="fn" />QString <b><a href="qwidget.html#toolTip">toolTip</a></b> (<i>self</i>)</li><li><div class="fn" />QWidget <b><a href="qwidget.html#topLevelWidget">topLevelWidget</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qwidget.html#underMouse">underMouse</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#ungrabGesture">ungrabGesture</a></b> (<i>self</i>, Qt.GestureType&#160;<i>type</i>)</li><li><div class="fn" /><b><a href="qwidget.html#unsetCursor">unsetCursor</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#unsetLayoutDirection">unsetLayoutDirection</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#unsetLocale">unsetLocale</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#update">update</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#update-2">update</a></b> (<i>self</i>, QRect)</li><li><div class="fn" /><b><a href="qwidget.html#update-3">update</a></b> (<i>self</i>, QRegion)</li><li><div class="fn" /><b><a href="qwidget.html#update-4">update</a></b> (<i>self</i>, int&#160;<i>ax</i>, int&#160;<i>ay</i>, int&#160;<i>aw</i>, int&#160;<i>ah</i>)</li><li><div class="fn" /><b><a href="qwidget.html#updateGeometry">updateGeometry</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#updateMicroFocus">updateMicroFocus</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qwidget.html#updatesEnabled">updatesEnabled</a></b> (<i>self</i>)</li><li><div class="fn" />QRegion <b><a href="qwidget.html#visibleRegion">visibleRegion</a></b> (<i>self</i>)</li><li><div class="fn" />QString <b><a href="qwidget.html#whatsThis">whatsThis</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#wheelEvent">wheelEvent</a></b> (<i>self</i>, QWheelEvent)</li><li><div class="fn" />int <b><a href="qwidget.html#width">width</a></b> (<i>self</i>)</li><li><div class="fn" />QWidget <b><a href="qwidget.html#window">window</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qwidget.html#windowActivationChange">windowActivationChange</a></b> (<i>self</i>, bool)</li><li><div class="fn" />QString <b><a href="qwidget.html#windowFilePath">windowFilePath</a></b> (<i>self</i>)</li><li><div class="fn" />Qt.WindowFlags <b><a href="qwidget.html#windowFlags">windowFlags</a></b> (<i>self</i>)</li><li><div class="fn" />QIcon <b><a href="qwidget.html#windowIcon">windowIcon</a></b> (<i>self</i>)</li><li><div class="fn" />QString <b><a href="qwidget.html#windowIconText">windowIconText</a></b> (<i>self</i>)</li><li><div class="fn" />Qt.WindowModality <b><a href="qwidget.html#windowModality">windowModality</a></b> (<i>self</i>)</li><li><div class="fn" />float <b><a href="qwidget.html#windowOpacity">windowOpacity</a></b> (<i>self</i>)</li><li><div class="fn" />QString <b><a href="qwidget.html#windowRole">windowRole</a></b> (<i>self</i>)</li><li><div class="fn" />Qt.WindowStates <b><a href="qwidget.html#windowState">windowState</a></b> (<i>self</i>)</li><li><div class="fn" />QString <b><a href="qwidget.html#windowTitle">windowTitle</a></b> (<i>self</i>)</li><li><div class="fn" />Qt.WindowType <b><a href="qwidget.html#windowType">windowType</a></b> (<i>self</i>)</li><li><div class="fn" />(bool, int&#160;<i>result</i>) <b><a href="qwidget.html#winEvent">winEvent</a></b> (<i>self</i>, MSG&#160;<i>message</i>)</li><li><div class="fn" />sip.voidptr <b><a href="qwidget.html#winId">winId</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qwidget.html#x">x</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qwidget.html#y">y</a></b> (<i>self</i>)</li></ul><h3>Static Methods</h3><ul><li><div class="fn" />QWidget <b><a href="qwidget.html#find">find</a></b> (sip.voidptr)</li><li><div class="fn" />QWidget <b><a href="qwidget.html#keyboardGrabber">keyboardGrabber</a></b> ()</li><li><div class="fn" />QWidget <b><a href="qwidget.html#mouseGrabber">mouseGrabber</a></b> ()</li><li><div class="fn" /><b><a href="qwidget.html#setTabOrder">setTabOrder</a></b> (QWidget, QWidget)</li></ul><h3>Qt Signals</h3><ul><li><div class="fn" />void <b><a href="qwidget.html#customContextMenuRequested">customContextMenuRequested</a></b> (const QPoint&amp;)</li></ul><a name="details" /><hr /><h2>Detailed Description</h2><p>The QWidget class is the base class of all user interface
objects.</p>
<p>The widget is the atom of the user interface: it receives mouse,
keyboard and other events from the window system, and paints a
representation of itself on the screen. Every widget is
rectangular, and they are sorted in a Z-order. A widget is clipped
by its parent and by the widgets in front of it.</p>
<p>A widget that is not embedded in a parent widget is called a
window. Usually, windows have a frame and a title bar, although it
is also possible to create windows without such decoration using
suitable <a href="qt.html#WindowType-enum">window flags</a>). In
Qt, <a href="qmainwindow.html">QMainWindow</a> and the various
subclasses of <a href="qdialog.html">QDialog</a> are the most
common window types.</p>
<p>Every widget's constructor accepts one or two standard
arguments:</p>
<ol class="1">
<li><tt>QWidget *parent = 0</tt> is the parent of the new widget.
If it is 0 (the default), the new widget will be a window. If not,
it will be a child of <i>parent</i>, and be constrained by
<i>parent</i>'s geometry (unless you specify <a href="qt.html#WindowType-enum">Qt.Window</a> as window flag).</li>
<li><tt>Qt.WindowFlags f = 0</tt> (where available) sets the
window flags; the default is suitable for almost all widgets, but
to get, for example, a window without a window system frame, you
must use special flags.</li>
</ol>
<p>QWidget has many member functions, but some of them have little
direct functionality; for example, QWidget has a font property, but
never uses this itself. There are many subclasses which provide
real functionality, such as <a href="qlabel.html">QLabel</a>,
<a href="qpushbutton.html">QPushButton</a>, <a href="qlistwidget.html">QListWidget</a>, and <a href="qtabwidget.html">QTabWidget</a>.</p>
<a id="top-level-and-child-widgets" name="top-level-and-child-widgets" />
<h3>Top-Level and Child Widgets</h3>
<p>A widget without a parent widget is always an independent window
(top-level widget). For these widgets, <a href="qwidget.html#windowTitle-prop">setWindowTitle</a>() and <a href="qwidget.html#windowIcon-prop">setWindowIcon</a>() set the title
bar and icon respectively.</p>
<p>Non-window widgets are child widgets, displayed within their
parent widgets. Most widgets in Qt are mainly useful as child
widgets. For example, it is possible to display a button as a
top-level window, but most people prefer to put their buttons
inside other widgets, such as <a href="qdialog.html">QDialog</a>.</p>
<p class="centerAlign"><img alt="A parent widget containing various child widgets." src="images/parent-child-widgets.png" /></p>
<p>The diagram above shows a <a href="qgroupbox.html">QGroupBox</a>
widget being used to hold various child widgets in a layout
provided by <a href="qgridlayout.html">QGridLayout</a>. The
<a href="qlabel.html">QLabel</a> child widgets have been outlined
to indicate their full sizes.</p>
<p>If you want to use a QWidget to hold child widgets you will
usually want to add a layout to the parent QWidget. See <a href="layout.html">Layout Management</a> for more information.</p>
<a id="composite-widgets" name="composite-widgets" />
<h3>Composite Widgets</h3>
<p>When a widget is used as a container to group a number of child
widgets, it is known as a composite widget. These can be created by
constructing a widget with the required visual properties - a
<a href="qframe.html">QFrame</a>, for example - and adding child
widgets to it, usually managed by a layout. The above diagram shows
such a composite widget that was created using <a href="designer-manual.html#qt-designer">Qt Designer</a>.</p>
<p>Composite widgets can also be created by subclassing a standard
widget, such as QWidget or <a href="qframe.html">QFrame</a>, and
adding the necessary layout and child widgets in the constructor of
the subclass. Many of the <a href="all-examples.html">examples
provided with Qt</a> use this approach, and it is also covered in
the Qt <a href="tutorials.html">Tutorials</a>.</p>
<a id="custom-widgets-and-painting" name="custom-widgets-and-painting" />
<h3>Custom Widgets and Painting</h3>
<p>Since QWidget is a subclass of <a href="qpaintdevice.html">QPaintDevice</a>, subclasses can be used to
display custom content that is composed using a series of painting
operations with an instance of the <a href="qpainter.html">QPainter</a> class. This approach contrasts with
the canvas-style approach used by the <a href="graphicsview.html#graphics-view">Graphics View Framework</a> where
items are added to a scene by the application and are rendered by
the framework itself.</p>
<p>Each widget performs all painting operations from within its
<a href="qwidget.html#paintEvent">paintEvent</a>() function. This
is called whenever the widget needs to be redrawn, either as a
result of some external change or when requested by the
application.</p>
<p>The <a href="widgets-analogclock.html">Analog Clock example</a>
shows how a simple widget can handle paint events.</p>
<a id="size-hints-and-size-policies" name="size-hints-and-size-policies" />
<h3>Size Hints and Size Policies</h3>
<p>When implementing a new widget, it is almost always useful to
reimplement <a href="qwidget.html#sizeHint-prop">sizeHint</a>() to
provide a reasonable default size for the widget and to set the
correct size policy with <a href="qwidget.html#sizePolicy-prop">setSizePolicy</a>().</p>
<p>By default, composite widgets which do not provide a size hint
will be sized according to the space requirements of their child
widgets.</p>
<p>The size policy lets you supply good default behavior for the
layout management system, so that other widgets can contain and
manage yours easily. The default size policy indicates that the
size hint represents the preferred size of the widget, and this is
often good enough for many widgets.</p>
<p><b>Note:</b> The size of top-level widgets are constrained to
2/3 of the desktop's height and width. You can <a href="qwidget.html#size-prop">resize</a>() the widget manually if these
bounds are inadequate.</p>
<a id="events" name="events" />
<h3>Events</h3>
<p>Widgets respond to events that are typically caused by user
actions. Qt delivers events to widgets by calling specific event
handler functions with instances of <a href="qevent.html">QEvent</a> subclasses containing information about
each event.</p>
<p>If your widget only contains child widgets, you probably do not
need to implement any event handlers. If you want to detect a mouse
click in a child widget call the child's <a href="qwidget.html#underMouse">underMouse</a>() function inside the
widget's <a href="qwidget.html#mousePressEvent">mousePressEvent</a>().</p>
<p>The <a href="widgets-scribble.html">Scribble example</a>
implements a wider set of events to handle mouse movement, button
presses, and window resizing.</p>
<p>You will need to supply the behavior and content for your own
widgets, but here is a brief overview of the events that are
relevant to QWidget, starting with the most common ones:</p>
<ul>
<li><a href="qwidget.html#paintEvent">paintEvent</a>() is called
whenever the widget needs to be repainted. Every widget displaying
custom content must implement it. Painting using a <a href="qpainter.html">QPainter</a> can only take place in a <a href="qwidget.html#paintEvent">paintEvent</a>() or a function called by
a <a href="qwidget.html#paintEvent">paintEvent</a>().</li>
<li><a href="qwidget.html#resizeEvent">resizeEvent</a>() is called
when the widget has been resized.</li>
<li><a href="qwidget.html#mousePressEvent">mousePressEvent</a>() is
called when a mouse button is pressed while the mouse cursor is
inside the widget, or when the widget has grabbed the mouse using
<a href="qwidget.html#grabMouse">grabMouse</a>(). Pressing the
mouse without releasing it is effectively the same as calling
<a href="qwidget.html#grabMouse">grabMouse</a>().</li>
<li><a href="qwidget.html#mouseReleaseEvent">mouseReleaseEvent</a>() is called
when a mouse button is released. A widget receives mouse release
events when it has received the corresponding mouse press event.
This means that if the user presses the mouse inside <i>your</i>
widget, then drags the mouse somewhere else before releasing the
mouse button, <i>your</i> widget receives the release event. There
is one exception: if a popup menu appears while the mouse button is
held down, this popup immediately steals the mouse events.</li>
<li><a href="qwidget.html#mouseDoubleClickEvent">mouseDoubleClickEvent</a>() is
called when the user double-clicks in the widget. If the user
double-clicks, the widget receives a mouse press event, a mouse
release event and finally this event instead of a second mouse
press event. (Some mouse move events may also be received if the
mouse is not held steady during this operation.) It is <i>not
possible</i> to distinguish a click from a double-click until the
second click arrives. (This is one reason why most GUI books
recommend that double-clicks be an extension of single-clicks,
rather than trigger a different action.)</li>
</ul>
<p>Widgets that accept keyboard input need to reimplement a few
more event handlers:</p>
<ul>
<li><a href="qwidget.html#keyPressEvent">keyPressEvent</a>() is
called whenever a key is pressed, and again when a key has been
held down long enough for it to auto-repeat. The <b>Tab</b> and
<b>Shift+Tab</b> keys are only passed to the widget if they are not
used by the focus-change mechanisms. To force those keys to be
processed by your widget, you must reimplement <a href="qwidget.html#event">QWidget.event</a>().</li>
<li><a href="qwidget.html#focusInEvent">focusInEvent</a>() is
called when the widget gains keyboard focus (assuming you have
called <a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>()). Well-behaved
widgets indicate that they own the keyboard focus in a clear but
discreet way.</li>
<li><a href="qwidget.html#focusOutEvent">focusOutEvent</a>() is
called when the widget loses keyboard focus.</li>
</ul>
<p>You may be required to also reimplement some of the less common
event handlers:</p>
<ul>
<li><a href="qwidget.html#mouseMoveEvent">mouseMoveEvent</a>() is
called whenever the mouse moves while a mouse button is held down.
This can be useful during drag and drop operations. If you call
<a href="qwidget.html#mouseTracking-prop">setMouseTracking</a>(true), you
get mouse move events even when no buttons are held down. (See also
the <a href="dnd.html">Drag and Drop</a> guide.)</li>
<li><a href="qwidget.html#keyReleaseEvent">keyReleaseEvent</a>() is
called whenever a key is released and while it is held down (if the
key is auto-repeating). In that case, the widget will receive a
pair of key release and key press event for every repeat. The
<b>Tab</b> and <b>Shift+Tab</b> keys are only passed to the widget
if they are not used by the focus-change mechanisms. To force those
keys to be processed by your widget, you must reimplement <a href="qwidget.html#event">QWidget.event</a>().</li>
<li><a href="qwidget.html#wheelEvent">wheelEvent</a>() is called
whenever the user turns the mouse wheel while the widget has the
focus.</li>
<li><a href="qwidget.html#enterEvent">enterEvent</a>() is called
when the mouse enters the widget's screen space. (This excludes
screen space owned by any of the widget's children.)</li>
<li><a href="qwidget.html#leaveEvent">leaveEvent</a>() is called
when the mouse leaves the widget's screen space. If the mouse
enters a child widget it will not cause a <a href="qwidget.html#leaveEvent">leaveEvent</a>().</li>
<li><a href="qwidget.html#moveEvent">moveEvent</a>() is called when
the widget has been moved relative to its parent.</li>
<li><a href="qwidget.html#closeEvent">closeEvent</a>() is called
when the user closes the widget (or when <a href="qwidget.html#close">close</a>() is called).</li>
</ul>
<p>There are also some rather obscure events described in the
documentation for <a href="qevent.html#Type-enum">QEvent.Type</a>.
To handle these events, you need to reimplement <a href="qwidget.html#event">event</a>() directly.</p>
<p>The default implementation of <a href="qwidget.html#event">event</a>() handles <b>Tab</b> and
<b>Shift+Tab</b> (to move the keyboard focus), and passes on most
of the other events to one of the more specialized handlers
above.</p>
<p>Events and the mechanism used to deliver them are covered in
<a href="eventsandfilters.html">The Event System</a>.</p>
<a id="groups-of-functions-and-properties" name="groups-of-functions-and-properties" />
<h3>Groups of Functions and Properties</h3>
<table class="generic">
<thead>
<tr class="qt-style">
<th>Context</th>
<th>Functions and Properties</th>
</tr>
</thead>
<tr class="odd" valign="top">
<td>Window functions</td>
<td><a href="qwidget.html#show">show</a>(), <a href="qwidget.html#hide">hide</a>(), <a href="qwidget.html#raise">raise_</a>(), <a href="qwidget.html#lower">lower</a>(), <a href="qwidget.html#close">close</a>().</td>
</tr>
<tr class="even" valign="top">
<td>Top-level windows</td>
<td><a href="qwidget.html#windowModified-prop">windowModified</a>,
<a href="qwidget.html#windowTitle-prop">windowTitle</a>, <a href="qwidget.html#windowIcon-prop">windowIcon</a>, <a href="qwidget.html#windowIconText-prop">windowIconText</a>, <a href="qwidget.html#isActiveWindow-prop">isActiveWindow</a>, <a href="qwidget.html#activateWindow">activateWindow</a>(), <a href="qwidget.html#minimized-prop">minimized</a>, <a href="qwidget.html#showMinimized">showMinimized</a>(), <a href="qwidget.html#maximized-prop">maximized</a>, <a href="qwidget.html#showMaximized">showMaximized</a>(), <a href="qwidget.html#fullScreen-prop">fullScreen</a>, <a href="qwidget.html#showFullScreen">showFullScreen</a>(), <a href="qwidget.html#showNormal">showNormal</a>().</td>
</tr>
<tr class="odd" valign="top">
<td>Window contents</td>
<td><a href="qwidget.html#update">update</a>(), <a href="qwidget.html#repaint">repaint</a>(), <a href="qwidget.html#scroll">scroll</a>().</td>
</tr>
<tr class="even" valign="top">
<td>Geometry</td>
<td><a href="qwidget.html#pos-prop">pos</a>, <a href="qwidget.html#x-prop">x</a>(), <a href="qwidget.html#y-prop">y</a>(), <a href="qwidget.html#rect-prop">rect</a>, <a href="qwidget.html#size-prop">size</a>, <a href="qwidget.html#width-prop">width</a>(), <a href="qwidget.html#height-prop">height</a>(), <a href="qwidget.html#pos-prop">move</a>(), <a href="qwidget.html#size-prop">resize</a>(), <a href="qwidget.html#sizePolicy-prop">sizePolicy</a>, <a href="qwidget.html#sizeHint-prop">sizeHint</a>(), <a href="qwidget.html#minimumSizeHint-prop">minimumSizeHint</a>(), <a href="qwidget.html#updateGeometry">updateGeometry</a>(), <a href="qwidget.html#layout">layout</a>(), <a href="qwidget.html#frameGeometry-prop">frameGeometry</a>, <a href="qwidget.html#geometry-prop">geometry</a>, <a href="qwidget.html#childrenRect-prop">childrenRect</a>, <a href="qwidget.html#childrenRegion-prop">childrenRegion</a>, <a href="qwidget.html#adjustSize">adjustSize</a>(), <a href="qwidget.html#mapFromGlobal">mapFromGlobal</a>(), <a href="qwidget.html#mapToGlobal">mapToGlobal</a>(), <a href="qwidget.html#mapFromParent">mapFromParent</a>(), <a href="qwidget.html#mapToParent">mapToParent</a>(), <a href="qwidget.html#maximumSize-prop">maximumSize</a>, <a href="qwidget.html#minimumSize-prop">minimumSize</a>, <a href="qwidget.html#sizeIncrement-prop">sizeIncrement</a>, <a href="qwidget.html#baseSize-prop">baseSize</a>, <a href="qwidget.html#setFixedSize">setFixedSize</a>()</td>
</tr>
<tr class="odd" valign="top">
<td>Mode</td>
<td><a href="qwidget.html#visible-prop">visible</a>, <a href="qwidget.html#isVisibleTo">isVisibleTo</a>(), <a href="qwidget.html#enabled-prop">enabled</a>, <a href="qwidget.html#isEnabledTo">isEnabledTo</a>(), <a href="qwidget.html#modal-prop">modal</a>, <a href="qwidget.html#isWindow">isWindow</a>(), <a href="qwidget.html#mouseTracking-prop">mouseTracking</a>, <a href="qwidget.html#updatesEnabled-prop">updatesEnabled</a>, <a href="qwidget.html#visibleRegion">visibleRegion</a>().</td>
</tr>
<tr class="even" valign="top">
<td>Look and feel</td>
<td><a href="qwidget.html#style">style</a>(), <a href="qwidget.html#setStyle">setStyle</a>(), <a href="qwidget.html#styleSheet-prop">styleSheet</a>, <a href="qwidget.html#cursor-prop">cursor</a>, <a href="qwidget.html#font-prop">font</a>, <a href="qwidget.html#palette-prop">palette</a>, <a href="qwidget.html#backgroundRole">backgroundRole</a>(), <a href="qwidget.html#setBackgroundRole">setBackgroundRole</a>(), <a href="qwidget.html#fontInfo">fontInfo</a>(), <a href="qwidget.html#fontMetrics">fontMetrics</a>().</td>
</tr>
<tr class="odd" valign="top">
<td>Keyboard focus functions</td>
<td><a href="qwidget.html#focus-prop">focus</a>, <a href="qwidget.html#focusPolicy-prop">focusPolicy</a>, <a href="qwidget.html#setFocus">setFocus</a>(), <a href="qwidget.html#clearFocus">clearFocus</a>(), <a href="qwidget.html#setTabOrder">setTabOrder</a>(), <a href="qwidget.html#setFocusProxy">setFocusProxy</a>(), <a href="qwidget.html#focusNextChild">focusNextChild</a>(), <a href="qwidget.html#focusPreviousChild">focusPreviousChild</a>().</td>
</tr>
<tr class="even" valign="top">
<td>Mouse and keyboard grabbing</td>
<td><a href="qwidget.html#grabMouse">grabMouse</a>(), <a href="qwidget.html#releaseMouse">releaseMouse</a>(), <a href="qwidget.html#grabKeyboard">grabKeyboard</a>(), <a href="qwidget.html#releaseKeyboard">releaseKeyboard</a>(), <a href="qwidget.html#mouseGrabber">mouseGrabber</a>(), <a href="qwidget.html#keyboardGrabber">keyboardGrabber</a>().</td>
</tr>
<tr class="odd" valign="top">
<td>Event handlers</td>
<td><a href="qwidget.html#event">event</a>(), <a href="qwidget.html#mousePressEvent">mousePressEvent</a>(), <a href="qwidget.html#mouseReleaseEvent">mouseReleaseEvent</a>(), <a href="qwidget.html#mouseDoubleClickEvent">mouseDoubleClickEvent</a>(),
<a href="qwidget.html#mouseMoveEvent">mouseMoveEvent</a>(),
<a href="qwidget.html#keyPressEvent">keyPressEvent</a>(), <a href="qwidget.html#keyReleaseEvent">keyReleaseEvent</a>(), <a href="qwidget.html#focusInEvent">focusInEvent</a>(), <a href="qwidget.html#focusOutEvent">focusOutEvent</a>(), <a href="qwidget.html#wheelEvent">wheelEvent</a>(), <a href="qwidget.html#enterEvent">enterEvent</a>(), <a href="qwidget.html#leaveEvent">leaveEvent</a>(), <a href="qwidget.html#paintEvent">paintEvent</a>(), <a href="qwidget.html#moveEvent">moveEvent</a>(), <a href="qwidget.html#resizeEvent">resizeEvent</a>(), <a href="qwidget.html#closeEvent">closeEvent</a>(), <a href="qwidget.html#dragEnterEvent">dragEnterEvent</a>(), <a href="qwidget.html#dragMoveEvent">dragMoveEvent</a>(), <a href="qwidget.html#dragLeaveEvent">dragLeaveEvent</a>(), <a href="qwidget.html#dropEvent">dropEvent</a>(), <a href="qobject.html#childEvent">childEvent</a>(), <a href="qwidget.html#showEvent">showEvent</a>(), <a href="qwidget.html#hideEvent">hideEvent</a>(), <a href="qobject.html#customEvent">customEvent</a>(). <a href="qwidget.html#changeEvent">changeEvent</a>(),</td>
</tr>
<tr class="even" valign="top">
<td>System functions</td>
<td><a href="qwidget.html#parentWidget">parentWidget</a>(),
<a href="qwidget.html#window">window</a>(), <a href="qwidget.html#setParent">setParent</a>(), <a href="qwidget.html#winId">winId</a>(), <a href="qwidget.html#find">find</a>(), <a href="qwidget.html#metric">metric</a>().</td>
</tr>
<tr class="odd" valign="top">
<td>Interactive help</td>
<td><a href="qwidget.html#toolTip-prop">setToolTip</a>(), <a href="qwidget.html#whatsThis-prop">setWhatsThis</a>()</td>
</tr>
</table>
<a id="widget-style-sheets" name="widget-style-sheets" />
<h3>Widget Style Sheets</h3>
<p>In addition to the standard widget styles for each platform,
widgets can also be styled according to rules specified in a
<a href="qwidget.html#styleSheet-prop">style sheet</a>. This
feature enables you to customize the appearance of specific widgets
to provide visual cues to users about their purpose. For example, a
button could be styled in a particular way to indicate that it
performs a destructive action.</p>
<p>The use of widget style sheets is described in more detail in
the <a href="stylesheet.html">Qt Style Sheets</a> document.</p>
<a id="transparency-and-double-buffering" name="transparency-and-double-buffering" />
<h3>Transparency and Double Buffering</h3>
<p>Since Qt 4.0, QWidget automatically double-buffers its painting,
so there is no need to write double-buffering code in <a href="qwidget.html#paintEvent">paintEvent</a>() to avoid flicker.</p>
<p>Since Qt 4.1, the <a href="qt.html#WidgetAttribute-enum">Qt.WA_ContentsPropagated</a> widget
attribute has been deprecated. Instead, the contents of parent
widgets are propagated by default to each of their children as long
as <a href="qt.html#WidgetAttribute-enum">Qt.WA_PaintOnScreen</a>
is not set. Custom widgets can be written to take advantage of this
feature by updating irregular regions (to create non-rectangular
child widgets), or painting with colors that have less than full
alpha component. The following diagram shows how attributes and
properties of a custom widget can be fine-tuned to achieve
different effects.</p>
<p class="centerAlign"><img alt="" src="images/propagation-custom.png" /></p>
<p>In the above diagram, a semi-transparent rectangular child
widget with an area removed is constructed and added to a parent
widget (a <a href="qlabel.html">QLabel</a> showing a pixmap). Then,
different properties and widget attributes are set to achieve
different effects:</p>
<ul>
<li>The left widget has no additional properties or widget
attributes set. This default state suits most custom widgets using
transparency, are irregularly-shaped, or do not paint over their
entire area with an opaque brush.</li>
<li>The center widget has the <a href="qwidget.html#autoFillBackground-prop">autoFillBackground</a>
property set. This property is used with custom widgets that rely
on the widget to supply a default background, and do not paint over
their entire area with an opaque brush.</li>
<li>The right widget has the <a href="qt.html#WidgetAttribute-enum">Qt.WA_OpaquePaintEvent</a> widget
attribute set. This indicates that the widget will paint over its
entire area with opaque colors. The widget's area will initially be
<i>uninitialized</i>, represented in the diagram with a red
diagonal grid pattern that shines through the overpainted area. The
Qt.WA_OpaquePaintArea attribute is useful for widgets that need to
paint their own specialized contents quickly and do not need a
default filled background.</li>
</ul>
<p>To rapidly update custom widgets with simple background colors,
such as real-time plotting or graphing widgets, it is better to
define a suitable background color (using <a href="qwidget.html#setBackgroundRole">setBackgroundRole</a>() with the
<a href="qpalette.html#ColorRole-enum">QPalette.Window</a> role),
set the <a href="qwidget.html#autoFillBackground-prop">autoFillBackground</a>
property, and only implement the necessary drawing functionality in
the widget's <a href="qwidget.html#paintEvent">paintEvent</a>().</p>
<p>To rapidly update custom widgets that constantly paint over
their entire areas with opaque content, e.g., video streaming
widgets, it is better to set the widget's <a href="qt.html#WidgetAttribute-enum">Qt.WA_OpaquePaintEvent</a>,
avoiding any unnecessary overhead associated with repainting the
widget's background.</p>
<p>If a widget has both the <a href="qt.html#WidgetAttribute-enum">Qt.WA_OpaquePaintEvent</a> widget
attribute <i>and</i> the <a href="qwidget.html#autoFillBackground-prop">autoFillBackground</a>
property set, the <a href="qt.html#WidgetAttribute-enum">Qt.WA_OpaquePaintEvent</a>
attribute takes precedence. Depending on your requirements, you
should choose either one of them.</p>
<p>Since Qt 4.1, the contents of parent widgets are also propagated
to standard Qt widgets. This can lead to some unexpected results if
the parent widget is decorated in a non-standard way, as shown in
the diagram below.</p>
<p class="centerAlign"><img alt="" src="images/propagation-standard.png" /></p>
<p>The scope for customizing the painting behavior of standard Qt
widgets, without resorting to subclassing, is slightly less than
that possible for custom widgets. Usually, the desired appearance
of a standard widget can be achieved by setting its <a href="qwidget.html#autoFillBackground-prop">autoFillBackground</a>
property.</p>
<a id="creating-translucent-windows" name="creating-translucent-windows" />
<h3>Creating Translucent Windows</h3>
<p>Since Qt 4.5, it has been possible to create windows with
translucent regions on window systems that support compositing.</p>
<p>To enable this feature in a top-level widget, set its <a href="qt.html#WidgetAttribute-enum">Qt.WA_TranslucentBackground</a>
attribute with <a href="qwidget.html#setAttribute">setAttribute</a>() and ensure that its
background is painted with non-opaque colors in the regions you
want to be partially transparent.</p>
<p>Platform notes:</p>
<ul>
<li>X11: This feature relies on the use of an X server that
supports ARGB visuals and a compositing window manager.</li>
<li>Windows: The widget needs to have the <a href="qt.html#WindowType-enum">Qt.FramelessWindowHint</a> window flag
set for the translucency to work.</li>
</ul>
<a id="native-widgets-vs-alien-widgets" name="native-widgets-vs-alien-widgets" />
<h3>Native Widgets vs Alien Widgets</h3>
<p>Introduced in Qt 4.4, alien widgets are widgets unknown to the
windowing system. They do not have a native window handle
associated with them. This feature significantly speeds up widget
painting, resizing, and removes flicker.</p>
<p>Should you require the old behavior with native windows, you can
choose one of the following options:</p>
<ol class="1">
<li>Use the <tt>QT_USE_NATIVE_WINDOWS=1</tt> in your
environment.</li>
<li>Set the <a href="qt.html#ApplicationAttribute-enum">Qt.AA_NativeWindows</a>
attribute on your application. All widgets will be native
widgets.</li>
<li>Set the <a href="qt.html#WidgetAttribute-enum">Qt.WA_NativeWindow</a> attribute on
widgets: The widget itself and all of its ancestors will become
native (unless <a href="qt.html#WidgetAttribute-enum">Qt.WA_DontCreateNativeAncestors</a>
is set).</li>
<li>Call QWidget.winId to enforce a native window (this implies
3).</li>
<li>Set the <a href="qt.html#WidgetAttribute-enum">Qt.WA_PaintOnScreen</a> attribute
to enforce a native window (this implies 3).</li>
</ol>
<a id="softkeys" name="softkeys" />
<h3>Softkeys</h3>
<p>Since Qt 4.6, Softkeys are usually physical keys on a device
that have a corresponding label or other visual representation on
the screen that is generally located next to its physical
counterpart. They are most often found on mobile phone platforms.
In modern touch based user interfaces it is also possible to have
softkeys that do not correspond to any physical keys. Softkeys
differ from other onscreen labels in that they are contextual.</p>
<p>In Qt, contextual softkeys are added to a widget by calling
<a href="qwidget.html#addAction">addAction</a>() and passing a
<tt>QAction</tt> with a softkey role set on it. When the widget
containing the softkey actions has focus, its softkeys should
appear in the user interface. Softkeys are discovered by traversing
the widget hierarchy so it is possible to define a single set of
softkeys that are present at all times by calling <a href="qwidget.html#addAction">addAction</a>() for a given top level
widget.</p>
<p>On some platforms, this concept overlaps with <tt>QMenuBar</tt>
such that if no other softkeys are found and the top level widget
is a <a href="qmainwindow.html">QMainWindow</a> containing a
<a href="qmenubar.html">QMenuBar</a>, the menubar actions may
appear on one of the softkeys.</p>
<p>Note: Currently softkeys are only supported on the Symbian
Platform.</p>
<hr /><h2>Type Documentation</h2><h3 class="fn"><a name="RenderFlag-enum" />QWidget.RenderFlag</h3><p>This enum describes how to render the widget when calling
<a href="qwidget.html#render">QWidget.render</a>().</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QWidget.DrawWindowBackground</tt></td>
<td class="topAlign"><tt>0x1</tt></td>
<td class="topAlign">If you enable this option, the widget's
background is rendered into the target even if <a href="qwidget.html#autoFillBackground-prop">autoFillBackground</a> is
not set. By default, this option is enabled.</td>
</tr>
<tr>
<td class="topAlign"><tt>QWidget.DrawChildren</tt></td>
<td class="topAlign"><tt>0x2</tt></td>
<td class="topAlign">If you enable this option, the widget's
children are rendered recursively into the target. By default, this
option is enabled.</td>
</tr>
<tr>
<td class="topAlign"><tt>QWidget.IgnoreMask</tt></td>
<td class="topAlign"><tt>0x4</tt></td>
<td class="topAlign">If you enable this option, the widget's
<a href="qwidget.html#mask">QWidget.mask</a>() is ignored when
rendering into the target. By default, this option is
disabled.</td>
</tr>
</table>
<p>This enum was introduced or modified in Qt 4.3.</p>
<p>The RenderFlags type is a typedef for <a href="qflags.html">QFlags</a>&lt;RenderFlag&gt;. It stores an OR
combination of RenderFlag values.</p>
<hr /><h2>Method Documentation</h2><h3 class="fn"><a name="QWidget" />QWidget.__init__ (<i>self</i>, <a href="qwidget.html">QWidget</a>&#160;<i>parent</i>&#160;=&#160;None, <a href="qt-windowflags.html">Qt.WindowFlags</a>&#160;<i>flags</i>&#160;=&#160;0)</h3><p>The <i>parent</i> argument, if not None, causes <i>self</i> to be owned by Qt instead of PyQt.</p><p>Constructs a widget which is a child of <i>parent</i>, with
widget flags set to <i>f</i>.</p>
<p>If <i>parent</i> is 0, the new widget becomes a window. If
<i>parent</i> is another widget, this widget becomes a child window
inside <i>parent</i>. The new widget is deleted when its
<i>parent</i> is deleted.</p>
<p>The widget flags argument, <i>f</i>, is normally 0, but it can
be set to customize the frame of a window (i.e. <i>parent</i> must
be 0). To customize the frame, use a value composed from the
bitwise OR of any of the <a href="qt.html#WindowType-enum">window
flags</a>.</p>
<p>If you add a child widget to an already visible widget you must
explicitly show the child to make it visible.</p>
<p>Note that the X11 version of Qt may not be able to deliver all
combinations of style flags on all systems. This is because on X11,
Qt can only ask the window manager, and the window manager can
override the application's settings. On Windows, Qt can set
whatever flags you want.</p>
<p><b>See also</b> <a href="qwidget.html#windowFlags-prop">windowFlags</a>.</p>


<h3 class="fn"><a name="acceptDrops" />bool QWidget.acceptDrops (<i>self</i>)</h3><h3 class="fn"><a name="accessibleDescription" />QString QWidget.accessibleDescription (<i>self</i>)</h3><h3 class="fn"><a name="accessibleName" />QString QWidget.accessibleName (<i>self</i>)</h3><h3 class="fn"><a name="actionEvent" />QWidget.actionEvent (<i>self</i>, <a href="qactionevent.html">QActionEvent</a>)</h3><p>This event handler is called with the given <i>event</i>
whenever the widget's actions are changed.</p>
<p><b>See also</b> <a href="qwidget.html#addAction">addAction</a>(), <a href="qwidget.html#insertAction">insertAction</a>(), <a href="qwidget.html#removeAction">removeAction</a>(), <a href="qwidget.html#actions">actions</a>(), and <a href="qactionevent.html">QActionEvent</a>.</p>


<h3 class="fn"><a name="actions" />list-of-QAction QWidget.actions (<i>self</i>)</h3><p>Returns the (possibly empty) list of this widget's actions.</p>
<p><b>See also</b> <a href="qwidget.html#contextMenuPolicy-prop">contextMenuPolicy</a>,
<a href="qwidget.html#insertAction">insertAction</a>(), and
<a href="qwidget.html#removeAction">removeAction</a>().</p>


<h3 class="fn"><a name="activateWindow" />QWidget.activateWindow (<i>self</i>)</h3><p>Sets the top-level widget containing this widget to be the
active window.</p>
<p>An active window is a visible top-level window that has the
keyboard input focus.</p>
<p>This function performs the same operation as clicking the mouse
on the title bar of a top-level window. On X11, the result depends
on the Window Manager. If you want to ensure that the window is
stacked on top as well you should also call <a href="qwidget.html#raise">raise_</a>(). Note that the window must be
visible, otherwise activateWindow() has no effect.</p>
<p>On Windows, if you are calling this when the application is not
currently the active one then it will not make it the active
window. It will change the color of the taskbar entry to indicate
that the window has changed in some way. This is because Microsoft
does not allow an application to interrupt what the user is
currently doing in another application.</p>
<p><b>See also</b> <a href="qwidget.html#isActiveWindow-prop">isActiveWindow</a>(), <a href="qwidget.html#window">window</a>(), and <a href="qwidget.html#show">show</a>().</p>


<h3 class="fn"><a name="addAction" />QWidget.addAction (<i>self</i>, <a href="qaction.html">QAction</a>&#160;<i>action</i>)</h3><p>Appends the action <i>action</i> to this widget's list of
actions.</p>
<p>All QWidgets have a list of <a href="qaction.html">QAction</a>s,
however they can be represented graphically in many different ways.
The default use of the <a href="qaction.html">QAction</a> list (as
returned by <a href="qwidget.html#actions">actions</a>()) is to
create a context <a href="qmenu.html">QMenu</a>.</p>
<p>A <a href="qwidget.html">QWidget</a> should only have one of
each action and adding an action it already has will not cause the
same action to be in the widget twice.</p>
<p>The ownership of <i>action</i> is not transferred to this
<a href="qwidget.html">QWidget</a>.</p>
<p><b>See also</b> <a href="qwidget.html#removeAction">removeAction</a>(), <a href="qwidget.html#insertAction">insertAction</a>(), <a href="qwidget.html#actions">actions</a>(), and <a href="qmenu.html">QMenu</a>.</p>


<h3 class="fn"><a name="addActions" />QWidget.addActions (<i>self</i>, list-of-QAction&#160;<i>actions</i>)</h3><p>Appends the actions <i>actions</i> to this widget's list of
actions.</p>
<p><b>See also</b> <a href="qwidget.html#removeAction">removeAction</a>(), <a href="qmenu.html">QMenu</a>, and <a href="qwidget.html#addAction">addAction</a>().</p>


<h3 class="fn"><a name="adjustSize" />QWidget.adjustSize (<i>self</i>)</h3><p>Adjusts the size of the widget to fit its contents.</p>
<p>This function uses <a href="qwidget.html#sizeHint-prop">sizeHint</a>() if it is valid, i.e.,
the size hint's width and height are &gt;= 0. Otherwise, it sets
the size to the children rectangle that covers all child widgets
(the union of all child widget rectangles).</p>
<p>For windows, the screen size is also taken into account. If the
<a href="qwidget.html#sizeHint-prop">sizeHint</a>() is less than
(200, 100) and the size policy is <a href="qsizepolicy.html#Policy-enum">expanding</a>, the window will be at
least (200, 100). The maximum size of a window is 2/3 of the
screen's width and height.</p>
<p><b>See also</b> <a href="qwidget.html#sizeHint-prop">sizeHint</a>() and <a href="qwidget.html#childrenRect-prop">childrenRect</a>().</p>


<h3 class="fn"><a name="autoFillBackground" />bool QWidget.autoFillBackground (<i>self</i>)</h3><h3 class="fn"><a name="backgroundRole" /><a href="qpalette.html#ColorRole-enum">QPalette.ColorRole</a> QWidget.backgroundRole (<i>self</i>)</h3><p>Returns the background role of the widget.</p>
<p>The background role defines the brush from the widget's <a href="qwidget.html#palette-prop">palette</a> that is used to render the
background.</p>
<p>If no explicit background role is set, the widget inherts its
parent widget's background role.</p>
<p><b>See also</b> <a href="qwidget.html#setBackgroundRole">setBackgroundRole</a>() and
<a href="qwidget.html#foregroundRole">foregroundRole</a>().</p>


<h3 class="fn"><a name="baseSize" /><a href="qsize.html">QSize</a> QWidget.baseSize (<i>self</i>)</h3><h3 class="fn"><a name="changeEvent" />QWidget.changeEvent (<i>self</i>, <a href="qevent.html">QEvent</a>)</h3><p>This event handler can be reimplemented to handle state
changes.</p>
<p>The state being changed in this event can be retrieved through
the <i>event</i> supplied.</p>
<p>Change events include: <a href="qevent.html#Type-enum">QEvent.ToolBarChange</a>, <a href="qevent.html#Type-enum">QEvent.ActivationChange</a>, <a href="qevent.html#Type-enum">QEvent.EnabledChange</a>, <a href="qevent.html#Type-enum">QEvent.FontChange</a>, <a href="qevent.html#Type-enum">QEvent.StyleChange</a>, <a href="qevent.html#Type-enum">QEvent.PaletteChange</a>, <a href="qevent.html#Type-enum">QEvent.WindowTitleChange</a>, <a href="qevent.html#Type-enum">QEvent.IconTextChange</a>, <a href="qevent.html#Type-enum">QEvent.ModifiedChange</a>, <a href="qevent.html#Type-enum">QEvent.MouseTrackingChange</a>, <a href="qevent.html#Type-enum">QEvent.ParentChange</a>, <a href="qevent.html#Type-enum">QEvent.WindowStateChange</a>, <a href="qevent.html#Type-enum">QEvent.LanguageChange</a>, <a href="qevent.html#Type-enum">QEvent.LocaleChange</a>, <a href="qevent.html#Type-enum">QEvent.LayoutDirectionChange</a>.</p>


<h3 class="fn"><a name="childAt" /><a href="qwidget.html">QWidget</a> QWidget.childAt (<i>self</i>, <a href="qpoint.html">QPoint</a>&#160;<i>p</i>)</h3><p>Returns the visible child widget at the position (<i>x</i>,
<i>y</i>) in the widget's coordinate system. If there is no visible
child widget at the specified position, the function returns 0.</p>


<h3 class="fn"><a name="childAt-2" /><a href="qwidget.html">QWidget</a> QWidget.childAt (<i>self</i>, int&#160;<i>ax</i>, int&#160;<i>ay</i>)</h3><h3 class="fn"><a name="childrenRect" /><a href="qrect.html">QRect</a> QWidget.childrenRect (<i>self</i>)</h3><h3 class="fn"><a name="childrenRegion" /><a href="qregion.html">QRegion</a> QWidget.childrenRegion (<i>self</i>)</h3><h3 class="fn"><a name="clearFocus" />QWidget.clearFocus (<i>self</i>)</h3><p>Takes keyboard input focus from the widget.</p>
<p>If the widget has active focus, a <a href="qwidget.html#focusOutEvent">focus out event</a> is sent to this
widget to tell it that it is about to lose the focus.</p>
<p>This widget must enable focus setting in order to get the
keyboard input focus, i.e. it must call <a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>().</p>
<p><b>See also</b> <a href="qwidget.html#focus-prop">hasFocus</a>(), <a href="qwidget.html#setFocus">setFocus</a>(), <a href="qwidget.html#focusInEvent">focusInEvent</a>(), <a href="qwidget.html#focusOutEvent">focusOutEvent</a>(), <a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>(), and <a href="qapplication.html#focusWidget">QApplication.focusWidget</a>().</p>


<h3 class="fn"><a name="clearMask" />QWidget.clearMask (<i>self</i>)</h3><p>Removes any mask set by <a href="qwidget.html#setMask">setMask</a>().</p>
<p><b>See also</b> <a href="qwidget.html#setMask">setMask</a>().</p>


<h3 class="fn"><a name="close" />bool QWidget.close (<i>self</i>)</h3><p>This method is also a Qt slot with the C++ signature <tt>bool close()</tt>.</p><p>Closes this widget. Returns true if the widget was closed;
otherwise returns false.</p>
<p>First it sends the widget a <a href="qcloseevent.html">QCloseEvent</a>. The widget is <a href="qwidget.html#hide">hidden</a> if it <a href="qevent.html#accept">accepts</a> the close event. If it <a href="qevent.html#ignore">ignores</a> the event, nothing happens. The
default implementation of <a href="qwidget.html#closeEvent">QWidget.closeEvent</a>() accepts the
close event.</p>
<p>If the widget has the <a href="qt.html#WidgetAttribute-enum">Qt.WA_DeleteOnClose</a> flag, the
widget is also deleted. A close events is delivered to the widget
no matter if the widget is visible or not.</p>
<p>The <a href="qapplication.html#lastWindowClosed">QApplication.lastWindowClosed</a>()
signal is emitted when the last visible primary window (i.e. window
with no parent) with the <a href="qt.html#WidgetAttribute-enum">Qt.WA_QuitOnClose</a> attribute set
is closed. By default this attribute is set for all widgets except
transient windows such as splash screens, tool windows, and popup
menus.</p>


<h3 class="fn"><a name="closeEvent" />QWidget.closeEvent (<i>self</i>, <a href="qcloseevent.html">QCloseEvent</a>)</h3><p>This event handler is called with the given <i>event</i> when Qt
receives a window close request for a top-level widget from the
window system.</p>
<p>By default, the event is accepted and the widget is closed. You
can reimplement this function to change the way the widget responds
to window close requests. For example, you can prevent the window
from closing by calling <a href="qevent.html#ignore">ignore()</a>
on all events.</p>
<p>Main window applications typically use reimplementations of this
function to check whether the user's work has been saved and ask
for permission before closing. For example, the <a href="mainwindows-application.html">Application Example</a> uses a
helper function to determine whether or not to close the
window:</p>
<pre class="cpp">
 <span class="type">void</span> MainWindow<span class="operator">.</span>closeEvent(<span class="type"><a href="qcloseevent.html">QCloseEvent</a></span> <span class="operator">*</span>event)
 {
     <span class="keyword">if</span> (maybeSave()) {
         writeSettings();
         event<span class="operator">-</span><span class="operator">&gt;</span>accept();
     } <span class="keyword">else</span> {
         event<span class="operator">-</span><span class="operator">&gt;</span>ignore();
     }
 }
</pre>
<p><b>See also</b> <a href="qwidget.html#event">event</a>(),
<a href="qwidget.html#hide">hide</a>(), <a href="qwidget.html#close">close</a>(), <a href="qcloseevent.html">QCloseEvent</a>, and <a href="mainwindows-application.html">Application Example</a>.</p>


<h3 class="fn"><a name="contentsMargins" /><a href="qmargins.html">QMargins</a> QWidget.contentsMargins (<i>self</i>)</h3><p>The contentsMargins function returns the widget's contents
margins.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also</b> <a href="qwidget.html#getContentsMargins">getContentsMargins</a>(),
<a href="qwidget.html#setContentsMargins">setContentsMargins</a>(),
and <a href="qwidget.html#contentsRect">contentsRect</a>().</p>


<h3 class="fn"><a name="contentsRect" /><a href="qrect.html">QRect</a> QWidget.contentsRect (<i>self</i>)</h3><p>Returns the area inside the widget's margins.</p>
<p><b>See also</b> <a href="qwidget.html#setContentsMargins">setContentsMargins</a>() and
<a href="qwidget.html#getContentsMargins">getContentsMargins</a>().</p>


<h3 class="fn"><a name="contextMenuEvent" />QWidget.contextMenuEvent (<i>self</i>, <a href="qcontextmenuevent.html">QContextMenuEvent</a>)</h3><p>This event handler, for event <i>event</i>, can be reimplemented
in a subclass to receive widget context menu events.</p>
<p>The handler is called when the widget's <a href="qwidget.html#contextMenuPolicy-prop">contextMenuPolicy</a> is
<a href="qt.html#ContextMenuPolicy-enum">Qt.DefaultContextMenu</a>.</p>
<p>The default implementation ignores the context event. See the
<a href="qcontextmenuevent.html">QContextMenuEvent</a>
documentation for more details.</p>
<p><b>See also</b> <a href="qwidget.html#event">event</a>(),
<a href="qcontextmenuevent.html">QContextMenuEvent</a>, and
<a href="qwidget.html#customContextMenuRequested">customContextMenuRequested</a>().</p>


<h3 class="fn"><a name="contextMenuPolicy" /><a href="qt.html#ContextMenuPolicy-enum">Qt.ContextMenuPolicy</a> QWidget.contextMenuPolicy (<i>self</i>)</h3><h3 class="fn"><a name="create" />QWidget.create (<i>self</i>, sip.voidptr&#160;<i>window</i>&#160;=&#160;None, bool&#160;<i>initializeWindow</i>&#160;=&#160;True, bool&#160;<i>destroyOldWindow</i>&#160;=&#160;True)</h3><p>Creates a new widget window if <i>window</i> is 0, otherwise
sets the widget's window to <i>window</i>.</p>
<p>Initializes the window (sets the geometry etc.) if
<i>initializeWindow</i> is true. If <i>initializeWindow</i> is
false, no initialization is performed. This parameter only makes
sense if <i>window</i> is a valid window.</p>
<p>Destroys the old window if <i>destroyOldWindow</i> is true. If
<i>destroyOldWindow</i> is false, you are responsible for
destroying the window yourself (using platform native code).</p>
<p>The <a href="qwidget.html">QWidget</a> constructor calls
create(0,true,true) to create a window for this widget.</p>


<h3 class="fn"><a name="cursor" /><a href="qcursor.html">QCursor</a> QWidget.cursor (<i>self</i>)</h3><h3 class="fn"><a name="destroy" />QWidget.destroy (<i>self</i>, bool&#160;<i>destroyWindow</i>&#160;=&#160;True, bool&#160;<i>destroySubWindows</i>&#160;=&#160;True)</h3><p>Frees up window system resources. Destroys the widget window if
<i>destroyWindow</i> is true.</p>
<p>destroy() calls itself recursively for all the child widgets,
passing <i>destroySubWindows</i> for the <i>destroyWindow</i>
parameter. To have more control over destruction of subwidgets,
destroy subwidgets selectively first.</p>
<p>This function is usually called from the <a href="qwidget.html">QWidget</a> destructor.</p>


<h3 class="fn"><a name="devType" />int QWidget.devType (<i>self</i>)</h3><h3 class="fn"><a name="dragEnterEvent" />QWidget.dragEnterEvent (<i>self</i>, <a href="qdragenterevent.html">QDragEnterEvent</a>)</h3><p>This event handler is called when a drag is in progress and the
mouse enters this widget. The event is passed in the <i>event</i>
parameter.</p>
<p>If the event is ignored, the widget won't receive any <a href="qwidget.html#dragMoveEvent">drag move events</a>.</p>
<p>See the <a href="dnd.html">Drag-and-drop documentation</a> for
an overview of how to provide drag-and-drop in your
application.</p>
<p><b>See also</b> <a href="qdrag.html">QDrag</a> and <a href="qdragenterevent.html">QDragEnterEvent</a>.</p>


<h3 class="fn"><a name="dragLeaveEvent" />QWidget.dragLeaveEvent (<i>self</i>, <a href="qdragleaveevent.html">QDragLeaveEvent</a>)</h3><p>This event handler is called when a drag is in progress and the
mouse leaves this widget. The event is passed in the <i>event</i>
parameter.</p>
<p>See the <a href="dnd.html">Drag-and-drop documentation</a> for
an overview of how to provide drag-and-drop in your
application.</p>
<p><b>See also</b> <a href="qdrag.html">QDrag</a> and <a href="qdragleaveevent.html">QDragLeaveEvent</a>.</p>


<h3 class="fn"><a name="dragMoveEvent" />QWidget.dragMoveEvent (<i>self</i>, <a href="qdragmoveevent.html">QDragMoveEvent</a>)</h3><p>This event handler is called if a drag is in progress, and when
any of the following conditions occur: the cursor enters this
widget, the cursor moves within this widget, or a modifier key is
pressed on the keyboard while this widget has the focus. The event
is passed in the <i>event</i> parameter.</p>
<p>See the <a href="dnd.html">Drag-and-drop documentation</a> for
an overview of how to provide drag-and-drop in your
application.</p>
<p><b>See also</b> <a href="qdrag.html">QDrag</a> and <a href="qdragmoveevent.html">QDragMoveEvent</a>.</p>


<h3 class="fn"><a name="dropEvent" />QWidget.dropEvent (<i>self</i>, <a href="qdropevent.html">QDropEvent</a>)</h3><p>This event handler is called when the drag is dropped on this
widget. The event is passed in the <i>event</i> parameter.</p>
<p>See the <a href="dnd.html">Drag-and-drop documentation</a> for
an overview of how to provide drag-and-drop in your
application.</p>
<p><b>See also</b> <a href="qdrag.html">QDrag</a> and <a href="qdropevent.html">QDropEvent</a>.</p>


<h3 class="fn"><a name="effectiveWinId" />sip.voidptr QWidget.effectiveWinId (<i>self</i>)</h3><p>Returns the effective window system identifier of the widget,
i.e. the native parent's window system identifier.</p>
<p>If the widget is native, this function returns the native widget
ID. Otherwise, the window ID of the first native parent widget,
i.e., the top-level widget that contains this widget, is
returned.</p>
<p><b>Note:</b> We recommend that you do not store this value as it
is likely to change at run-time.</p>
<p>This function was introduced in Qt 4.4.</p>
<p><b>See also</b> <a href="qwidget.html#nativeParentWidget">nativeParentWidget</a>().</p>


<h3 class="fn"><a name="enabledChange" />QWidget.enabledChange (<i>self</i>, bool)</h3><h3 class="fn"><a name="ensurePolished" />QWidget.ensurePolished (<i>self</i>)</h3><p>Ensures that the widget has been polished by <a href="qstyle.html">QStyle</a> (i.e., has a proper font and palette).</p>
<p><a href="qwidget.html">QWidget</a> calls this function after it
has been fully constructed but before it is shown the very first
time. You can call this function if you want to ensure that the
widget is polished before doing an operation, e.g., the correct
font size might be needed in the widget's <a href="qwidget.html#sizeHint-prop">sizeHint</a>() reimplementation. Note
that this function <i>is</i> called from the default implementation
of <a href="qwidget.html#sizeHint-prop">sizeHint</a>().</p>
<p>Polishing is useful for final initialization that must happen
after all constructors (from base classes as well as from
subclasses) have been called.</p>
<p>If you need to change some settings when a widget is polished,
reimplement <a href="qwidget.html#event">event</a>() and handle the
<a href="qevent.html#Type-enum">QEvent.Polish</a> event type.</p>
<p><b>Note:</b> The function is declared const so that it can be
called from other const functions (e.g., <a href="qwidget.html#sizeHint-prop">sizeHint</a>()).</p>
<p><b>See also</b> <a href="qwidget.html#event">event</a>().</p>


<h3 class="fn"><a name="enterEvent" />QWidget.enterEvent (<i>self</i>, <a href="qevent.html">QEvent</a>)</h3><p>This event handler can be reimplemented in a subclass to receive
widget enter events which are passed in the <i>event</i>
parameter.</p>
<p>An event is sent to the widget when the mouse cursor enters the
widget.</p>
<p><b>See also</b> <a href="qwidget.html#leaveEvent">leaveEvent</a>(), <a href="qwidget.html#mouseMoveEvent">mouseMoveEvent</a>(), and <a href="qwidget.html#event">event</a>().</p>


<h3 class="fn"><a name="event" />bool QWidget.event (<i>self</i>, <a href="qevent.html">QEvent</a>)</h3><p>Reimplemented from <a href="qobject.html#event">QObject.event</a>().</p>
<p>This is the main event handler; it handles event <i>event</i>.
You can reimplement this function in a subclass, but we recommend
using one of the specialized event handlers instead.</p>
<p>Key press and release events are treated differently from other
events. event() checks for Tab and Shift+Tab and tries to move the
focus appropriately. If there is no widget to move the focus to (or
the key press is not Tab or Shift+Tab), event() calls <a href="qwidget.html#keyPressEvent">keyPressEvent</a>().</p>
<p>Mouse and tablet event handling is also slightly special: only
when the widget is <a href="qwidget.html#enabled-prop">enabled</a>,
event() will call the specialized handlers such as <a href="qwidget.html#mousePressEvent">mousePressEvent</a>(); otherwise it
will discard the event.</p>
<p>This function returns true if the event was recognized,
otherwise it returns false. If the recognized event was accepted
(see <a href="qevent.html#accepted-prop">QEvent.accepted</a>), any
further processing such as event propagation to the parent widget
stops.</p>
<p><b>See also</b> <a href="qwidget.html#closeEvent">closeEvent</a>(), <a href="qwidget.html#focusInEvent">focusInEvent</a>(), <a href="qwidget.html#focusOutEvent">focusOutEvent</a>(), <a href="qwidget.html#enterEvent">enterEvent</a>(), <a href="qwidget.html#keyPressEvent">keyPressEvent</a>(), <a href="qwidget.html#keyReleaseEvent">keyReleaseEvent</a>(), <a href="qwidget.html#leaveEvent">leaveEvent</a>(), <a href="qwidget.html#mouseDoubleClickEvent">mouseDoubleClickEvent</a>(),
<a href="qwidget.html#mouseMoveEvent">mouseMoveEvent</a>(),
<a href="qwidget.html#mousePressEvent">mousePressEvent</a>(),
<a href="qwidget.html#mouseReleaseEvent">mouseReleaseEvent</a>(),
<a href="qwidget.html#moveEvent">moveEvent</a>(), <a href="qwidget.html#paintEvent">paintEvent</a>(), <a href="qwidget.html#resizeEvent">resizeEvent</a>(), <a href="qobject.html#event">QObject.event</a>(), and <a href="qobject.html#timerEvent">QObject.timerEvent</a>().</p>


<h3 class="fn"><a name="find" /><a href="qwidget.html">QWidget</a> QWidget.find (sip.voidptr)</h3><p>Returns a pointer to the widget with window identifer/handle
<i>id</i>.</p>
<p>The window identifier type depends on the underlying window
system, see <tt>qwindowdefs.h</tt> for the actual definition. If
there is no widget with this identifier, 0 is returned.</p>


<h3 class="fn"><a name="focusInEvent" />QWidget.focusInEvent (<i>self</i>, <a href="qfocusevent.html">QFocusEvent</a>)</h3><p>This event handler can be reimplemented in a subclass to receive
keyboard focus events (focus received) for the widget. The event is
passed in the <i>event</i> parameter</p>
<p>A widget normally must <a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>() to something
other than <a href="qt.html#FocusPolicy-enum">Qt.NoFocus</a> in
order to receive focus events. (Note that the application
programmer can call <a href="qwidget.html#setFocus">setFocus</a>()
on any widget, even those that do not normally accept focus.)</p>
<p>The default implementation updates the widget (except for
windows that do not specify a <a href="qwidget.html#focusPolicy-prop">focusPolicy</a>()).</p>
<p><b>See also</b> <a href="qwidget.html#focusOutEvent">focusOutEvent</a>(), <a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>(), <a href="qwidget.html#keyPressEvent">keyPressEvent</a>(), <a href="qwidget.html#keyReleaseEvent">keyReleaseEvent</a>(), <a href="qwidget.html#event">event</a>(), and <a href="qfocusevent.html">QFocusEvent</a>.</p>


<h3 class="fn"><a name="focusNextChild" />bool QWidget.focusNextChild (<i>self</i>)</h3><p>Finds a new widget to give the keyboard focus to, as appropriate
for <b>Tab</b>, and returns true if it can find a new widget, or
false if it can't.</p>
<p><b>See also</b> <a href="qwidget.html#focusPreviousChild">focusPreviousChild</a>().</p>


<h3 class="fn"><a name="focusNextPrevChild" />bool QWidget.focusNextPrevChild (<i>self</i>, bool&#160;<i>next</i>)</h3><p>Finds a new widget to give the keyboard focus to, as appropriate
for Tab and Shift+Tab, and returns true if it can find a new
widget, or false if it can't.</p>
<p>If <i>next</i> is true, this function searches forward, if
<i>next</i> is false, it searches backward.</p>
<p>Sometimes, you will want to reimplement this function. For
example, a web browser might reimplement it to move its "current
active link" forward or backward, and call focusNextPrevChild()
only when it reaches the last or first link on the "page".</p>
<p>Child widgets call focusNextPrevChild() on their parent widgets,
but only the window that contains the child widgets decides where
to redirect focus. By reimplementing this function for an object,
you thus gain control of focus traversal for all child widgets.</p>
<p><b>See also</b> <a href="qwidget.html#focusNextChild">focusNextChild</a>() and <a href="qwidget.html#focusPreviousChild">focusPreviousChild</a>().</p>


<h3 class="fn"><a name="focusOutEvent" />QWidget.focusOutEvent (<i>self</i>, <a href="qfocusevent.html">QFocusEvent</a>)</h3><p>This event handler can be reimplemented in a subclass to receive
keyboard focus events (focus lost) for the widget. The events is
passed in the <i>event</i> parameter.</p>
<p>A widget normally must <a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>() to something
other than <a href="qt.html#FocusPolicy-enum">Qt.NoFocus</a> in
order to receive focus events. (Note that the application
programmer can call <a href="qwidget.html#setFocus">setFocus</a>()
on any widget, even those that do not normally accept focus.)</p>
<p>The default implementation updates the widget (except for
windows that do not specify a <a href="qwidget.html#focusPolicy-prop">focusPolicy</a>()).</p>
<p><b>See also</b> <a href="qwidget.html#focusInEvent">focusInEvent</a>(), <a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>(), <a href="qwidget.html#keyPressEvent">keyPressEvent</a>(), <a href="qwidget.html#keyReleaseEvent">keyReleaseEvent</a>(), <a href="qwidget.html#event">event</a>(), and <a href="qfocusevent.html">QFocusEvent</a>.</p>


<h3 class="fn"><a name="focusPolicy" /><a href="qt.html#FocusPolicy-enum">Qt.FocusPolicy</a> QWidget.focusPolicy (<i>self</i>)</h3><h3 class="fn"><a name="focusPreviousChild" />bool QWidget.focusPreviousChild (<i>self</i>)</h3><p>Finds a new widget to give the keyboard focus to, as appropriate
for <b>Shift+Tab</b>, and returns true if it can find a new widget,
or false if it can't.</p>
<p><b>See also</b> <a href="qwidget.html#focusNextChild">focusNextChild</a>().</p>


<h3 class="fn"><a name="focusProxy" /><a href="qwidget.html">QWidget</a> QWidget.focusProxy (<i>self</i>)</h3><p>Returns the focus proxy, or 0 if there is no focus proxy.</p>
<p><b>See also</b> <a href="qwidget.html#setFocusProxy">setFocusProxy</a>().</p>


<h3 class="fn"><a name="focusWidget" /><a href="qwidget.html">QWidget</a> QWidget.focusWidget (<i>self</i>)</h3><p>Returns the last child of this widget that setFocus had been
called on. For top level widgets this is the widget that will get
focus in case this window gets activated</p>
<p>This is not the same as <a href="qapplication.html#focusWidget">QApplication.focusWidget</a>(),
which returns the focus widget in the currently active window.</p>


<h3 class="fn"><a name="font" /><a href="qfont.html">QFont</a> QWidget.font (<i>self</i>)</h3><h3 class="fn"><a name="fontChange" />QWidget.fontChange (<i>self</i>, <a href="qfont.html">QFont</a>)</h3><h3 class="fn"><a name="fontInfo" /><a href="qfontinfo.html">QFontInfo</a> QWidget.fontInfo (<i>self</i>)</h3><p>Returns the font info for the widget's current font. Equivalent
to QFontInto(widget-&gt;<a href="qwidget.html#font-prop">font</a>()).</p>
<p><b>See also</b> <a href="qwidget.html#font-prop">font</a>(),
<a href="qwidget.html#fontMetrics">fontMetrics</a>(), and <a href="qwidget.html#font-prop">setFont</a>().</p>


<h3 class="fn"><a name="fontMetrics" /><a href="qfontmetrics.html">QFontMetrics</a> QWidget.fontMetrics (<i>self</i>)</h3><p>Returns the font metrics for the widget's current font.
Equivalent to <a href="qfontmetrics.html">QFontMetrics</a>(widget-&gt;<a href="qwidget.html#font-prop">font</a>()).</p>
<p><b>See also</b> <a href="qwidget.html#font-prop">font</a>(),
<a href="qwidget.html#fontInfo">fontInfo</a>(), and <a href="qwidget.html#font-prop">setFont</a>().</p>


<h3 class="fn"><a name="foregroundRole" /><a href="qpalette.html#ColorRole-enum">QPalette.ColorRole</a> QWidget.foregroundRole (<i>self</i>)</h3><p>Returns the foreground role.</p>
<p>The foreground role defines the color from the widget's <a href="qwidget.html#palette-prop">palette</a> that is used to draw the
foreground.</p>
<p>If no explicit foreground role is set, the function returns a
role that contrasts with the background role.</p>
<p><b>See also</b> <a href="qwidget.html#setForegroundRole">setForegroundRole</a>() and
<a href="qwidget.html#backgroundRole">backgroundRole</a>().</p>


<h3 class="fn"><a name="frameGeometry" /><a href="qrect.html">QRect</a> QWidget.frameGeometry (<i>self</i>)</h3><h3 class="fn"><a name="frameSize" /><a href="qsize.html">QSize</a> QWidget.frameSize (<i>self</i>)</h3><h3 class="fn"><a name="geometry" /><a href="qrect.html">QRect</a> QWidget.geometry (<i>self</i>)</h3><h3 class="fn"><a name="getContentsMargins" />(int&#160;<i>left</i>, int&#160;<i>top</i>, int&#160;<i>right</i>, int&#160;<i>bottom</i>) QWidget.getContentsMargins (<i>self</i>)</h3><p>Returns the widget's contents margins for <i>left</i>,
<i>top</i>, <i>right</i>, and <i>bottom</i>.</p>
<p><b>See also</b> <a href="qwidget.html#setContentsMargins">setContentsMargins</a>() and
<a href="qwidget.html#contentsRect">contentsRect</a>().</p>


<h3 class="fn"><a name="grabGesture" />QWidget.grabGesture (<i>self</i>, <a href="qt.html#GestureType-enum">Qt.GestureType</a>&#160;<i>type</i>, <a href="qt-gestureflags.html">Qt.GestureFlags</a>&#160;<i>flags</i>&#160;=&#160;Qt.GestureFlags(0))</h3><p>Subscribes the widget to a given <i>gesture</i> with specific
<i>flags</i>.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also</b> <a href="qwidget.html#ungrabGesture">ungrabGesture</a>() and <a href="qgestureevent.html">QGestureEvent</a>.</p>


<h3 class="fn"><a name="grabKeyboard" />QWidget.grabKeyboard (<i>self</i>)</h3><p>Grabs the keyboard input.</p>
<p>This widget receives all keyboard events until <a href="qwidget.html#releaseKeyboard">releaseKeyboard</a>() is called;
other widgets get no keyboard events at all. Mouse events are not
affected. Use <a href="qwidget.html#grabMouse">grabMouse</a>() if
you want to grab that.</p>
<p>The focus widget is not affected, except that it doesn't receive
any keyboard events. <a href="qwidget.html#setFocus">setFocus</a>()
moves the focus as usual, but the new focus widget receives
keyboard events only after <a href="qwidget.html#releaseKeyboard">releaseKeyboard</a>() is called.</p>
<p>If a different widget is currently grabbing keyboard input, that
widget's grab is released first.</p>
<p><b>See also</b> <a href="qwidget.html#releaseKeyboard">releaseKeyboard</a>(), <a href="qwidget.html#grabMouse">grabMouse</a>(), <a href="qwidget.html#releaseMouse">releaseMouse</a>(), and <a href="qwidget.html#focusWidget">focusWidget</a>().</p>


<h3 class="fn"><a name="grabMouse" />QWidget.grabMouse (<i>self</i>)</h3><p>Grabs the mouse input.</p>
<p>This widget receives all mouse events until <a href="qwidget.html#releaseMouse">releaseMouse</a>() is called; other
widgets get no mouse events at all. Keyboard events are not
affected. Use <a href="qwidget.html#grabKeyboard">grabKeyboard</a>() if you want to grab
that.</p>
<p><b>Warning:</b> Bugs in mouse-grabbing applications very often
lock the terminal. Use this function with extreme caution, and
consider using the <tt>-nograb</tt> command line option while
debugging.</p>
<p>It is almost never necessary to grab the mouse when using Qt, as
Qt grabs and releases it sensibly. In particular, Qt grabs the
mouse when a mouse button is pressed and keeps it until the last
button is released.</p>
<p><b>Note:</b> Only visible widgets can grab mouse input. If
<a href="qwidget.html#visible-prop">isVisible</a>() returns false
for a widget, that widget cannot call grabMouse().</p>
<p><b>Note:</b> <b>(Mac OS X developers)</b> For <i>Cocoa</i>,
calling grabMouse() on a widget only works when the mouse is inside
the frame of that widget. For <i>Carbon</i>, it works outside the
widget's frame as well, like for Windows and X11.</p>
<p><b>See also</b> <a href="qwidget.html#releaseMouse">releaseMouse</a>(), <a href="qwidget.html#grabKeyboard">grabKeyboard</a>(), and <a href="qwidget.html#releaseKeyboard">releaseKeyboard</a>().</p>


<h3 class="fn"><a name="grabMouse-2" />QWidget.grabMouse (<i>self</i>, <a href="qcursor.html">QCursor</a>)</h3><p>This function overloads <a href="qwidget.html#grabMouse">grabMouse</a>().</p>
<p>Grabs the mouse input and changes the cursor shape.</p>
<p>The cursor will assume shape <i>cursor</i> (for as long as the
mouse focus is grabbed) and this widget will be the only one to
receive mouse events until <a href="qwidget.html#releaseMouse">releaseMouse</a>() is called().</p>
<p><b>Warning:</b> Grabbing the mouse might lock the terminal.</p>
<p><b>Note:</b> <b>(Mac OS X developers)</b> See the note in
<a href="qwidget.html#grabMouse">QWidget.grabMouse</a>().</p>
<p><b>See also</b> <a href="qwidget.html#releaseMouse">releaseMouse</a>(), <a href="qwidget.html#grabKeyboard">grabKeyboard</a>(), <a href="qwidget.html#releaseKeyboard">releaseKeyboard</a>(), and <a href="qwidget.html#cursor-prop">setCursor</a>().</p>


<h3 class="fn"><a name="grabShortcut" />int QWidget.grabShortcut (<i>self</i>, <a href="qkeysequence.html">QKeySequence</a>&#160;<i>key</i>, <a href="qt.html#ShortcutContext-enum">Qt.ShortcutContext</a>&#160;<i>context</i>&#160;=&#160;Qt.WindowShortcut)</h3><p>Adds a shortcut to Qt's shortcut system that watches for the
given <i>key</i> sequence in the given <i>context</i>. If the
<i>context</i> is <a href="qt.html#ShortcutContext-enum">Qt.ApplicationShortcut</a>, the
shortcut applies to the application as a whole. Otherwise, it is
either local to this widget, <a href="qt.html#ShortcutContext-enum">Qt.WidgetShortcut</a>, or to the
window itself, <a href="qt.html#ShortcutContext-enum">Qt.WindowShortcut</a>.</p>
<p>If the same <i>key</i> sequence has been grabbed by several
widgets, when the <i>key</i> sequence occurs a <a href="qevent.html#Type-enum">QEvent.Shortcut</a> event is sent to all
the widgets to which it applies in a non-deterministic order, but
with the ``ambiguous'' flag set to true.</p>
<p><b>Warning:</b> You should not normally need to use this
function; instead create <a href="qaction.html">QAction</a>s with
the shortcut key sequences you require (if you also want equivalent
menu options and toolbar buttons), or create <a href="qshortcut.html">QShortcut</a>s if you just need key sequences.
Both <a href="qaction.html">QAction</a> and <a href="qshortcut.html">QShortcut</a> handle all the event filtering for
you, and provide signals which are triggered when the user triggers
the key sequence, so are much easier to use than this low-level
function.</p>
<p><b>See also</b> <a href="qwidget.html#releaseShortcut">releaseShortcut</a>() and <a href="qwidget.html#setShortcutEnabled">setShortcutEnabled</a>().</p>


<h3 class="fn"><a name="graphicsEffect" /><a href="qgraphicseffect.html">QGraphicsEffect</a> QWidget.graphicsEffect (<i>self</i>)</h3><p>The graphicsEffect function returns a pointer to the widget's
graphics effect.</p>
<p>If the widget has no graphics effect, 0 is returned.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also</b> <a href="qwidget.html#setGraphicsEffect">setGraphicsEffect</a>().</p>


<h3 class="fn"><a name="graphicsProxyWidget" /><a href="qgraphicsproxywidget.html">QGraphicsProxyWidget</a> QWidget.graphicsProxyWidget (<i>self</i>)</h3><p>Returns the proxy widget for the corresponding embedded widget
in a graphics view; otherwise returns 0.</p>
<p>This function was introduced in Qt 4.5.</p>
<p><b>See also</b> <a href="qgraphicsproxywidget.html#createProxyForChildWidget">QGraphicsProxyWidget.createProxyForChildWidget</a>()
and <a href="qgraphicsscene.html#addWidget">QGraphicsScene.addWidget</a>().</p>


<h3 class="fn"><a name="hasFocus" />bool QWidget.hasFocus (<i>self</i>)</h3><h3 class="fn"><a name="hasMouseTracking" />bool QWidget.hasMouseTracking (<i>self</i>)</h3><h3 class="fn"><a name="height" />int QWidget.height (<i>self</i>)</h3><h3 class="fn"><a name="heightForWidth" />int QWidget.heightForWidth (<i>self</i>, int)</h3><p>Returns the preferred height for this widget, given the width
<i>w</i>.</p>
<p>If this widget has a layout, the default implementation returns
the layout's preferred height. if there is no layout, the default
implementation returns -1 indicating that the preferred height does
not depend on the width.</p>


<h3 class="fn"><a name="hide" />QWidget.hide (<i>self</i>)</h3><p>This method is also a Qt slot with the C++ signature <tt>void hide()</tt>.</p><p>Hides the widget. This function is equivalent to
setVisible(false).</p>
<p><b>Note:</b> If you are working with <a href="qdialog.html">QDialog</a> or its subclasses and you invoke the
<a href="qwidget.html#show">show</a>() function after this
function, the dialog will be displayed in its original
position.</p>
<p><b>See also</b> <a href="qwidget.html#hideEvent">hideEvent</a>(), <a href="qwidget.html#isHidden">isHidden</a>(), <a href="qwidget.html#show">show</a>(), <a href="qwidget.html#visible-prop">setVisible</a>(), <a href="qwidget.html#visible-prop">isVisible</a>(), and <a href="qwidget.html#close">close</a>().</p>


<h3 class="fn"><a name="hideEvent" />QWidget.hideEvent (<i>self</i>, <a href="qhideevent.html">QHideEvent</a>)</h3><p>This event handler can be reimplemented in a subclass to receive
widget hide events. The event is passed in the <i>event</i>
parameter.</p>
<p>Hide events are sent to widgets immediately after they have been
hidden.</p>
<p>Note: A widget receives spontaneous show and hide events when
its mapping status is changed by the window system, e.g. a
spontaneous hide event when the user minimizes the window, and a
spontaneous show event when the window is restored again. After
receiving a spontaneous hide event, a widget is still considered
visible in the sense of <a href="qwidget.html#visible-prop">isVisible</a>().</p>
<p><b>See also</b> <a href="qwidget.html#visible-prop">visible</a>,
<a href="qwidget.html#event">event</a>(), and <a href="qhideevent.html">QHideEvent</a>.</p>


<h3 class="fn"><a name="inputContext" /><a href="qinputcontext.html">QInputContext</a> QWidget.inputContext (<i>self</i>)</h3><p>This function returns the <a href="qinputcontext.html">QInputContext</a> for this widget. By default
the input context is inherited from the widgets parent. For
toplevels it is inherited from <a href="qapplication.html">QApplication</a>.</p>
<p>You can override this and set a special input context for this
widget by using the <a href="qwidget.html#setInputContext">setInputContext</a>() method.</p>
<p><b>See also</b> <a href="qwidget.html#setInputContext">setInputContext</a>().</p>


<h3 class="fn"><a name="inputMethodEvent" />QWidget.inputMethodEvent (<i>self</i>, <a href="qinputmethodevent.html">QInputMethodEvent</a>)</h3><p>This event handler, for event <i>event</i>, can be reimplemented
in a subclass to receive Input Method composition events. This
handler is called when the state of the input method changes.</p>
<p>Note that when creating custom text editing widgets, the
<a href="qt.html#WidgetAttribute-enum">Qt.WA_InputMethodEnabled</a>
window attribute must be set explicitly (using the <a href="qwidget.html#setAttribute">setAttribute</a>() function) in order
to receive input method events.</p>
<p>The default implementation calls event-&gt;ignore(), which
rejects the Input Method event. See the <a href="qinputmethodevent.html">QInputMethodEvent</a> documentation for
more details.</p>
<p><b>See also</b> <a href="qwidget.html#event">event</a>() and
<a href="qinputmethodevent.html">QInputMethodEvent</a>.</p>


<h3 class="fn"><a name="inputMethodHints" /><a href="qt-inputmethodhints.html">Qt.InputMethodHints</a> QWidget.inputMethodHints (<i>self</i>)</h3><h3 class="fn"><a name="inputMethodQuery" />QVariant QWidget.inputMethodQuery (<i>self</i>, <a href="qt.html#InputMethodQuery-enum">Qt.InputMethodQuery</a>)</h3><p>This method is only relevant for input widgets. It is used by
the input method to query a set of properties of the widget to be
able to support complex input method operations as support for
surrounding text and reconversions.</p>
<p><i>query</i> specifies which property is queried.</p>
<p><b>See also</b> <a href="qwidget.html#inputMethodEvent">inputMethodEvent</a>(), <a href="qinputmethodevent.html">QInputMethodEvent</a>, <a href="qinputcontext.html">QInputContext</a>, and <a href="qwidget.html#inputMethodHints-prop">inputMethodHints</a>.</p>


<h3 class="fn"><a name="insertAction" />QWidget.insertAction (<i>self</i>, <a href="qaction.html">QAction</a>&#160;<i>before</i>, <a href="qaction.html">QAction</a>&#160;<i>action</i>)</h3><p>Inserts the action <i>action</i> to this widget's list of
actions, before the action <i>before</i>. It appends the action if
<i>before</i> is 0 or <i>before</i> is not a valid action for this
widget.</p>
<p>A <a href="qwidget.html">QWidget</a> should only have one of
each action.</p>
<p><b>See also</b> <a href="qwidget.html#removeAction">removeAction</a>(), <a href="qwidget.html#addAction">addAction</a>(), <a href="qmenu.html">QMenu</a>, <a href="qwidget.html#contextMenuPolicy-prop">contextMenuPolicy</a>, and
<a href="qwidget.html#actions">actions</a>().</p>


<h3 class="fn"><a name="insertActions" />QWidget.insertActions (<i>self</i>, <a href="qaction.html">QAction</a>&#160;<i>before</i>, list-of-QAction&#160;<i>actions</i>)</h3><p>Inserts the actions <i>actions</i> to this widget's list of
actions, before the action <i>before</i>. It appends the action if
<i>before</i> is 0 or <i>before</i> is not a valid action for this
widget.</p>
<p>A <a href="qwidget.html">QWidget</a> can have at most one of
each action.</p>
<p><b>See also</b> <a href="qwidget.html#removeAction">removeAction</a>(), <a href="qmenu.html">QMenu</a>, <a href="qwidget.html#insertAction">insertAction</a>(), and <a href="qwidget.html#contextMenuPolicy-prop">contextMenuPolicy</a>.</p>


<h3 class="fn"><a name="isActiveWindow" />bool QWidget.isActiveWindow (<i>self</i>)</h3><h3 class="fn"><a name="isAncestorOf" />bool QWidget.isAncestorOf (<i>self</i>, <a href="qwidget.html">QWidget</a>&#160;<i>child</i>)</h3><p>Returns true if this widget is a parent, (or grandparent and so
on to any level), of the given <i>child</i>, and both widgets are
within the same window; otherwise returns false.</p>


<h3 class="fn"><a name="isEnabled" />bool QWidget.isEnabled (<i>self</i>)</h3><h3 class="fn"><a name="isEnabledTo" />bool QWidget.isEnabledTo (<i>self</i>, <a href="qwidget.html">QWidget</a>)</h3><p>Returns true if this widget would become enabled if
<i>ancestor</i> is enabled; otherwise returns false.</p>
<p>This is the case if neither the widget itself nor every parent
up to but excluding <i>ancestor</i> has been explicitly
disabled.</p>
<p>isEnabledTo(0) is equivalent to <a href="qwidget.html#enabled-prop">isEnabled</a>().</p>
<p><b>See also</b> <a href="qwidget.html#enabled-prop">setEnabled</a>() and <a href="qwidget.html#enabled-prop">enabled</a>.</p>


<h3 class="fn"><a name="isEnabledToTLW" />bool QWidget.isEnabledToTLW (<i>self</i>)</h3><h3 class="fn"><a name="isFullScreen" />bool QWidget.isFullScreen (<i>self</i>)</h3><h3 class="fn"><a name="isHidden" />bool QWidget.isHidden (<i>self</i>)</h3><p>Returns true if the widget is hidden, otherwise returns
false.</p>
<p>A hidden widget will only become visible when <a href="qwidget.html#show">show</a>() is called on it. It will not be
automatically shown when the parent is shown.</p>
<p>To check visibility, use !<a href="qwidget.html#visible-prop">isVisible</a>() instead (notice the
exclamation mark).</p>
<p>isHidden() implies !<a href="qwidget.html#visible-prop">isVisible</a>(), but a widget can be
not visible and not hidden at the same time. This is the case for
widgets that are children of widgets that are not visible.</p>
<p>Widgets are hidden if:</p>
<ul>
<li>they were created as independent windows,</li>
<li>they were created as children of visible widgets,</li>
<li><a href="qwidget.html#hide">hide</a>() or setVisible(false) was
called.</li>
</ul>


<h3 class="fn"><a name="isLeftToRight" />bool QWidget.isLeftToRight (<i>self</i>)</h3><h3 class="fn"><a name="isMaximized" />bool QWidget.isMaximized (<i>self</i>)</h3><h3 class="fn"><a name="isMinimized" />bool QWidget.isMinimized (<i>self</i>)</h3><h3 class="fn"><a name="isModal" />bool QWidget.isModal (<i>self</i>)</h3><h3 class="fn"><a name="isRightToLeft" />bool QWidget.isRightToLeft (<i>self</i>)</h3><h3 class="fn"><a name="isTopLevel" />bool QWidget.isTopLevel (<i>self</i>)</h3><h3 class="fn"><a name="isVisible" />bool QWidget.isVisible (<i>self</i>)</h3><h3 class="fn"><a name="isVisibleTo" />bool QWidget.isVisibleTo (<i>self</i>, <a href="qwidget.html">QWidget</a>)</h3><p>Returns true if this widget would become visible if
<i>ancestor</i> is shown; otherwise returns false.</p>
<p>The true case occurs if neither the widget itself nor any parent
up to but excluding <i>ancestor</i> has been explicitly hidden.</p>
<p>This function will still return true if the widget is obscured
by other windows on the screen, but could be physically visible if
it or they were to be moved.</p>
<p>isVisibleTo(0) is identical to <a href="qwidget.html#visible-prop">isVisible</a>().</p>
<p><b>See also</b> <a href="qwidget.html#show">show</a>(), <a href="qwidget.html#hide">hide</a>(), and <a href="qwidget.html#visible-prop">isVisible</a>().</p>


<h3 class="fn"><a name="isWindow" />bool QWidget.isWindow (<i>self</i>)</h3><p>Returns true if the widget is an independent window, otherwise
returns false.</p>
<p>A window is a widget that isn't visually the child of any other
widget and that usually has a frame and a <a href="qwidget.html#windowTitle-prop">window title</a>.</p>
<p>A window can have a <a href="qwidget.html#parentWidget">parent
widget</a>. It will then be grouped with its parent and deleted
when the parent is deleted, minimized when the parent is minimized
etc. If supported by the window manager, it will also have a common
taskbar entry with its parent.</p>
<p><a href="qdialog.html">QDialog</a> and <a href="qmainwindow.html">QMainWindow</a> widgets are by default windows,
even if a parent widget is specified in the constructor. This
behavior is specified by the <a href="qt.html#WindowType-enum">Qt.Window</a> flag.</p>
<p><b>See also</b> <a href="qwidget.html#window">window</a>(),
<a href="qwidget.html#modal-prop">isModal</a>(), and <a href="qwidget.html#parentWidget">parentWidget</a>().</p>


<h3 class="fn"><a name="isWindowModified" />bool QWidget.isWindowModified (<i>self</i>)</h3><h3 class="fn"><a name="keyboardGrabber" /><a href="qwidget.html">QWidget</a> QWidget.keyboardGrabber ()</h3><p>Returns the widget that is currently grabbing the keyboard
input.</p>
<p>If no widget in this application is currently grabbing the
keyboard, 0 is returned.</p>
<p><b>See also</b> <a href="qwidget.html#grabMouse">grabMouse</a>()
and <a href="qwidget.html#mouseGrabber">mouseGrabber</a>().</p>


<h3 class="fn"><a name="keyPressEvent" />QWidget.keyPressEvent (<i>self</i>, <a href="qkeyevent.html">QKeyEvent</a>)</h3><p>This event handler, for event <i>event</i>, can be reimplemented
in a subclass to receive key press events for the widget.</p>
<p>A widget must call <a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>() to accept
focus initially and have focus in order to receive a key press
event.</p>
<p>If you reimplement this handler, it is very important that you
call the base class implementation if you do not act upon the
key.</p>
<p>The default implementation closes popup widgets if the user
presses Esc. Otherwise the event is ignored, so that the widget's
parent can interpret it.</p>
<p>Note that <a href="qkeyevent.html">QKeyEvent</a> starts with
isAccepted() == true, so you do not need to call <a href="qevent.html#accept">QKeyEvent.accept</a>() - just do not call the
base class implementation if you act upon the key.</p>
<p><b>See also</b> <a href="qwidget.html#keyReleaseEvent">keyReleaseEvent</a>(), <a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>(), <a href="qwidget.html#focusInEvent">focusInEvent</a>(), <a href="qwidget.html#focusOutEvent">focusOutEvent</a>(), <a href="qwidget.html#event">event</a>(), <a href="qkeyevent.html">QKeyEvent</a>, and <a href="widgets-tetrix.html">Tetrix Example</a>.</p>


<h3 class="fn"><a name="keyReleaseEvent" />QWidget.keyReleaseEvent (<i>self</i>, <a href="qkeyevent.html">QKeyEvent</a>)</h3><p>This event handler, for event <i>event</i>, can be reimplemented
in a subclass to receive key release events for the widget.</p>
<p>A widget must <a href="qwidget.html#focusPolicy-prop">accept
focus</a> initially and <a href="qwidget.html#focus-prop">have
focus</a> in order to receive a key release event.</p>
<p>If you reimplement this handler, it is very important that you
call the base class implementation if you do not act upon the
key.</p>
<p>The default implementation ignores the event, so that the
widget's parent can interpret it.</p>
<p>Note that <a href="qkeyevent.html">QKeyEvent</a> starts with
isAccepted() == true, so you do not need to call <a href="qevent.html#accept">QKeyEvent.accept</a>() - just do not call the
base class implementation if you act upon the key.</p>
<p><b>See also</b> <a href="qwidget.html#keyPressEvent">keyPressEvent</a>(), <a href="qevent.html#ignore">QKeyEvent.ignore</a>(), <a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>(), <a href="qwidget.html#focusInEvent">focusInEvent</a>(), <a href="qwidget.html#focusOutEvent">focusOutEvent</a>(), <a href="qwidget.html#event">event</a>(), and <a href="qkeyevent.html">QKeyEvent</a>.</p>


<h3 class="fn"><a name="languageChange" />QWidget.languageChange (<i>self</i>)</h3><h3 class="fn"><a name="layout" /><a href="qlayout.html">QLayout</a> QWidget.layout (<i>self</i>)</h3><p>Returns the layout manager that is installed on this widget, or
0 if no layout manager is installed.</p>
<p>The layout manager sets the geometry of the widget's children
that have been added to the layout.</p>
<p><b>See also</b> <a href="qwidget.html#setLayout">setLayout</a>(), <a href="qwidget.html#sizePolicy-prop">sizePolicy</a>(), and <a href="layout.html">Layout Management</a>.</p>


<h3 class="fn"><a name="layoutDirection" /><a href="qt.html#LayoutDirection-enum">Qt.LayoutDirection</a> QWidget.layoutDirection (<i>self</i>)</h3><h3 class="fn"><a name="leaveEvent" />QWidget.leaveEvent (<i>self</i>, <a href="qevent.html">QEvent</a>)</h3><p>This event handler can be reimplemented in a subclass to receive
widget leave events which are passed in the <i>event</i>
parameter.</p>
<p>A leave event is sent to the widget when the mouse cursor leaves
the widget.</p>
<p><b>See also</b> <a href="qwidget.html#enterEvent">enterEvent</a>(), <a href="qwidget.html#mouseMoveEvent">mouseMoveEvent</a>(), and <a href="qwidget.html#event">event</a>().</p>


<h3 class="fn"><a name="locale" /><a href="qlocale.html">QLocale</a> QWidget.locale (<i>self</i>)</h3><h3 class="fn"><a name="lower" />QWidget.lower (<i>self</i>)</h3><p>This method is also a Qt slot with the C++ signature <tt>void lower()</tt>.</p><p>Lowers the widget to the bottom of the parent widget's
stack.</p>
<p>After this call the widget will be visually behind (and
therefore obscured by) any overlapping sibling widgets.</p>
<p><b>See also</b> <a href="qwidget.html#raise">raise_</a>() and
<a href="qwidget.html#stackUnder">stackUnder</a>().</p>


<h3 class="fn"><a name="mapFrom" /><a href="qpoint.html">QPoint</a> QWidget.mapFrom (<i>self</i>, <a href="qwidget.html">QWidget</a>, <a href="qpoint.html">QPoint</a>)</h3><p>Translates the widget coordinate <i>pos</i> from the coordinate
system of <i>parent</i> to this widget's coordinate system. The
<i>parent</i> must not be 0 and must be a parent of the calling
widget.</p>
<p><b>See also</b> <a href="qwidget.html#mapTo">mapTo</a>(),
<a href="qwidget.html#mapFromParent">mapFromParent</a>(), <a href="qwidget.html#mapFromGlobal">mapFromGlobal</a>(), and <a href="qwidget.html#underMouse">underMouse</a>().</p>


<h3 class="fn"><a name="mapFromGlobal" /><a href="qpoint.html">QPoint</a> QWidget.mapFromGlobal (<i>self</i>, <a href="qpoint.html">QPoint</a>)</h3><p>Translates the global screen coordinate <i>pos</i> to widget
coordinates.</p>
<p><b>See also</b> <a href="qwidget.html#mapToGlobal">mapToGlobal</a>(), <a href="qwidget.html#mapFrom">mapFrom</a>(), and <a href="qwidget.html#mapFromParent">mapFromParent</a>().</p>


<h3 class="fn"><a name="mapFromParent" /><a href="qpoint.html">QPoint</a> QWidget.mapFromParent (<i>self</i>, <a href="qpoint.html">QPoint</a>)</h3><p>Translates the parent widget coordinate <i>pos</i> to widget
coordinates.</p>
<p>Same as <a href="qwidget.html#mapFromGlobal">mapFromGlobal</a>()
if the widget has no parent.</p>
<p><b>See also</b> <a href="qwidget.html#mapToParent">mapToParent</a>(), <a href="qwidget.html#mapFrom">mapFrom</a>(), <a href="qwidget.html#mapFromGlobal">mapFromGlobal</a>(), and <a href="qwidget.html#underMouse">underMouse</a>().</p>


<h3 class="fn"><a name="mapTo" /><a href="qpoint.html">QPoint</a> QWidget.mapTo (<i>self</i>, <a href="qwidget.html">QWidget</a>, <a href="qpoint.html">QPoint</a>)</h3><p>Translates the widget coordinate <i>pos</i> to the coordinate
system of <i>parent</i>. The <i>parent</i> must not be 0 and must
be a parent of the calling widget.</p>
<p><b>See also</b> <a href="qwidget.html#mapFrom">mapFrom</a>(),
<a href="qwidget.html#mapToParent">mapToParent</a>(), <a href="qwidget.html#mapToGlobal">mapToGlobal</a>(), and <a href="qwidget.html#underMouse">underMouse</a>().</p>


<h3 class="fn"><a name="mapToGlobal" /><a href="qpoint.html">QPoint</a> QWidget.mapToGlobal (<i>self</i>, <a href="qpoint.html">QPoint</a>)</h3><p>Translates the widget coordinate <i>pos</i> to global screen
coordinates. For example, <tt>mapToGlobal(QPoint(0,0))</tt> would
give the global coordinates of the top-left pixel of the
widget.</p>
<p><b>See also</b> <a href="qwidget.html#mapFromGlobal">mapFromGlobal</a>(), <a href="qwidget.html#mapTo">mapTo</a>(), and <a href="qwidget.html#mapToParent">mapToParent</a>().</p>


<h3 class="fn"><a name="mapToParent" /><a href="qpoint.html">QPoint</a> QWidget.mapToParent (<i>self</i>, <a href="qpoint.html">QPoint</a>)</h3><p>Translates the widget coordinate <i>pos</i> to a coordinate in
the parent widget.</p>
<p>Same as <a href="qwidget.html#mapToGlobal">mapToGlobal</a>() if
the widget has no parent.</p>
<p><b>See also</b> <a href="qwidget.html#mapFromParent">mapFromParent</a>(), <a href="qwidget.html#mapTo">mapTo</a>(), <a href="qwidget.html#mapToGlobal">mapToGlobal</a>(), and <a href="qwidget.html#underMouse">underMouse</a>().</p>


<h3 class="fn"><a name="mask" /><a href="qregion.html">QRegion</a> QWidget.mask (<i>self</i>)</h3><p>Returns the mask currently set on a widget. If no mask is set
the return value will be an empty region.</p>
<p><b>See also</b> <a href="qwidget.html#setMask">setMask</a>(),
<a href="qwidget.html#clearMask">clearMask</a>(), <a href="qregion.html#isEmpty">QRegion.isEmpty</a>(), and <a href="widgets-shapedclock.html">Shaped Clock Example</a>.</p>


<h3 class="fn"><a name="maximumHeight" />int QWidget.maximumHeight (<i>self</i>)</h3><h3 class="fn"><a name="maximumSize" /><a href="qsize.html">QSize</a> QWidget.maximumSize (<i>self</i>)</h3><h3 class="fn"><a name="maximumWidth" />int QWidget.maximumWidth (<i>self</i>)</h3><h3 class="fn"><a name="metric" />int QWidget.metric (<i>self</i>, <a href="qpaintdevice.html#PaintDeviceMetric-enum">QPaintDevice.PaintDeviceMetric</a>)</h3><p>Reimplemented from <a href="qpaintdevice.html#metric">QPaintDevice.metric</a>().</p>
<p>Internal implementation of the virtual <a href="qpaintdevice.html#metric">QPaintDevice.metric</a>() function.</p>
<p><i>m</i> is the metric to get.</p>


<h3 class="fn"><a name="minimumHeight" />int QWidget.minimumHeight (<i>self</i>)</h3><h3 class="fn"><a name="minimumSize" /><a href="qsize.html">QSize</a> QWidget.minimumSize (<i>self</i>)</h3><h3 class="fn"><a name="minimumSizeHint" /><a href="qsize.html">QSize</a> QWidget.minimumSizeHint (<i>self</i>)</h3><h3 class="fn"><a name="minimumWidth" />int QWidget.minimumWidth (<i>self</i>)</h3><h3 class="fn"><a name="mouseDoubleClickEvent" />QWidget.mouseDoubleClickEvent (<i>self</i>, <a href="qmouseevent.html">QMouseEvent</a>)</h3><p>This event handler, for event <i>event</i>, can be reimplemented
in a subclass to receive mouse double click events for the
widget.</p>
<p>The default implementation generates a normal mouse press
event.</p>
<p><b>Note:</b> The widget will also receive mouse press and mouse
release events in addition to the double click event. It is up to
the developer to ensure that the application interprets these
events correctly.</p>
<p><b>See also</b> <a href="qwidget.html#mousePressEvent">mousePressEvent</a>(), <a href="qwidget.html#mouseReleaseEvent">mouseReleaseEvent</a>(), <a href="qwidget.html#mouseMoveEvent">mouseMoveEvent</a>(), <a href="qwidget.html#event">event</a>(), and <a href="qmouseevent.html">QMouseEvent</a>.</p>


<h3 class="fn"><a name="mouseGrabber" /><a href="qwidget.html">QWidget</a> QWidget.mouseGrabber ()</h3><p>Returns the widget that is currently grabbing the mouse
input.</p>
<p>If no widget in this application is currently grabbing the
mouse, 0 is returned.</p>
<p><b>See also</b> <a href="qwidget.html#grabMouse">grabMouse</a>()
and <a href="qwidget.html#keyboardGrabber">keyboardGrabber</a>().</p>


<h3 class="fn"><a name="mouseMoveEvent" />QWidget.mouseMoveEvent (<i>self</i>, <a href="qmouseevent.html">QMouseEvent</a>)</h3><p>This event handler, for event <i>event</i>, can be reimplemented
in a subclass to receive mouse move events for the widget.</p>
<p>If mouse tracking is switched off, mouse move events only occur
if a mouse button is pressed while the mouse is being moved. If
mouse tracking is switched on, mouse move events occur even if no
mouse button is pressed.</p>
<p><a href="qmouseevent.html#pos">QMouseEvent.pos</a>() reports
the position of the mouse cursor, relative to this widget. For
press and release events, the position is usually the same as the
position of the last mouse move event, but it might be different if
the user's hand shakes. This is a feature of the underlying window
system, not Qt.</p>
<p>If you want to show a tooltip immediately, while the mouse is
moving (e.g., to get the mouse coordinates with <a href="qmouseevent.html#pos">QMouseEvent.pos</a>() and show them as a
tooltip), you must first enable mouse tracking as described above.
Then, to ensure that the tooltip is updated immediately, you must
call <a href="qtooltip.html#showText">QToolTip.showText</a>()
instead of <a href="qwidget.html#toolTip-prop">setToolTip</a>() in
your implementation of mouseMoveEvent().</p>
<p><b>See also</b> <a href="qwidget.html#mouseTracking-prop">setMouseTracking</a>(), <a href="qwidget.html#mousePressEvent">mousePressEvent</a>(), <a href="qwidget.html#mouseReleaseEvent">mouseReleaseEvent</a>(), <a href="qwidget.html#mouseDoubleClickEvent">mouseDoubleClickEvent</a>(),
<a href="qwidget.html#event">event</a>(), <a href="qmouseevent.html">QMouseEvent</a>, and <a href="widgets-scribble.html">Scribble Example</a>.</p>


<h3 class="fn"><a name="mousePressEvent" />QWidget.mousePressEvent (<i>self</i>, <a href="qmouseevent.html">QMouseEvent</a>)</h3><p>This event handler, for event <i>event</i>, can be reimplemented
in a subclass to receive mouse press events for the widget.</p>
<p>If you create new widgets in the mousePressEvent() the <a href="qwidget.html#mouseReleaseEvent">mouseReleaseEvent</a>() may not
end up where you expect, depending on the underlying window system
(or X11 window manager), the widgets' location and maybe more.</p>
<p>The default implementation implements the closing of popup
widgets when you click outside the window. For other widget types
it does nothing.</p>
<p><b>See also</b> <a href="qwidget.html#mouseReleaseEvent">mouseReleaseEvent</a>(), <a href="qwidget.html#mouseDoubleClickEvent">mouseDoubleClickEvent</a>(),
<a href="qwidget.html#mouseMoveEvent">mouseMoveEvent</a>(),
<a href="qwidget.html#event">event</a>(), <a href="qmouseevent.html">QMouseEvent</a>, and <a href="widgets-scribble.html">Scribble Example</a>.</p>


<h3 class="fn"><a name="mouseReleaseEvent" />QWidget.mouseReleaseEvent (<i>self</i>, <a href="qmouseevent.html">QMouseEvent</a>)</h3><p>This event handler, for event <i>event</i>, can be reimplemented
in a subclass to receive mouse release events for the widget.</p>
<p><b>See also</b> <a href="qwidget.html#mousePressEvent">mousePressEvent</a>(), <a href="qwidget.html#mouseDoubleClickEvent">mouseDoubleClickEvent</a>(),
<a href="qwidget.html#mouseMoveEvent">mouseMoveEvent</a>(),
<a href="qwidget.html#event">event</a>(), <a href="qmouseevent.html">QMouseEvent</a>, and <a href="widgets-scribble.html">Scribble Example</a>.</p>


<h3 class="fn"><a name="move" />QWidget.move (<i>self</i>, <a href="qpoint.html">QPoint</a>)</h3><h3 class="fn"><a name="move-2" />QWidget.move (<i>self</i>, int&#160;<i>ax</i>, int&#160;<i>ay</i>)</h3><h3 class="fn"><a name="moveEvent" />QWidget.moveEvent (<i>self</i>, <a href="qmoveevent.html">QMoveEvent</a>)</h3><p>This event handler can be reimplemented in a subclass to receive
widget move events which are passed in the <i>event</i> parameter.
When the widget receives this event, it is already at the new
position.</p>
<p>The old position is accessible through <a href="qmoveevent.html#oldPos">QMoveEvent.oldPos</a>().</p>
<p><b>See also</b> <a href="qwidget.html#resizeEvent">resizeEvent</a>(), <a href="qwidget.html#event">event</a>(), <a href="qwidget.html#pos-prop">move</a>(), and <a href="qmoveevent.html">QMoveEvent</a>.</p>


<h3 class="fn"><a name="nativeParentWidget" /><a href="qwidget.html">QWidget</a> QWidget.nativeParentWidget (<i>self</i>)</h3><p>Returns the native parent for this widget, i.e. the next
ancestor widget that has a system identifier, or 0 if it does not
have any native parent.</p>
<p>This function was introduced in Qt 4.4.</p>
<p><b>See also</b> <a href="qwidget.html#effectiveWinId">effectiveWinId</a>().</p>


<h3 class="fn"><a name="nextInFocusChain" /><a href="qwidget.html">QWidget</a> QWidget.nextInFocusChain (<i>self</i>)</h3><p>Returns the next widget in this widget's focus chain.</p>
<p><b>See also</b> <a href="qwidget.html#previousInFocusChain">previousInFocusChain</a>().</p>


<h3 class="fn"><a name="normalGeometry" /><a href="qrect.html">QRect</a> QWidget.normalGeometry (<i>self</i>)</h3><h3 class="fn"><a name="overrideWindowFlags" />QWidget.overrideWindowFlags (<i>self</i>, <a href="qt-windowflags.html">Qt.WindowFlags</a>&#160;<i>type</i>)</h3><p>Sets the window flags for the widget to <i>flags</i>,
<i>without</i> telling the window system.</p>
<p><b>Warning:</b> Do not call this function unless you really know
what you're doing.</p>
<p><b>See also</b> <a href="qwidget.html#windowFlags-prop">setWindowFlags</a>().</p>


<h3 class="fn"><a name="overrideWindowState" />QWidget.overrideWindowState (<i>self</i>, <a href="qt-windowstates.html">Qt.WindowStates</a>&#160;<i>state</i>)</h3><h3 class="fn"><a name="paintEngine" /><a href="qpaintengine.html">QPaintEngine</a> QWidget.paintEngine (<i>self</i>)</h3><p>Reimplemented from <a href="qpaintdevice.html#paintEngine">QPaintDevice.paintEngine</a>().</p>
<p>Returns the widget's paint engine.</p>
<p>Note that this function should not be called explicitly by the
user, since it's meant for reimplementation purposes only. The
function is called by Qt internally, and the default implementation
may not always return a valid pointer.</p>


<h3 class="fn"><a name="paintEvent" />QWidget.paintEvent (<i>self</i>, <a href="qpaintevent.html">QPaintEvent</a>)</h3><p>This event handler can be reimplemented in a subclass to receive
paint events passed in <i>event</i>.</p>
<p>A paint event is a request to repaint all or part of a widget.
It can happen for one of the following reasons:</p>
<ul>
<li><a href="qwidget.html#repaint">repaint</a>() or <a href="qwidget.html#update">update</a>() was invoked,</li>
<li>the widget was obscured and has now been uncovered, or</li>
<li>many other reasons.</li>
</ul>
<p>Many widgets can simply repaint their entire surface when asked
to, but some slow widgets need to optimize by painting only the
requested region: <a href="qpaintevent.html#region">QPaintEvent.region</a>(). This speed
optimization does not change the result, as painting is clipped to
that region during event processing. <a href="qlistview.html">QListView</a> and <a href="qtableview.html">QTableView</a> do this, for example.</p>
<p>Qt also tries to speed up painting by merging multiple paint
events into one. When <a href="qwidget.html#update">update</a>() is
called several times or the window system sends several paint
events, Qt merges these events into one event with a larger region
(see <a href="qregion.html#united">QRegion.united</a>()). The
<a href="qwidget.html#repaint">repaint</a>() function does not
permit this optimization, so we suggest using <a href="qwidget.html#update">update</a>() whenever possible.</p>
<p>When the paint event occurs, the update region has normally been
erased, so you are painting on the widget's background.</p>
<p>The background can be set using <a href="qwidget.html#setBackgroundRole">setBackgroundRole</a>() and
<a href="qwidget.html#palette-prop">setPalette</a>().</p>
<p>Since Qt 4.0, <a href="qwidget.html">QWidget</a> automatically
double-buffers its painting, so there is no need to write
double-buffering code in paintEvent() to avoid flicker.</p>
<p><b>Note for the X11 platform</b>: It is possible to toggle
global double buffering by calling
<tt>qt_x11_set_global_double_buffer()</tt>. For example,</p>
<pre class="cpp">
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="keyword">extern</span> <span class="type">void</span> qt_x11_set_global_double_buffer(<span class="type">bool</span>);
 qt_x11_set_global_double_buffer(<span class="keyword">false</span>);
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
</pre>
<p><b>Note:</b> Generally, you should refrain from calling <a href="qwidget.html#update">update</a>() or <a href="qwidget.html#repaint">repaint</a>() <b>inside</b> a paintEvent().
For example, calling <a href="qwidget.html#update">update</a>() or
<a href="qwidget.html#repaint">repaint</a>() on children inside a
paintevent() results in undefined behavior; the child may or may
not get a paint event.</p>
<p><b>Warning:</b> If you are using a custom paint engine without
Qt's backingstore, <a href="qt.html#WidgetAttribute-enum">Qt.WA_PaintOnScreen</a> must be
set. Otherwise, <a href="qwidget.html#paintEngine">QWidget.paintEngine</a>() will never be
called; the backingstore will be used instead.</p>
<p><b>See also</b> <a href="qwidget.html#event">event</a>(),
<a href="qwidget.html#repaint">repaint</a>(), <a href="qwidget.html#update">update</a>(), <a href="qpainter.html">QPainter</a>, <a href="qpixmap.html">QPixmap</a>,
<a href="qpaintevent.html">QPaintEvent</a>, and <a href="widgets-analogclock.html">Analog Clock Example</a>.</p>


<h3 class="fn"><a name="palette" /><a href="qpalette.html">QPalette</a> QWidget.palette (<i>self</i>)</h3><h3 class="fn"><a name="paletteChange" />QWidget.paletteChange (<i>self</i>, <a href="qpalette.html">QPalette</a>)</h3><h3 class="fn"><a name="parentWidget" /><a href="qwidget.html">QWidget</a> QWidget.parentWidget (<i>self</i>)</h3><p>Returns the parent of this widget, or 0 if it does not have any
parent widget.</p>


<h3 class="fn"><a name="pos" /><a href="qpoint.html">QPoint</a> QWidget.pos (<i>self</i>)</h3><h3 class="fn"><a name="previousInFocusChain" /><a href="qwidget.html">QWidget</a> QWidget.previousInFocusChain (<i>self</i>)</h3><p>The previousInFocusChain function returns the previous widget in
this widget's focus chain.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also</b> <a href="qwidget.html#nextInFocusChain">nextInFocusChain</a>().</p>


<h3 class="fn"><a name="raise" />QWidget.raise_ (<i>self</i>)</h3><p>This method is also a Qt slot with the C++ signature <tt>void raise()</tt>.</p><p>Raises this widget to the top of the parent widget's stack.</p>
<p>After this call the widget will be visually in front of any
overlapping sibling widgets.</p>
<p><b>Note:</b> When using <a href="qwidget.html#activateWindow">activateWindow</a>(), you can call
this function to ensure that the window is stacked on top.</p>
<p><b>See also</b> <a href="qwidget.html#lower">lower</a>() and
<a href="qwidget.html#stackUnder">stackUnder</a>().</p>


<h3 class="fn"><a name="rect" /><a href="qrect.html">QRect</a> QWidget.rect (<i>self</i>)</h3><h3 class="fn"><a name="releaseKeyboard" />QWidget.releaseKeyboard (<i>self</i>)</h3><p>Releases the keyboard grab.</p>
<p><b>See also</b> <a href="qwidget.html#grabKeyboard">grabKeyboard</a>(), <a href="qwidget.html#grabMouse">grabMouse</a>(), and <a href="qwidget.html#releaseMouse">releaseMouse</a>().</p>


<h3 class="fn"><a name="releaseMouse" />QWidget.releaseMouse (<i>self</i>)</h3><p>Releases the mouse grab.</p>
<p><b>See also</b> <a href="qwidget.html#grabMouse">grabMouse</a>(), <a href="qwidget.html#grabKeyboard">grabKeyboard</a>(), and <a href="qwidget.html#releaseKeyboard">releaseKeyboard</a>().</p>


<h3 class="fn"><a name="releaseShortcut" />QWidget.releaseShortcut (<i>self</i>, int&#160;<i>id</i>)</h3><p>Removes the shortcut with the given <i>id</i> from Qt's shortcut
system. The widget will no longer receive <a href="qevent.html#Type-enum">QEvent.Shortcut</a> events for the
shortcut's key sequence (unless it has other shortcuts with the
same key sequence).</p>
<p><b>Warning:</b> You should not normally need to use this
function since Qt's shortcut system removes shortcuts automatically
when their parent widget is destroyed. It is best to use <a href="qaction.html">QAction</a> or <a href="qshortcut.html">QShortcut</a> to handle shortcuts, since they are
easier to use than this low-level function. Note also that this is
an expensive operation.</p>
<p><b>See also</b> <a href="qwidget.html#grabShortcut">grabShortcut</a>() and <a href="qwidget.html#setShortcutEnabled">setShortcutEnabled</a>().</p>


<h3 class="fn"><a name="removeAction" />QWidget.removeAction (<i>self</i>, <a href="qaction.html">QAction</a>&#160;<i>action</i>)</h3><p>Removes the action <i>action</i> from this widget's list of
actions.</p>
<p><b>See also</b> <a href="qwidget.html#insertAction">insertAction</a>(), <a href="qwidget.html#actions">actions</a>(), and <a href="qwidget.html#insertAction">insertAction</a>().</p>


<h3 class="fn"><a name="render" />QWidget.render (<i>self</i>, <a href="qpaintdevice.html">QPaintDevice</a>&#160;<i>target</i>, <a href="qpoint.html">QPoint</a>&#160;<i>targetOffset</i>&#160;=&#160;QPoint(), <a href="qregion.html">QRegion</a>&#160;<i>sourceRegion</i>&#160;=&#160;QRegion(), <a href="qwidget-renderflags.html">RenderFlags</a>&#160;<i>flags</i>&#160;=&#160;QWidget.DrawWindowBackground|QWidget.DrawChildren)</h3><p>Renders the <i>sourceRegion</i> of this widget into the
<i>target</i> using <i>renderFlags</i> to determine how to render.
Rendering starts at <i>targetOffset</i> in the <i>target</i>. For
example:</p>
<pre class="cpp">
 <span class="type"><a href="qpixmap.html">QPixmap</a></span> pixmap(widget<span class="operator">-</span><span class="operator">&gt;</span>size());
 widget<span class="operator">-</span><span class="operator">&gt;</span>render(<span class="operator">&amp;</span>pixmap);
</pre>
<p>If <i>sourceRegion</i> is a null region, this function will use
<a href="qwidget.html#rect-prop">QWidget.rect</a>() as the region,
i.e. the entire widget.</p>
<p>Ensure that you call <a href="qpainter.html#end">QPainter.end</a>() for the <i>target</i>
device's active painter (if any) before rendering. For example:</p>
<pre class="cpp">
 <span class="type"><a href="qpainter.html">QPainter</a></span> painter(<span class="keyword">this</span>);
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 painter<span class="operator">.</span>end();
 myWidget<span class="operator">-</span><span class="operator">&gt;</span>render(<span class="keyword">this</span>);
</pre>
<p><b>Note:</b> To obtain the contents of an OpenGL widget, use
<a href="qglwidget.html#grabFrameBuffer">QGLWidget.grabFrameBuffer</a>()
or <a href="qglwidget.html#renderPixmap">QGLWidget.renderPixmap</a>()
instead.</p>
<p>This function was introduced in Qt 4.3.</p>


<h3 class="fn"><a name="render-2" />QWidget.render (<i>self</i>, <a href="qpainter.html">QPainter</a>&#160;<i>painter</i>, <a href="qpoint.html">QPoint</a>&#160;<i>targetOffset</i>&#160;=&#160;QPoint(), <a href="qregion.html">QRegion</a>&#160;<i>sourceRegion</i>&#160;=&#160;QRegion(), <a href="qwidget-renderflags.html">RenderFlags</a>&#160;<i>flags</i>&#160;=&#160;QWidget.DrawWindowBackground|QWidget.DrawChildren)</h3><p>This is an overloaded function.</p>
<p>Renders the widget into the <i>painter</i>'s <a href="qpainter.html#device">QPainter.device</a>().</p>
<p>Transformations and settings applied to the <i>painter</i> will
be used when rendering.</p>
<p><b>Note:</b> The <i>painter</i> must be active. On Mac OS X the
widget will be rendered into a <a href="qpixmap.html">QPixmap</a>
and then drawn by the <i>painter</i>.</p>
<p><b>See also</b> <a href="qpainter.html#device">QPainter.device</a>().</p>


<h3 class="fn"><a name="repaint" />QWidget.repaint (<i>self</i>)</h3><p>This method is also a Qt slot with the C++ signature <tt>void repaint()</tt>.</p><p>Repaints the widget directly by calling <a href="qwidget.html#paintEvent">paintEvent</a>() immediately, unless
updates are disabled or the widget is hidden.</p>
<p>We suggest only using repaint() if you need an immediate
repaint, for example during animation. In almost all circumstances
<a href="qwidget.html#update">update</a>() is better, as it permits
Qt to optimize for speed and minimize flicker.</p>
<p><b>Warning:</b> If you call repaint() in a function which may
itself be called from <a href="qwidget.html#paintEvent">paintEvent</a>(), you may get infinite
recursion. The <a href="qwidget.html#update">update</a>() function
never causes recursion.</p>
<p><b>See also</b> <a href="qwidget.html#update">update</a>(),
<a href="qwidget.html#paintEvent">paintEvent</a>(), and <a href="qwidget.html#updatesEnabled-prop">setUpdatesEnabled</a>().</p>


<h3 class="fn"><a name="repaint-2" />QWidget.repaint (<i>self</i>, int&#160;<i>x</i>, int&#160;<i>y</i>, int&#160;<i>w</i>, int&#160;<i>h</i>)</h3><h3 class="fn"><a name="repaint-3" />QWidget.repaint (<i>self</i>, <a href="qrect.html">QRect</a>)</h3><h3 class="fn"><a name="repaint-4" />QWidget.repaint (<i>self</i>, <a href="qregion.html">QRegion</a>)</h3><h3 class="fn"><a name="resetInputContext" />QWidget.resetInputContext (<i>self</i>)</h3><h3 class="fn"><a name="resize" />QWidget.resize (<i>self</i>, <a href="qsize.html">QSize</a>)</h3><h3 class="fn"><a name="resize-2" />QWidget.resize (<i>self</i>, int&#160;<i>w</i>, int&#160;<i>h</i>)</h3><h3 class="fn"><a name="resizeEvent" />QWidget.resizeEvent (<i>self</i>, <a href="qresizeevent.html">QResizeEvent</a>)</h3><p>This event handler can be reimplemented in a subclass to receive
widget resize events which are passed in the <i>event</i>
parameter. When resizeEvent() is called, the widget already has its
new geometry. The old size is accessible through <a href="qresizeevent.html#oldSize">QResizeEvent.oldSize</a>().</p>
<p>The widget will be erased and receive a paint event immediately
after processing the resize event. No drawing need be (or should
be) done inside this handler.</p>
<p><b>See also</b> <a href="qwidget.html#moveEvent">moveEvent</a>(), <a href="qwidget.html#event">event</a>(), <a href="qwidget.html#size-prop">resize</a>(), <a href="qresizeevent.html">QResizeEvent</a>, <a href="qwidget.html#paintEvent">paintEvent</a>(), and <a href="widgets-scribble.html">Scribble Example</a>.</p>


<h3 class="fn"><a name="restoreGeometry" />bool QWidget.restoreGeometry (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>geometry</i>)</h3><p>Restores the geometry and state top-level widgets stored in the
byte array <i>geometry</i>. Returns true on success; otherwise
returns false.</p>
<p>If the restored geometry is off-screen, it will be modified to
be inside the available screen geometry.</p>
<p>To restore geometry saved using <a href="qsettings.html">QSettings</a>, you can use code like this:</p>
<pre class="cpp">
 <span class="type"><a href="qsettings.html">QSettings</a></span> settings(<span class="string">"MyCompany"</span><span class="operator">,</span> <span class="string">"MyApp"</span>);
 myWidget<span class="operator">-</span><span class="operator">&gt;</span>restoreGeometry(settings<span class="operator">.</span>value(<span class="string">"myWidget/geometry"</span>)<span class="operator">.</span>toByteArray());
</pre>
<p>See the <a href="application-windows.html#window-geometry">Window Geometry</a>
documentation for an overview of geometry issues with windows.</p>
<p>Use <a href="qmainwindow.html#restoreState">QMainWindow.restoreState</a>() to
restore the geometry and the state of toolbars and dock
widgets.</p>
<p>This function was introduced in Qt 4.2.</p>
<p><b>See also</b> <a href="qwidget.html#saveGeometry">saveGeometry</a>(), <a href="qsettings.html">QSettings</a>, <a href="qmainwindow.html#saveState">QMainWindow.saveState</a>(), and
<a href="qmainwindow.html#restoreState">QMainWindow.restoreState</a>().</p>


<h3 class="fn"><a name="saveGeometry" /><a href="qbytearray.html">QByteArray</a> QWidget.saveGeometry (<i>self</i>)</h3><p>Saves the current geometry and state for top-level widgets.</p>
<p>To save the geometry when the window closes, you can implement a
close event like this:</p>
<pre class="cpp">
 <span class="type">void</span> MyWidget<span class="operator">.</span><a href="qwidget.html#closeEvent">closeEvent</a>(<span class="type"><a href="qcloseevent.html">QCloseEvent</a></span> <span class="operator">*</span>event)
 {
     <span class="type"><a href="qsettings.html">QSettings</a></span> settings(<span class="string">"MyCompany"</span><span class="operator">,</span> <span class="string">"MyApp"</span>);
     settings<span class="operator">.</span>setValue(<span class="string">"geometry"</span><span class="operator">,</span> saveGeometry());
     <span class="type"><a href="qwidget.html">QWidget</a></span><span class="operator">.</span>closeEvent(event);
 }
</pre>
<p>See the <a href="application-windows.html#window-geometry">Window Geometry</a>
documentation for an overview of geometry issues with windows.</p>
<p>Use <a href="qmainwindow.html#saveState">QMainWindow.saveState</a>() to save
the geometry and the state of toolbars and dock widgets.</p>
<p>This function was introduced in Qt 4.2.</p>
<p><b>See also</b> <a href="qwidget.html#restoreGeometry">restoreGeometry</a>(), <a href="qmainwindow.html#saveState">QMainWindow.saveState</a>(), and
<a href="qmainwindow.html#restoreState">QMainWindow.restoreState</a>().</p>


<h3 class="fn"><a name="scroll" />QWidget.scroll (<i>self</i>, int&#160;<i>dx</i>, int&#160;<i>dy</i>)</h3><p>Scrolls the widget including its children <i>dx</i> pixels to
the right and <i>dy</i> downward. Both <i>dx</i> and <i>dy</i> may
be negative.</p>
<p>After scrolling, the widgets will receive paint events for the
areas that need to be repainted. For widgets that Qt knows to be
opaque, this is only the newly exposed parts. For example, if an
opaque widget is scrolled 8 pixels to the left, only an 8-pixel
wide stripe at the right edge needs updating.</p>
<p>Since widgets propagate the contents of their parents by
default, you need to set the <a href="qwidget.html#autoFillBackground-prop">autoFillBackground</a>
property, or use <a href="qwidget.html#setAttribute">setAttribute</a>() to set the <a href="qt.html#WidgetAttribute-enum">Qt.WA_OpaquePaintEvent</a>
attribute, to make a widget opaque.</p>
<p>For widgets that use contents propagation, a scroll will cause
an update of the entire scroll area.</p>
<p><b>See also</b> <a href="qwidget.html#transparency-and-double-buffering">Transparency and
Double Buffering</a>.</p>


<h3 class="fn"><a name="scroll-2" />QWidget.scroll (<i>self</i>, int&#160;<i>dx</i>, int&#160;<i>dy</i>, <a href="qrect.html">QRect</a>)</h3><p>This is an overloaded function.</p>
<p>This version only scrolls <i>r</i> and does not move the
children of the widget.</p>
<p>If <i>r</i> is empty or invalid, the result is undefined.</p>
<p><b>See also</b> <a href="qscrollarea.html">QScrollArea</a>.</p>


<h3 class="fn"><a name="setAcceptDrops" />QWidget.setAcceptDrops (<i>self</i>, bool&#160;<i>on</i>)</h3><h3 class="fn"><a name="setAccessibleDescription" />QWidget.setAccessibleDescription (<i>self</i>, QString&#160;<i>description</i>)</h3><h3 class="fn"><a name="setAccessibleName" />QWidget.setAccessibleName (<i>self</i>, QString&#160;<i>name</i>)</h3><h3 class="fn"><a name="setAttribute" />QWidget.setAttribute (<i>self</i>, <a href="qt.html#WidgetAttribute-enum">Qt.WidgetAttribute</a>&#160;<i>attribute</i>, bool&#160;<i>on</i>&#160;=&#160;True)</h3><p>Sets the attribute <i>attribute</i> on this widget if <i>on</i>
is true; otherwise clears the attribute.</p>
<p><b>See also</b> <a href="qwidget.html#testAttribute">testAttribute</a>().</p>


<h3 class="fn"><a name="setAutoFillBackground" />QWidget.setAutoFillBackground (<i>self</i>, bool&#160;<i>enabled</i>)</h3><h3 class="fn"><a name="setBackgroundRole" />QWidget.setBackgroundRole (<i>self</i>, <a href="qpalette.html#ColorRole-enum">QPalette.ColorRole</a>)</h3><p>Sets the background role of the widget to <i>role</i>.</p>
<p>The background role defines the brush from the widget's <a href="qwidget.html#palette-prop">palette</a> that is used to render the
background.</p>
<p>If <i>role</i> is <a href="qpalette.html#ColorRole-enum">QPalette.NoRole</a>, then the
widget inherits its parent's background role.</p>
<p>Note that styles are free to choose any color from the palette.
You can modify the palette or set a style sheet if you don't
achieve the result you want with setBackgroundRole().</p>
<p><b>See also</b> <a href="qwidget.html#backgroundRole">backgroundRole</a>() and <a href="qwidget.html#foregroundRole">foregroundRole</a>().</p>


<h3 class="fn"><a name="setBaseSize" />QWidget.setBaseSize (<i>self</i>, int&#160;<i>basew</i>, int&#160;<i>baseh</i>)</h3><h3 class="fn"><a name="setBaseSize-2" />QWidget.setBaseSize (<i>self</i>, <a href="qsize.html">QSize</a>&#160;<i>s</i>)</h3><h3 class="fn"><a name="setContentsMargins" />QWidget.setContentsMargins (<i>self</i>, int&#160;<i>left</i>, int&#160;<i>top</i>, int&#160;<i>right</i>, int&#160;<i>bottom</i>)</h3><p>Sets the margins around the contents of the widget to have the
sizes <i>left</i>, <i>top</i>, <i>right</i>, and <i>bottom</i>. The
margins are used by the layout system, and may be used by
subclasses to specify the area to draw in (e.g. excluding the
frame).</p>
<p>Changing the margins will trigger a <a href="qwidget.html#resizeEvent">resizeEvent</a>().</p>
<p><b>See also</b> <a href="qwidget.html#contentsMargins">contentsMargins</a>(), <a href="qwidget.html#contentsRect">contentsRect</a>(), and <a href="qwidget.html#getContentsMargins">getContentsMargins</a>().</p>


<h3 class="fn"><a name="setContentsMargins-2" />QWidget.setContentsMargins (<i>self</i>, <a href="qmargins.html">QMargins</a>&#160;<i>margins</i>)</h3><p>This is an overloaded function.</p>
<p>The setContentsMargins function sets the margins around the
widget's contents.</p>
<p>Sets the margins around the contents of the widget to have the
sizes determined by <i>margins</i>. The margins are used by the
layout system, and may be used by subclasses to specify the area to
draw in (e.g. excluding the frame).</p>
<p>Changing the margins will trigger a <a href="qwidget.html#resizeEvent">resizeEvent</a>().</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also</b> <a href="qwidget.html#contentsRect">contentsRect</a>() and <a href="qwidget.html#getContentsMargins">getContentsMargins</a>().</p>


<h3 class="fn"><a name="setContextMenuPolicy" />QWidget.setContextMenuPolicy (<i>self</i>, <a href="qt.html#ContextMenuPolicy-enum">Qt.ContextMenuPolicy</a>&#160;<i>policy</i>)</h3><h3 class="fn"><a name="setCursor" />QWidget.setCursor (<i>self</i>, <a href="qcursor.html">QCursor</a>)</h3><h3 class="fn"><a name="setDisabled" />QWidget.setDisabled (<i>self</i>, bool)</h3><p>This method is also a Qt slot with the C++ signature <tt>void setDisabled(bool)</tt>.</p><p>Disables widget input events if <i>disable</i> is true;
otherwise enables input events.</p>
<p>See the <a href="qwidget.html#enabled-prop">enabled</a>
documentation for more information.</p>
<p><b>See also</b> <a href="qwidget.html#isEnabledTo">isEnabledTo</a>(), <a href="qkeyevent.html">QKeyEvent</a>, <a href="qmouseevent.html">QMouseEvent</a>, and <a href="qwidget.html#changeEvent">changeEvent</a>().</p>


<h3 class="fn"><a name="setEnabled" />QWidget.setEnabled (<i>self</i>, bool)</h3><p>This method is also a Qt slot with the C++ signature <tt>void setEnabled(bool)</tt>.</p><h3 class="fn"><a name="setFixedHeight" />QWidget.setFixedHeight (<i>self</i>, int&#160;<i>h</i>)</h3><p>Sets both the minimum and maximum heights of the widget to
<i>h</i> without changing the widths. Provided for convenience.</p>
<p><b>See also</b> <a href="qwidget.html#sizeHint-prop">sizeHint</a>(), <a href="qwidget.html#minimumSize-prop">minimumSize</a>(), <a href="qwidget.html#maximumSize-prop">maximumSize</a>(), and <a href="qwidget.html#setFixedSize">setFixedSize</a>().</p>


<h3 class="fn"><a name="setFixedSize" />QWidget.setFixedSize (<i>self</i>, <a href="qsize.html">QSize</a>)</h3><p>Sets both the minimum and maximum sizes of the widget to
<i>s</i>, thereby preventing it from ever growing or shrinking.</p>
<p>This will override the default size constraints set by <a href="qlayout.html">QLayout</a>.</p>
<p>To remove constraints, set the size to <a href="qwidget.html#QWIDGETSIZE_MAX">QWIDGETSIZE_MAX</a>.</p>
<p>Alternatively, if you want the widget to have a fixed size based
on its contents, you can call QLayout.setSizeConstraint(<a href="qlayout.html#SizeConstraint-enum">QLayout.SetFixedSize</a>);</p>
<p><b>See also</b> <a href="qwidget.html#maximumSize-prop">maximumSize</a> and <a href="qwidget.html#minimumSize-prop">minimumSize</a>.</p>


<h3 class="fn"><a name="setFixedSize-2" />QWidget.setFixedSize (<i>self</i>, int&#160;<i>w</i>, int&#160;<i>h</i>)</h3><p>This is an overloaded function.</p>
<p>Sets the width of the widget to <i>w</i> and the height to
<i>h</i>.</p>


<h3 class="fn"><a name="setFixedWidth" />QWidget.setFixedWidth (<i>self</i>, int&#160;<i>w</i>)</h3><p>Sets both the minimum and maximum width of the widget to
<i>w</i> without changing the heights. Provided for
convenience.</p>
<p><b>See also</b> <a href="qwidget.html#sizeHint-prop">sizeHint</a>(), <a href="qwidget.html#minimumSize-prop">minimumSize</a>(), <a href="qwidget.html#maximumSize-prop">maximumSize</a>(), and <a href="qwidget.html#setFixedSize">setFixedSize</a>().</p>


<h3 class="fn"><a name="setFocus" />QWidget.setFocus (<i>self</i>)</h3><p>This method is also a Qt slot with the C++ signature <tt>void setFocus()</tt>.</p><p>Gives the keyboard input focus to this widget (or its focus
proxy) if this widget or one of its parents is the <a href="qwidget.html#isActiveWindow-prop">active window</a>. The
<i>reason</i> argument will be passed into any focus event sent
from this function, it is used to give an explanation of what
caused the widget to get focus. If the window is not active, the
widget will be given the focus when the window becomes active.</p>
<p>First, a focus out event is sent to the focus widget (if any) to
tell it that it is about to lose the focus. Then a focus in event
is sent to this widget to tell it that it just received the focus.
(Nothing happens if the focus in and focus out widgets are the
same.)</p>
<p><b>Note:</b> On embedded platforms, setFocus() will not cause an
input panel to be opened by the input method. If you want this to
happen, you have to send a <a href="qevent.html#Type-enum">QEvent.RequestSoftwareInputPanel</a> event
to the widget yourself.</p>
<p>setFocus() gives focus to a widget regardless of its focus
policy, but does not clear any keyboard grab (see <a href="qwidget.html#grabKeyboard">grabKeyboard</a>()).</p>
<p>Be aware that if the widget is hidden, it will not accept focus
until it is shown.</p>
<p><b>Warning:</b> If you call setFocus() in a function which may
itself be called from <a href="qwidget.html#focusOutEvent">focusOutEvent</a>() or <a href="qwidget.html#focusInEvent">focusInEvent</a>(), you may get an
infinite recursion.</p>
<p><b>See also</b> <a href="qwidget.html#focus-prop">hasFocus</a>(), <a href="qwidget.html#clearFocus">clearFocus</a>(), <a href="qwidget.html#focusInEvent">focusInEvent</a>(), <a href="qwidget.html#focusOutEvent">focusOutEvent</a>(), <a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>(), <a href="qwidget.html#focusWidget">focusWidget</a>(), <a href="qapplication.html#focusWidget">QApplication.focusWidget</a>(),
<a href="qwidget.html#grabKeyboard">grabKeyboard</a>(), <a href="qwidget.html#grabMouse">grabMouse</a>(), <a href="focus.html">Keyboard Focus</a>, and <a href="qevent.html#Type-enum">QEvent.RequestSoftwareInputPanel</a>.</p>


<h3 class="fn"><a name="setFocus-2" />QWidget.setFocus (<i>self</i>, <a href="qt.html#FocusReason-enum">Qt.FocusReason</a>&#160;<i>reason</i>)</h3><p>This is an overloaded function.</p>
<p>Gives the keyboard input focus to this widget (or its focus
proxy) if this widget or one of its parents is the <a href="qwidget.html#isActiveWindow-prop">active window</a>.</p>


<h3 class="fn"><a name="setFocusPolicy" />QWidget.setFocusPolicy (<i>self</i>, <a href="qt.html#FocusPolicy-enum">Qt.FocusPolicy</a>&#160;<i>policy</i>)</h3><h3 class="fn"><a name="setFocusProxy" />QWidget.setFocusProxy (<i>self</i>, <a href="qwidget.html">QWidget</a>)</h3><p>Sets the widget's focus proxy to widget <i>w</i>. If <i>w</i> is
0, the function resets this widget to have no focus proxy.</p>
<p>Some widgets can "have focus", but create a child widget, such
as <a href="qlineedit.html">QLineEdit</a>, to actually handle the
focus. In this case, the widget can set the line edit to be its
focus proxy.</p>
<p>setFocusProxy() sets the widget which will actually get focus
when "this widget" gets it. If there is a focus proxy, <a href="qwidget.html#setFocus">setFocus</a>() and <a href="qwidget.html#focus-prop">hasFocus</a>() operate on the focus
proxy.</p>
<p><b>See also</b> <a href="qwidget.html#focusProxy">focusProxy</a>().</p>


<h3 class="fn"><a name="setFont" />QWidget.setFont (<i>self</i>, <a href="qfont.html">QFont</a>)</h3><h3 class="fn"><a name="setForegroundRole" />QWidget.setForegroundRole (<i>self</i>, <a href="qpalette.html#ColorRole-enum">QPalette.ColorRole</a>)</h3><p>Sets the foreground role of the widget to <i>role</i>.</p>
<p>The foreground role defines the color from the widget's <a href="qwidget.html#palette-prop">palette</a> that is used to draw the
foreground.</p>
<p>If <i>role</i> is <a href="qpalette.html#ColorRole-enum">QPalette.NoRole</a>, the widget
uses a foreground role that contrasts with the background role.</p>
<p>Note that styles are free to choose any color from the palette.
You can modify the palette or set a style sheet if you don't
achieve the result you want with setForegroundRole().</p>
<p><b>See also</b> <a href="qwidget.html#foregroundRole">foregroundRole</a>() and <a href="qwidget.html#backgroundRole">backgroundRole</a>().</p>


<h3 class="fn"><a name="setGeometry" />QWidget.setGeometry (<i>self</i>, <a href="qrect.html">QRect</a>)</h3><h3 class="fn"><a name="setGeometry-2" />QWidget.setGeometry (<i>self</i>, int&#160;<i>ax</i>, int&#160;<i>ay</i>, int&#160;<i>aw</i>, int&#160;<i>ah</i>)</h3><h3 class="fn"><a name="setGraphicsEffect" />QWidget.setGraphicsEffect (<i>self</i>, <a href="qgraphicseffect.html">QGraphicsEffect</a>&#160;<i>effect</i>)</h3><p>The <i>effect</i> argument has it's ownership transferred to Qt.</p><p>The setGraphicsEffect function is for setting the widget's
graphics effect.</p>
<p>Sets <i>effect</i> as the widget's effect. If there already is
an effect installed on this widget, <a href="qwidget.html">QWidget</a> will delete the existing effect before
installing the new <i>effect</i>.</p>
<p>If <i>effect</i> is the installed on a different widget,
setGraphicsEffect() will remove the effect from the widget and
install it on this widget.</p>
<p><a href="qwidget.html">QWidget</a> takes ownership of
<i>effect</i>.</p>
<p><b>Note:</b> This function will apply the effect on itself and
all its children.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also</b> <a href="qwidget.html#graphicsEffect">graphicsEffect</a>().</p>


<h3 class="fn"><a name="setHidden" />QWidget.setHidden (<i>self</i>, bool&#160;<i>hidden</i>)</h3><p>This method is also a Qt slot with the C++ signature <tt>void setHidden(bool)</tt>.</p><p>Convenience function, equivalent to
setVisible(!<i>hidden</i>).</p>
<p><b>See also</b> <a href="qwidget.html#isHidden">isHidden</a>().</p>


<h3 class="fn"><a name="setInputContext" />QWidget.setInputContext (<i>self</i>, <a href="qinputcontext.html">QInputContext</a>)</h3><p>The <i>QInputContext</i> argument has it's ownership transferred to Qt.</p><p>This function sets the input context <i>context</i> on this
widget.</p>
<p>Qt takes ownership of the given input <i>context</i>.</p>
<p><b>See also</b> <a href="qwidget.html#inputContext">inputContext</a>().</p>


<h3 class="fn"><a name="setInputMethodHints" />QWidget.setInputMethodHints (<i>self</i>, <a href="qt-inputmethodhints.html">Qt.InputMethodHints</a>&#160;<i>hints</i>)</h3><h3 class="fn"><a name="setLayout" />QWidget.setLayout (<i>self</i>, <a href="qlayout.html">QLayout</a>)</h3><p>The <i>QLayout</i> argument has it's ownership transferred to Qt.</p><p>Sets the layout manager for this widget to <i>layout</i>.</p>
<p>If there already is a layout manager installed on this widget,
<a href="qwidget.html">QWidget</a> won't let you install another.
You must first delete the existing layout manager (returned by
<a href="qwidget.html#layout">layout</a>()) before you can call
setLayout() with the new layout.</p>
<p>If <i>layout</i> is the layout manger on a different widget,
setLayout() will reparent the layout and make it the layout manager
for this widget.</p>
<p>Example:</p>
<pre class="cpp">
     <span class="type"><a href="qvboxlayout.html">QVBoxLayout</a></span> <span class="operator">*</span>layout <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qvboxlayout.html">QVBoxLayout</a></span>;
     layout<span class="operator">-</span><span class="operator">&gt;</span>addWidget(formWidget);
     setLayout(layout);
</pre>
<p>An alternative to calling this function is to pass this widget
to the layout's constructor.</p>
<p>The <a href="qwidget.html">QWidget</a> will take ownership of
<i>layout</i>.</p>
<p><b>See also</b> <a href="qwidget.html#layout">layout</a>() and
<a href="layout.html">Layout Management</a>.</p>


<h3 class="fn"><a name="setLayoutDirection" />QWidget.setLayoutDirection (<i>self</i>, <a href="qt.html#LayoutDirection-enum">Qt.LayoutDirection</a>&#160;<i>direction</i>)</h3><h3 class="fn"><a name="setLocale" />QWidget.setLocale (<i>self</i>, <a href="qlocale.html">QLocale</a>&#160;<i>locale</i>)</h3><h3 class="fn"><a name="setMask" />QWidget.setMask (<i>self</i>, <a href="qbitmap.html">QBitmap</a>)</h3><p>Causes only the pixels of the widget for which <i>bitmap</i> has
a corresponding 1 bit to be visible. If the region includes pixels
outside the <a href="qwidget.html#rect-prop">rect</a>() of the
widget, window system controls in that area may or may not be
visible, depending on the platform.</p>
<p>Note that this effect can be slow if the region is particularly
complex.</p>
<p>The following code shows how an image with an alpha channel can
be used to generate a mask for a widget:</p>
<pre class="cpp">
     <span class="type"><a href="qlabel.html">QLabel</a></span> topLevelLabel;
     <span class="type"><a href="qpixmap.html">QPixmap</a></span> pixmap(<span class="string">":/images/tux.png"</span>);
     topLevelLabel<span class="operator">.</span>setPixmap(pixmap);
     topLevelLabel<span class="operator">.</span>setMask(pixmap<span class="operator">.</span>mask());
</pre>
<p>The label shown by this code is masked using the image it
contains, giving the appearance that an irregularly-shaped image is
being drawn directly onto the screen.</p>
<p>Masked widgets receive mouse events only on their visible
portions.</p>
<p><b>See also</b> <a href="qwidget.html#mask">mask</a>(), <a href="qwidget.html#clearMask">clearMask</a>(), <a href="qwidget.html#windowOpacity-prop">windowOpacity</a>(), and <a href="widgets-shapedclock.html">Shaped Clock Example</a>.</p>


<h3 class="fn"><a name="setMask-2" />QWidget.setMask (<i>self</i>, <a href="qregion.html">QRegion</a>)</h3><p>This is an overloaded function.</p>
<p>Causes only the parts of the widget which overlap <i>region</i>
to be visible. If the region includes pixels outside the <a href="qwidget.html#rect-prop">rect</a>() of the widget, window system
controls in that area may or may not be visible, depending on the
platform.</p>
<p>Note that this effect can be slow if the region is particularly
complex.</p>
<p><b>See also</b> <a href="qwidget.html#windowOpacity-prop">windowOpacity</a>.</p>


<h3 class="fn"><a name="setMaximumHeight" />QWidget.setMaximumHeight (<i>self</i>, int&#160;<i>maxh</i>)</h3><h3 class="fn"><a name="setMaximumSize" />QWidget.setMaximumSize (<i>self</i>, int&#160;<i>maxw</i>, int&#160;<i>maxh</i>)</h3><h3 class="fn"><a name="setMaximumSize-2" />QWidget.setMaximumSize (<i>self</i>, <a href="qsize.html">QSize</a>&#160;<i>s</i>)</h3><h3 class="fn"><a name="setMaximumWidth" />QWidget.setMaximumWidth (<i>self</i>, int&#160;<i>maxw</i>)</h3><h3 class="fn"><a name="setMinimumHeight" />QWidget.setMinimumHeight (<i>self</i>, int&#160;<i>minh</i>)</h3><h3 class="fn"><a name="setMinimumSize" />QWidget.setMinimumSize (<i>self</i>, int&#160;<i>minw</i>, int&#160;<i>minh</i>)</h3><h3 class="fn"><a name="setMinimumSize-2" />QWidget.setMinimumSize (<i>self</i>, <a href="qsize.html">QSize</a>&#160;<i>s</i>)</h3><h3 class="fn"><a name="setMinimumWidth" />QWidget.setMinimumWidth (<i>self</i>, int&#160;<i>minw</i>)</h3><h3 class="fn"><a name="setMouseTracking" />QWidget.setMouseTracking (<i>self</i>, bool&#160;<i>enable</i>)</h3><h3 class="fn"><a name="setPalette" />QWidget.setPalette (<i>self</i>, <a href="qpalette.html">QPalette</a>)</h3><h3 class="fn"><a name="setParent" />QWidget.setParent (<i>self</i>, <a href="qwidget.html">QWidget</a>&#160;<i>parent</i>)</h3><p>The <i>parent</i> argument, if not None, causes <i>self</i> to be owned by Qt instead of PyQt.</p><p>Sets the parent of the widget to <i>parent</i>, and resets the
window flags. The widget is moved to position (0, 0) in its new
parent.</p>
<p>If the new parent widget is in a different window, the
reparented widget and its children are appended to the end of the
<a href="qwidget.html#focusPolicy-prop">tab chain</a> of the new
parent widget, in the same internal order as before. If one of the
moved widgets had keyboard focus, setParent() calls <a href="qwidget.html#clearFocus">clearFocus</a>() for that widget.</p>
<p>If the new parent widget is in the same window as the old
parent, setting the parent doesn't change the tab order or keyboard
focus.</p>
<p>If the "new" parent widget is the old parent widget, this
function does nothing.</p>
<p><b>Note:</b> The widget becomes invisible as part of changing
its parent, even if it was previously visible. You must call
<a href="qwidget.html#show">show</a>() to make the widget visible
again.</p>
<p><b>Warning:</b> It is very unlikely that you will ever need this
function. If you have a widget that changes its content
dynamically, it is far easier to use <a href="qstackedwidget.html">QStackedWidget</a>.</p>
<p><b>See also</b> <a href="qwidget.html#windowFlags-prop">setWindowFlags</a>().</p>


<h3 class="fn"><a name="setParent-2" />QWidget.setParent (<i>self</i>, <a href="qwidget.html">QWidget</a>&#160;<i>parent</i>, <a href="qt-windowflags.html">Qt.WindowFlags</a>&#160;<i>f</i>)</h3><p>The <i>parent</i> argument, if not None, causes <i>self</i> to be owned by Qt instead of PyQt.</p><p>This is an overloaded function.</p>
<p>This function also takes widget flags, <i>f</i> as an
argument.</p>


<h3 class="fn"><a name="setShortcutAutoRepeat" />QWidget.setShortcutAutoRepeat (<i>self</i>, int&#160;<i>id</i>, bool&#160;<i>enabled</i>&#160;=&#160;True)</h3><p>If <i>enable</i> is true, auto repeat of the shortcut with the
given <i>id</i> is enabled; otherwise it is disabled.</p>
<p>This function was introduced in Qt 4.2.</p>
<p><b>See also</b> <a href="qwidget.html#grabShortcut">grabShortcut</a>() and <a href="qwidget.html#releaseShortcut">releaseShortcut</a>().</p>


<h3 class="fn"><a name="setShortcutEnabled" />QWidget.setShortcutEnabled (<i>self</i>, int&#160;<i>id</i>, bool&#160;<i>enabled</i>&#160;=&#160;True)</h3><p>If <i>enable</i> is true, the shortcut with the given <i>id</i>
is enabled; otherwise the shortcut is disabled.</p>
<p><b>Warning:</b> You should not normally need to use this
function since Qt's shortcut system enables/disables shortcuts
automatically as widgets become hidden/visible and gain or lose
focus. It is best to use <a href="qaction.html">QAction</a> or
<a href="qshortcut.html">QShortcut</a> to handle shortcuts, since
they are easier to use than this low-level function.</p>
<p><b>See also</b> <a href="qwidget.html#grabShortcut">grabShortcut</a>() and <a href="qwidget.html#releaseShortcut">releaseShortcut</a>().</p>


<h3 class="fn"><a name="setShown" />QWidget.setShown (<i>self</i>, bool&#160;<i>shown</i>)</h3><p>This method is also a Qt slot with the C++ signature <tt>void setShown(bool)</tt>.</p><h3 class="fn"><a name="setSizeIncrement" />QWidget.setSizeIncrement (<i>self</i>, int&#160;<i>w</i>, int&#160;<i>h</i>)</h3><h3 class="fn"><a name="setSizeIncrement-2" />QWidget.setSizeIncrement (<i>self</i>, <a href="qsize.html">QSize</a>&#160;<i>s</i>)</h3><h3 class="fn"><a name="setSizePolicy" />QWidget.setSizePolicy (<i>self</i>, <a href="qsizepolicy.html">QSizePolicy</a>)</h3><h3 class="fn"><a name="setSizePolicy-2" />QWidget.setSizePolicy (<i>self</i>, <a href="qsizepolicy.html#Policy-enum">QSizePolicy.Policy</a>&#160;<i>hor</i>, <a href="qsizepolicy.html#Policy-enum">QSizePolicy.Policy</a>&#160;<i>ver</i>)</h3><h3 class="fn"><a name="setStatusTip" />QWidget.setStatusTip (<i>self</i>, QString)</h3><h3 class="fn"><a name="setStyle" />QWidget.setStyle (<i>self</i>, <a href="qstyle.html">QStyle</a>)</h3><p>Sets the widget's GUI style to <i>style</i>. The ownership of
the style object is not transferred.</p>
<p>If no style is set, the widget uses the application's style,
<a href="qapplication.html#style">QApplication.style</a>()
instead.</p>
<p>Setting a widget's style has no effect on existing or future
child widgets.</p>
<p><b>Warning:</b> This function is particularly useful for
demonstration purposes, where you want to show Qt's styling
capabilities. Real applications should avoid it and use one
consistent GUI style instead.</p>
<p><b>Warning:</b> Qt style sheets are currently not supported for
custom <a href="qstyle.html">QStyle</a> subclasses. We plan to
address this in some future release.</p>
<p><b>See also</b> <a href="qwidget.html#style">style</a>(),
<a href="qstyle.html">QStyle</a>, <a href="qapplication.html#style">QApplication.style</a>(), and <a href="qapplication.html#setStyle">QApplication.setStyle</a>().</p>


<h3 class="fn"><a name="setStyleSheet" />QWidget.setStyleSheet (<i>self</i>, QString&#160;<i>styleSheet</i>)</h3><h3 class="fn"><a name="setTabOrder" />QWidget.setTabOrder (<a href="qwidget.html">QWidget</a>, <a href="qwidget.html">QWidget</a>)</h3><p>Puts the <i>second</i> widget after the <i>first</i> widget in
the focus order.</p>
<p>Note that since the tab order of the <i>second</i> widget is
changed, you should order a chain like this:</p>
<pre class="cpp">
 setTabOrder(a<span class="operator">,</span> b); <span class="comment">// a to b</span>
 setTabOrder(b<span class="operator">,</span> c); <span class="comment">// a to b to c</span>
 setTabOrder(c<span class="operator">,</span> d); <span class="comment">// a to b to c to d</span>
</pre>
<p><i>not</i> like this:</p>
<pre class="cpp">
 <span class="comment">// WRONG</span>
 setTabOrder(c<span class="operator">,</span> d); <span class="comment">// c to d</span>
 setTabOrder(a<span class="operator">,</span> b); <span class="comment">// a to b AND c to d</span>
 setTabOrder(b<span class="operator">,</span> c); <span class="comment">// a to b to c, but not c to d</span>
</pre>
<p>If <i>first</i> or <i>second</i> has a focus proxy,
setTabOrder() correctly substitutes the proxy.</p>
<p><b>See also</b> <a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>(), <a href="qwidget.html#setFocusProxy">setFocusProxy</a>(), and <a href="focus.html">Keyboard Focus</a>.</p>


<h3 class="fn"><a name="setToolTip" />QWidget.setToolTip (<i>self</i>, QString)</h3><h3 class="fn"><a name="setUpdatesEnabled" />QWidget.setUpdatesEnabled (<i>self</i>, bool&#160;<i>enable</i>)</h3><h3 class="fn"><a name="setVisible" />QWidget.setVisible (<i>self</i>, bool&#160;<i>visible</i>)</h3><p>This method is also a Qt slot with the C++ signature <tt>void setVisible(bool)</tt>.</p><h3 class="fn"><a name="setWhatsThis" />QWidget.setWhatsThis (<i>self</i>, QString)</h3><h3 class="fn"><a name="setWindowFilePath" />QWidget.setWindowFilePath (<i>self</i>, QString&#160;<i>filePath</i>)</h3><h3 class="fn"><a name="setWindowFlags" />QWidget.setWindowFlags (<i>self</i>, <a href="qt-windowflags.html">Qt.WindowFlags</a>&#160;<i>type</i>)</h3><h3 class="fn"><a name="setWindowIcon" />QWidget.setWindowIcon (<i>self</i>, <a href="qicon.html">QIcon</a>&#160;<i>icon</i>)</h3><h3 class="fn"><a name="setWindowIconText" />QWidget.setWindowIconText (<i>self</i>, QString)</h3><h3 class="fn"><a name="setWindowModality" />QWidget.setWindowModality (<i>self</i>, <a href="qt.html#WindowModality-enum">Qt.WindowModality</a>&#160;<i>windowModality</i>)</h3><h3 class="fn"><a name="setWindowModified" />QWidget.setWindowModified (<i>self</i>, bool)</h3><p>This method is also a Qt slot with the C++ signature <tt>void setWindowModified(bool)</tt>.</p><h3 class="fn"><a name="setWindowOpacity" />QWidget.setWindowOpacity (<i>self</i>, float&#160;<i>level</i>)</h3><h3 class="fn"><a name="setWindowRole" />QWidget.setWindowRole (<i>self</i>, QString)</h3><p>Sets the window's role to <i>role</i>. This only makes sense for
windows on X11.</p>
<p><b>See also</b> <a href="qwidget.html#windowRole">windowRole</a>().</p>


<h3 class="fn"><a name="setWindowState" />QWidget.setWindowState (<i>self</i>, <a href="qt-windowstates.html">Qt.WindowStates</a>&#160;<i>state</i>)</h3><p>Sets the window state to <i>windowState</i>. The window state is
a OR'ed combination of <a href="qt.html#WindowState-enum">Qt.WindowState</a>: <a href="qt.html#WindowState-enum">Qt.WindowMinimized</a>, <a href="qt.html#WindowState-enum">Qt.WindowMaximized</a>, <a href="qt.html#WindowState-enum">Qt.WindowFullScreen</a>, and <a href="qt.html#WindowState-enum">Qt.WindowActive</a>.</p>
<p>If the window is not visible (i.e. <a href="qwidget.html#visible-prop">isVisible</a>() returns false), the
window state will take effect when <a href="qwidget.html#show">show</a>() is called. For visible windows, the
change is immediate. For example, to toggle between full-screen and
normal mode, use the following code:</p>
<pre class="cpp">
 w<span class="operator">-</span><span class="operator">&gt;</span>setWindowState(w<span class="operator">-</span><span class="operator">&gt;</span>windowState() <span class="operator">^</span> <span class="type"><a href="qt.html">Qt</a></span><span class="operator">.</span>WindowFullScreen);
</pre>
<p>In order to restore and activate a minimized window (while
preserving its maximized and/or full-screen state), use the
following:</p>
<pre class="cpp">
 w<span class="operator">-</span><span class="operator">&gt;</span>setWindowState(w<span class="operator">-</span><span class="operator">&gt;</span>windowState() <span class="operator">&amp;</span> <span class="operator">~</span><span class="type"><a href="qt.html">Qt</a></span><span class="operator">.</span>WindowMinimized <span class="operator">|</span> <span class="type"><a href="qt.html">Qt</a></span><span class="operator">.</span>WindowActive);
</pre>
<p>Calling this function will hide the widget. You must call
<a href="qwidget.html#show">show</a>() to make the widget visible
again.</p>
<p><b>Note:</b> On some window systems <a href="qt.html#WindowState-enum">Qt.WindowActive</a> is not immediate,
and may be ignored in certain cases.</p>
<p>When the window state changes, the widget receives a <a href="qwidget.html#changeEvent">changeEvent</a>() of type <a href="qevent.html#Type-enum">QEvent.WindowStateChange</a>.</p>
<p><b>See also</b> <a href="qt.html#WindowState-enum">Qt.WindowState</a> and <a href="qwidget.html#windowState">windowState</a>().</p>


<h3 class="fn"><a name="setWindowTitle" />QWidget.setWindowTitle (<i>self</i>, QString)</h3><h3 class="fn"><a name="show" />QWidget.show (<i>self</i>)</h3><p>This method is also a Qt slot with the C++ signature <tt>void show()</tt>.</p><p>Shows the widget and its child widgets. This function is
equivalent to setVisible(true).</p>
<p><b>See also</b> <a href="qwidget.html#raise">raise_</a>(),
<a href="qwidget.html#showEvent">showEvent</a>(), <a href="qwidget.html#hide">hide</a>(), <a href="qwidget.html#visible-prop">setVisible</a>(), <a href="qwidget.html#showMinimized">showMinimized</a>(), <a href="qwidget.html#showMaximized">showMaximized</a>(), <a href="qwidget.html#showNormal">showNormal</a>(), and <a href="qwidget.html#visible-prop">isVisible</a>().</p>


<h3 class="fn"><a name="showEvent" />QWidget.showEvent (<i>self</i>, <a href="qshowevent.html">QShowEvent</a>)</h3><p>This event handler can be reimplemented in a subclass to receive
widget show events which are passed in the <i>event</i>
parameter.</p>
<p>Non-spontaneous show events are sent to widgets immediately
before they are shown. The spontaneous show events of windows are
delivered afterwards.</p>
<p>Note: A widget receives spontaneous show and hide events when
its mapping status is changed by the window system, e.g. a
spontaneous hide event when the user minimizes the window, and a
spontaneous show event when the window is restored again. After
receiving a spontaneous hide event, a widget is still considered
visible in the sense of <a href="qwidget.html#visible-prop">isVisible</a>().</p>
<p><b>See also</b> <a href="qwidget.html#visible-prop">visible</a>,
<a href="qwidget.html#event">event</a>(), and <a href="qshowevent.html">QShowEvent</a>.</p>


<h3 class="fn"><a name="showFullScreen" />QWidget.showFullScreen (<i>self</i>)</h3><p>This method is also a Qt slot with the C++ signature <tt>void showFullScreen()</tt>.</p><p>Shows the widget in full-screen mode.</p>
<p>Calling this function only affects <a href="qwidget.html#isWindow">windows</a>.</p>
<p>To return from full-screen mode, call <a href="qwidget.html#showNormal">showNormal</a>().</p>
<p>Full-screen mode works fine under Windows, but has certain
problems under X. These problems are due to limitations of the
ICCCM protocol that specifies the communication between X11 clients
and the window manager. ICCCM simply does not understand the
concept of non-decorated full-screen windows. Therefore, the best
we can do is to request a borderless window and place and resize it
to fill the entire screen. Depending on the window manager, this
may or may not work. The borderless window is requested using MOTIF
hints, which are at least partially supported by virtually all
modern window managers.</p>
<p>An alternative would be to bypass the window manager entirely
and create a window with the <a href="qt.html#WindowType-enum">Qt.X11BypassWindowManagerHint</a> flag.
This has other severe problems though, like totally broken keyboard
focus and very strange effects on desktop changes or when the user
raises other windows.</p>
<p>X11 window managers that follow modern post-ICCCM specifications
support full-screen mode properly.</p>
<p><b>See also</b> <a href="qwidget.html#showNormal">showNormal</a>(), <a href="qwidget.html#showMaximized">showMaximized</a>(), <a href="qwidget.html#show">show</a>(), <a href="qwidget.html#hide">hide</a>(), and <a href="qwidget.html#visible-prop">isVisible</a>().</p>


<h3 class="fn"><a name="showMaximized" />QWidget.showMaximized (<i>self</i>)</h3><p>This method is also a Qt slot with the C++ signature <tt>void showMaximized()</tt>.</p><p>Shows the widget maximized.</p>
<p>Calling this function only affects <a href="qwidget.html#isWindow">windows</a>.</p>
<p>On X11, this function may not work properly with certain window
managers. See the <a href="application-windows.html#window-geometry">Window Geometry</a>
documentation for an explanation.</p>
<p><b>See also</b> <a href="qwidget.html#setWindowState">setWindowState</a>(), <a href="qwidget.html#showNormal">showNormal</a>(), <a href="qwidget.html#showMinimized">showMinimized</a>(), <a href="qwidget.html#show">show</a>(), <a href="qwidget.html#hide">hide</a>(), and <a href="qwidget.html#visible-prop">isVisible</a>().</p>


<h3 class="fn"><a name="showMinimized" />QWidget.showMinimized (<i>self</i>)</h3><p>This method is also a Qt slot with the C++ signature <tt>void showMinimized()</tt>.</p><p>Shows the widget minimized, as an icon.</p>
<p>Calling this function only affects <a href="qwidget.html#isWindow">windows</a>.</p>
<p><b>See also</b> <a href="qwidget.html#showNormal">showNormal</a>(), <a href="qwidget.html#showMaximized">showMaximized</a>(), <a href="qwidget.html#show">show</a>(), <a href="qwidget.html#hide">hide</a>(), <a href="qwidget.html#visible-prop">isVisible</a>(), and <a href="qwidget.html#minimized-prop">isMinimized</a>().</p>


<h3 class="fn"><a name="showNormal" />QWidget.showNormal (<i>self</i>)</h3><p>This method is also a Qt slot with the C++ signature <tt>void showNormal()</tt>.</p><p>Restores the widget after it has been maximized or
minimized.</p>
<p>Calling this function only affects <a href="qwidget.html#isWindow">windows</a>.</p>
<p><b>See also</b> <a href="qwidget.html#setWindowState">setWindowState</a>(), <a href="qwidget.html#showMinimized">showMinimized</a>(), <a href="qwidget.html#showMaximized">showMaximized</a>(), <a href="qwidget.html#show">show</a>(), <a href="qwidget.html#hide">hide</a>(), and <a href="qwidget.html#visible-prop">isVisible</a>().</p>


<h3 class="fn"><a name="size" /><a href="qsize.html">QSize</a> QWidget.size (<i>self</i>)</h3><h3 class="fn"><a name="sizeHint" /><a href="qsize.html">QSize</a> QWidget.sizeHint (<i>self</i>)</h3><h3 class="fn"><a name="sizeIncrement" /><a href="qsize.html">QSize</a> QWidget.sizeIncrement (<i>self</i>)</h3><h3 class="fn"><a name="sizePolicy" /><a href="qsizepolicy.html">QSizePolicy</a> QWidget.sizePolicy (<i>self</i>)</h3><h3 class="fn"><a name="stackUnder" />QWidget.stackUnder (<i>self</i>, <a href="qwidget.html">QWidget</a>)</h3><p>Places the widget under <i>w</i> in the parent widget's
stack.</p>
<p>To make this work, the widget itself and <i>w</i> must be
siblings.</p>
<p><b>See also</b> <a href="qwidget.html#raise">raise_</a>() and
<a href="qwidget.html#lower">lower</a>().</p>


<h3 class="fn"><a name="statusTip" />QString QWidget.statusTip (<i>self</i>)</h3><h3 class="fn"><a name="style" /><a href="qstyle.html">QStyle</a> QWidget.style (<i>self</i>)</h3><p><b>See also</b> <a href="qwidget.html#setStyle">QWidget.setStyle</a>(), <a href="qapplication.html#setStyle">QApplication.setStyle</a>(), and
<a href="qapplication.html#style">QApplication.style</a>().</p>


<h3 class="fn"><a name="styleSheet" />QString QWidget.styleSheet (<i>self</i>)</h3><h3 class="fn"><a name="tabletEvent" />QWidget.tabletEvent (<i>self</i>, <a href="qtabletevent.html">QTabletEvent</a>)</h3><p>This event handler, for event <i>event</i>, can be reimplemented
in a subclass to receive tablet events for the widget.</p>
<p>If you reimplement this handler, it is very important that you
<a href="qtabletevent.html">ignore()</a> the event if you do not
handle it, so that the widget's parent can interpret it.</p>
<p>The default implementation ignores the event.</p>
<p><b>See also</b> <a href="qevent.html#ignore">QTabletEvent.ignore</a>(), <a href="qevent.html#accept">QTabletEvent.accept</a>(), <a href="qwidget.html#event">event</a>(), and <a href="qtabletevent.html">QTabletEvent</a>.</p>


<h3 class="fn"><a name="testAttribute" />bool QWidget.testAttribute (<i>self</i>, <a href="qt.html#WidgetAttribute-enum">Qt.WidgetAttribute</a>&#160;<i>attribute</i>)</h3><p>Returns true if attribute <i>attribute</i> is set on this
widget; otherwise returns false.</p>
<p><b>See also</b> <a href="qwidget.html#setAttribute">setAttribute</a>().</p>


<h3 class="fn"><a name="toolTip" />QString QWidget.toolTip (<i>self</i>)</h3><h3 class="fn"><a name="topLevelWidget" /><a href="qwidget.html">QWidget</a> QWidget.topLevelWidget (<i>self</i>)</h3><h3 class="fn"><a name="underMouse" />bool QWidget.underMouse (<i>self</i>)</h3><p>Returns true if the widget is under the mouse cursor; otherwise
returns false.</p>
<p>This value is not updated properly during drag and drop
operations.</p>
<p><b>See also</b> <a href="qwidget.html#enterEvent">enterEvent</a>() and <a href="qwidget.html#leaveEvent">leaveEvent</a>().</p>


<h3 class="fn"><a name="ungrabGesture" />QWidget.ungrabGesture (<i>self</i>, <a href="qt.html#GestureType-enum">Qt.GestureType</a>&#160;<i>type</i>)</h3><p>Unsubscribes the widget from a given <i>gesture</i> type</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also</b> <a href="qwidget.html#grabGesture">grabGesture</a>() and <a href="qgestureevent.html">QGestureEvent</a>.</p>


<h3 class="fn"><a name="unsetCursor" />QWidget.unsetCursor (<i>self</i>)</h3><h3 class="fn"><a name="unsetLayoutDirection" />QWidget.unsetLayoutDirection (<i>self</i>)</h3><h3 class="fn"><a name="unsetLocale" />QWidget.unsetLocale (<i>self</i>)</h3><h3 class="fn"><a name="update" />QWidget.update (<i>self</i>)</h3><p>This method is also a Qt slot with the C++ signature <tt>void update()</tt>.</p><p>Updates the widget unless updates are disabled or the widget is
hidden.</p>
<p>This function does not cause an immediate repaint; instead it
schedules a paint event for processing when Qt returns to the main
event loop. This permits Qt to optimize for more speed and less
flicker than a call to <a href="qwidget.html#repaint">repaint</a>()
does.</p>
<p>Calling update() several times normally results in just one
<a href="qwidget.html#paintEvent">paintEvent</a>() call.</p>
<p>Qt normally erases the widget's area before the <a href="qwidget.html#paintEvent">paintEvent</a>() call. If the <a href="qt.html#WidgetAttribute-enum">Qt.WA_OpaquePaintEvent</a> widget
attribute is set, the widget is responsible for painting all its
pixels with an opaque color.</p>
<p><b>See also</b> <a href="qwidget.html#repaint">repaint</a>(),
<a href="qwidget.html#paintEvent">paintEvent</a>(), <a href="qwidget.html#updatesEnabled-prop">setUpdatesEnabled</a>(), and
<a href="widgets-analogclock.html">Analog Clock Example</a>.</p>


<h3 class="fn"><a name="update-2" />QWidget.update (<i>self</i>, <a href="qrect.html">QRect</a>)</h3><p>This is an overloaded function.</p>
<p>This version updates a rectangle (<i>x</i>, <i>y</i>, <i>w</i>,
<i>h</i>) inside the widget.</p>


<h3 class="fn"><a name="update-3" />QWidget.update (<i>self</i>, <a href="qregion.html">QRegion</a>)</h3><p>This is an overloaded function.</p>
<p>This version updates a rectangle <i>rect</i> inside the
widget.</p>


<h3 class="fn"><a name="update-4" />QWidget.update (<i>self</i>, int&#160;<i>ax</i>, int&#160;<i>ay</i>, int&#160;<i>aw</i>, int&#160;<i>ah</i>)</h3><p>This is an overloaded function.</p>
<p>This version repaints a region <i>rgn</i> inside the widget.</p>


<h3 class="fn"><a name="updateGeometry" />QWidget.updateGeometry (<i>self</i>)</h3><p>Notifies the layout system that this widget has changed and may
need to change geometry.</p>
<p>Call this function if the <a href="qwidget.html#sizeHint-prop">sizeHint</a>() or <a href="qwidget.html#sizePolicy-prop">sizePolicy</a>() have changed.</p>
<p>For explicitly hidden widgets, updateGeometry() is a no-op. The
layout system will be notified as soon as the widget is shown.</p>


<h3 class="fn"><a name="updateMicroFocus" />QWidget.updateMicroFocus (<i>self</i>)</h3><p>Updates the widget's micro focus.</p>
<p><b>See also</b> <a href="qinputcontext.html">QInputContext</a>.</p>


<h3 class="fn"><a name="updatesEnabled" />bool QWidget.updatesEnabled (<i>self</i>)</h3><h3 class="fn"><a name="visibleRegion" /><a href="qregion.html">QRegion</a> QWidget.visibleRegion (<i>self</i>)</h3><p>Returns the unobscured region where paint events can occur.</p>
<p>For visible widgets, this is an approximation of the area not
covered by other widgets; otherwise, this is an empty region.</p>
<p>The <a href="qwidget.html#repaint">repaint</a>() function calls
this function if necessary, so in general you do not need to call
it.</p>


<h3 class="fn"><a name="whatsThis" />QString QWidget.whatsThis (<i>self</i>)</h3><h3 class="fn"><a name="wheelEvent" />QWidget.wheelEvent (<i>self</i>, <a href="qwheelevent.html">QWheelEvent</a>)</h3><p>This event handler, for event <i>event</i>, can be reimplemented
in a subclass to receive wheel events for the widget.</p>
<p>If you reimplement this handler, it is very important that you
<a href="qwheelevent.html">ignore()</a> the event if you do not
handle it, so that the widget's parent can interpret it.</p>
<p>The default implementation ignores the event.</p>
<p><b>See also</b> <a href="qevent.html#ignore">QWheelEvent.ignore</a>(), <a href="qevent.html#accept">QWheelEvent.accept</a>(), <a href="qwidget.html#event">event</a>(), and <a href="qwheelevent.html">QWheelEvent</a>.</p>


<h3 class="fn"><a name="width" />int QWidget.width (<i>self</i>)</h3><h3 class="fn"><a name="window" /><a href="qwidget.html">QWidget</a> QWidget.window (<i>self</i>)</h3><p>Returns the window for this widget, i.e. the next ancestor
widget that has (or could have) a window-system frame.</p>
<p>If the widget is a window, the widget itself is returned.</p>
<p>Typical usage is changing the window title:</p>
<pre class="cpp">
 aWidget<span class="operator">-</span><span class="operator">&gt;</span>window()<span class="operator">-</span><span class="operator">&gt;</span><a href="qwidget.html#windowTitle-prop">setWindowTitle</a>(<span class="string">"New Window Title"</span>);
</pre>
<p><b>See also</b> <a href="qwidget.html#isWindow">isWindow</a>().</p>


<h3 class="fn"><a name="windowActivationChange" />QWidget.windowActivationChange (<i>self</i>, bool)</h3><h3 class="fn"><a name="windowFilePath" />QString QWidget.windowFilePath (<i>self</i>)</h3><h3 class="fn"><a name="windowFlags" /><a href="qt-windowflags.html">Qt.WindowFlags</a> QWidget.windowFlags (<i>self</i>)</h3><h3 class="fn"><a name="windowIcon" /><a href="qicon.html">QIcon</a> QWidget.windowIcon (<i>self</i>)</h3><h3 class="fn"><a name="windowIconText" />QString QWidget.windowIconText (<i>self</i>)</h3><h3 class="fn"><a name="windowModality" /><a href="qt.html#WindowModality-enum">Qt.WindowModality</a> QWidget.windowModality (<i>self</i>)</h3><h3 class="fn"><a name="windowOpacity" />float QWidget.windowOpacity (<i>self</i>)</h3><h3 class="fn"><a name="windowRole" />QString QWidget.windowRole (<i>self</i>)</h3><p>Returns the window's role, or an empty string.</p>
<p><b>See also</b> <a href="qwidget.html#setWindowRole">setWindowRole</a>(), <a href="qwidget.html#windowIcon-prop">windowIcon</a>, and <a href="qwidget.html#windowTitle-prop">windowTitle</a>.</p>


<h3 class="fn"><a name="windowState" /><a href="qt-windowstates.html">Qt.WindowStates</a> QWidget.windowState (<i>self</i>)</h3><p>Returns the current window state. The window state is a OR'ed
combination of <a href="qt.html#WindowState-enum">Qt.WindowState</a>: <a href="qt.html#WindowState-enum">Qt.WindowMinimized</a>, <a href="qt.html#WindowState-enum">Qt.WindowMaximized</a>, <a href="qt.html#WindowState-enum">Qt.WindowFullScreen</a>, and <a href="qt.html#WindowState-enum">Qt.WindowActive</a>.</p>
<p><b>See also</b> <a href="qt.html#WindowState-enum">Qt.WindowState</a> and <a href="qwidget.html#setWindowState">setWindowState</a>().</p>


<h3 class="fn"><a name="windowTitle" />QString QWidget.windowTitle (<i>self</i>)</h3><h3 class="fn"><a name="windowType" /><a href="qt.html#WindowType-enum">Qt.WindowType</a> QWidget.windowType (<i>self</i>)</h3><p>Returns the window type of this widget. This is identical to
<a href="qwidget.html#windowFlags-prop">windowFlags</a>() &amp;
<a href="qt.html#WindowType-enum">Qt.WindowType_Mask</a>.</p>
<p><b>See also</b> <a href="qwidget.html#windowFlags-prop">windowFlags</a>.</p>


<h3 class="fn"><a name="winEvent" />(bool, int&#160;<i>result</i>) QWidget.winEvent (<i>self</i>, <a href="msg.html">MSG</a>&#160;<i>message</i>)</h3><p>This special event handler can be reimplemented in a subclass to
receive native Windows events which are passed in the
<i>message</i> parameter.</p>
<p>In your reimplementation of this function, if you want to stop
the event being handled by Qt, return true and set <i>result</i> to
the value that the window procedure should return. If you return
false, this native event is passed back to Qt, which translates the
event into a Qt event and sends it to the widget.</p>
<p><b>Warning:</b> This function is not portable.</p>
<p><b>See also</b> <a href="qcoreapplication.html#winEventFilter">QApplication.winEventFilter</a>().</p>


<h3 class="fn"><a name="winId" />sip.voidptr QWidget.winId (<i>self</i>)</h3><p>Returns the window system identifier of the widget.</p>
<p>Portable in principle, but if you use it you are probably about
to do something non-portable. Be careful.</p>
<p>If a widget is non-native (alien) and winId() is invoked on it,
that widget will be provided a native handle.</p>
<p>On Mac OS X, the type returned depends on which framework Qt was
linked against. If Qt is using Carbon, the {WId} is actually an
HIViewRef. If Qt is using Cocoa, {WId} is a pointer to an
NSView.</p>
<p>This value may change at run-time. An event with type <a href="qevent.html#Type-enum">QEvent.WinIdChange</a> will be sent to the
widget following a change in window system identifier.</p>
<p><b>See also</b> <a href="qwidget.html#find">find</a>().</p>


<h3 class="fn"><a name="x" />int QWidget.x (<i>self</i>)</h3><h3 class="fn"><a name="y" />int QWidget.y (<i>self</i>)</h3><hr /><h2>Qt Signal Documentation</h2><h3 class="fn"><a name="customContextMenuRequested" />void customContextMenuRequested (const QPoint&amp;)</h3><p>This is the default overload of this signal.</p><p>This signal is emitted when the widget's <a href="qwidget.html#contextMenuPolicy-prop">contextMenuPolicy</a> is
<a href="qt.html#ContextMenuPolicy-enum">Qt.CustomContextMenu</a>,
and the user has requested a context menu on the widget. The
position <i>pos</i> is the position of the context menu event that
the widget receives. Normally this is in widget coordinates. The
exception to this rule is <a href="qabstractscrollarea.html">QAbstractScrollArea</a> and its
subclasses that map the context menu event to coordinates of the
<a href="qabstractscrollarea.html#viewport">viewport()</a> .</p>
<p><b>See also</b> <a href="qwidget.html#mapToGlobal">mapToGlobal</a>(), <a href="qmenu.html">QMenu</a>, and <a href="qwidget.html#contextMenuPolicy-prop">contextMenuPolicy</a>.</p>


<address><hr /><div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address"><td align="left" width="25%">PyQt&#160;4.10 for Windows</td><td align="center" width="50%">Copyright &#169; <a href="http://www.riverbankcomputing.com">Riverbank&#160;Computing&#160;Ltd</a> and <a href="http://www.qtsoftware.com">Nokia</a> 2012</td><td align="right" width="25%">Qt&#160;4.8.4</td></tr></table></div></address></body></html>