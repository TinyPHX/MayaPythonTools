<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html><head><title>QGLBuffer Class Reference</title><style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style></head><body><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr /><td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" width="32" /></td><td width="1">&#160;&#160;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&#160;&#183; <a href="classes.html"><font color="#004faf">All Classes</font></a>&#160;&#183; <a href="modules.html"><font color="#004faf">Modules</font></a></td></table><h1 align="center">QGLBuffer Class Reference<br /><sup><sup>[<a href="qtopengl.html">QtOpenGL</a> module]</sup></sup></h1><p>The QGLBuffer class provides functions for creating and managing
GL buffer objects. <a href="#details">More...</a></p>

<h3>Types</h3><ul><li><div class="fn" />enum <b><a href="qglbuffer.html#Access-enum">Access</a></b> { ReadOnly, WriteOnly, ReadWrite }</li><li><div class="fn" />enum <b><a href="qglbuffer.html#Type-enum">Type</a></b> { VertexBuffer, IndexBuffer, PixelPackBuffer, PixelUnpackBuffer }</li><li><div class="fn" />enum <b><a href="qglbuffer.html#UsagePattern-enum">UsagePattern</a></b> { StreamDraw, StreamRead, StreamCopy, StaticDraw, ..., DynamicCopy }</li></ul><h3>Methods</h3><ul><li><div class="fn" /><b><a href="qglbuffer.html#QGLBuffer">__init__</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qglbuffer.html#QGLBuffer-2">__init__</a></b> (<i>self</i>, Type&#160;<i>type</i>)</li><li><div class="fn" /><b><a href="qglbuffer.html#QGLBuffer-3">__init__</a></b> (<i>self</i>, QGLBuffer&#160;<i>other</i>)</li><li><div class="fn" /><b><a href="qglbuffer.html#allocate">allocate</a></b> (<i>self</i>, sip.voidptr&#160;<i>data</i>, int&#160;<i>count</i>)</li><li><div class="fn" /><b><a href="qglbuffer.html#allocate-2">allocate</a></b> (<i>self</i>, int&#160;<i>count</i>)</li><li><div class="fn" />bool <b><a href="qglbuffer.html#bind">bind</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qglbuffer.html#bufferId">bufferId</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qglbuffer.html#create">create</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qglbuffer.html#destroy">destroy</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qglbuffer.html#isCreated">isCreated</a></b> (<i>self</i>)</li><li><div class="fn" />sip.voidptr <b><a href="qglbuffer.html#map">map</a></b> (<i>self</i>, Access&#160;<i>access</i>)</li><li><div class="fn" />bool <b><a href="qglbuffer.html#read">read</a></b> (<i>self</i>, int&#160;<i>offset</i>, sip.voidptr&#160;<i>data</i>, int&#160;<i>count</i>)</li><li><div class="fn" /><b><a href="qglbuffer.html#release">release</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qglbuffer.html#setUsagePattern">setUsagePattern</a></b> (<i>self</i>, UsagePattern&#160;<i>value</i>)</li><li><div class="fn" />int <b><a href="qglbuffer.html#size">size</a></b> (<i>self</i>)</li><li><div class="fn" />Type <b><a href="qglbuffer.html#type">type</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qglbuffer.html#unmap">unmap</a></b> (<i>self</i>)</li><li><div class="fn" />UsagePattern <b><a href="qglbuffer.html#usagePattern">usagePattern</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qglbuffer.html#write">write</a></b> (<i>self</i>, int&#160;<i>offset</i>, sip.voidptr&#160;<i>data</i>, int&#160;<i>count</i>)</li></ul><h3>Static Methods</h3><ul><li><div class="fn" /><b><a href="qglbuffer.html#release-2">release</a></b> (Type&#160;<i>type</i>)</li></ul><a name="details" /><hr /><h2>Detailed Description</h2><p>The QGLBuffer class provides functions for creating and managing
GL buffer objects.</p>
<p>Buffer objects are created in the GL server so that the client
application can avoid uploading vertices, indices, texture image
data, etc every time they are needed.</p>
<p>QGLBuffer objects can be copied around as a reference to the
underlying GL buffer object:</p>
<pre class="cpp">
 <span class="type">QGLBuffer</span> buffer1(<span class="type">QGLBuffer</span><span class="operator">.</span>IndexBuffer);
 buffer1<span class="operator">.</span><a href="qglbuffer.html#create">create</a>();

 <span class="type">QGLBuffer</span> buffer2 <span class="operator">=</span> buffer1;
</pre>
<p>QGLBuffer performs a shallow copy when objects are copied in
this manner, but does not implement copy-on-write semantics. The
original object will be affected whenever the copy is modified.</p>
<hr /><h2>Type Documentation</h2><h3 class="fn"><a name="Access-enum" />QGLBuffer.Access</h3><p>This enum defines the access mode for <a href="qglbuffer.html#map">QGLBuffer.map</a>().</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QGLBuffer.ReadOnly</tt></td>
<td class="topAlign"><tt>0x88B8</tt></td>
<td class="topAlign">The buffer will be mapped for reading
only.</td>
</tr>
<tr>
<td class="topAlign"><tt>QGLBuffer.WriteOnly</tt></td>
<td class="topAlign"><tt>0x88B9</tt></td>
<td class="topAlign">The buffer will be mapped for writing
only.</td>
</tr>
<tr>
<td class="topAlign"><tt>QGLBuffer.ReadWrite</tt></td>
<td class="topAlign"><tt>0x88BA</tt></td>
<td class="topAlign">The buffer will be mapped for reading and
writing.</td>
</tr>
</table>


<h3 class="fn"><a name="Type-enum" />QGLBuffer.Type</h3><p>This enum defines the type of GL buffer object to create with
<a href="qglbuffer.html">QGLBuffer</a>.</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QGLBuffer.VertexBuffer</tt></td>
<td class="topAlign"><tt>0x8892</tt></td>
<td class="topAlign">Vertex buffer object for use when specifying
vertex arrays.</td>
</tr>
<tr>
<td class="topAlign"><tt>QGLBuffer.IndexBuffer</tt></td>
<td class="topAlign"><tt>0x8893</tt></td>
<td class="topAlign">Index buffer object for use with
<tt>glDrawElements()</tt>.</td>
</tr>
<tr>
<td class="topAlign"><tt>QGLBuffer.PixelPackBuffer</tt></td>
<td class="topAlign"><tt>0x88EB</tt></td>
<td class="topAlign">Pixel pack buffer object for reading pixel
data from the GL server (for example, with
<tt>glReadPixels()</tt>). Not supported under OpenGL/ES.</td>
</tr>
<tr>
<td class="topAlign"><tt>QGLBuffer.PixelUnpackBuffer</tt></td>
<td class="topAlign"><tt>0x88EC</tt></td>
<td class="topAlign">Pixel unpack buffer object for writing pixel
data to the GL server (for example, with <tt>glTexImage2D()</tt>).
Not supported under OpenGL/ES.</td>
</tr>
</table>


<h3 class="fn"><a name="UsagePattern-enum" />QGLBuffer.UsagePattern</h3><p>This enum defines the usage pattern of a <a href="qglbuffer.html">QGLBuffer</a> object.</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QGLBuffer.StreamDraw</tt></td>
<td class="topAlign"><tt>0x88E0</tt></td>
<td class="topAlign">The data will be set once and used a few times
for drawing operations. Under OpenGL/ES 1.1 this is identical to
StaticDraw.</td>
</tr>
<tr>
<td class="topAlign"><tt>QGLBuffer.StreamRead</tt></td>
<td class="topAlign"><tt>0x88E1</tt></td>
<td class="topAlign">The data will be set once and used a few times
for reading data back from the GL server. Not supported under
OpenGL/ES.</td>
</tr>
<tr>
<td class="topAlign"><tt>QGLBuffer.StreamCopy</tt></td>
<td class="topAlign"><tt>0x88E2</tt></td>
<td class="topAlign">The data will be set once and used a few times
for reading data back from the GL server for use in further drawing
operations. Not supported under OpenGL/ES.</td>
</tr>
<tr>
<td class="topAlign"><tt>QGLBuffer.StaticDraw</tt></td>
<td class="topAlign"><tt>0x88E4</tt></td>
<td class="topAlign">The data will be set once and used many times
for drawing operations.</td>
</tr>
<tr>
<td class="topAlign"><tt>QGLBuffer.StaticRead</tt></td>
<td class="topAlign"><tt>0x88E5</tt></td>
<td class="topAlign">The data will be set once and used many times
for reading data back from the GL server. Not supported under
OpenGL/ES.</td>
</tr>
<tr>
<td class="topAlign"><tt>QGLBuffer.StaticCopy</tt></td>
<td class="topAlign"><tt>0x88E6</tt></td>
<td class="topAlign">The data will be set once and used many times
for reading data back from the GL server for use in further drawing
operations. Not supported under OpenGL/ES.</td>
</tr>
<tr>
<td class="topAlign"><tt>QGLBuffer.DynamicDraw</tt></td>
<td class="topAlign"><tt>0x88E8</tt></td>
<td class="topAlign">The data will be modified repeatedly and used
many times for drawing operations.</td>
</tr>
<tr>
<td class="topAlign"><tt>QGLBuffer.DynamicRead</tt></td>
<td class="topAlign"><tt>0x88E9</tt></td>
<td class="topAlign">The data will be modified repeatedly and used
many times for reading data back from the GL server. Not supported
under OpenGL/ES.</td>
</tr>
<tr>
<td class="topAlign"><tt>QGLBuffer.DynamicCopy</tt></td>
<td class="topAlign"><tt>0x88EA</tt></td>
<td class="topAlign">The data will be modified repeatedly and used
many times for reading data back from the GL server for use in
further drawing operations. Not supported under OpenGL/ES.</td>
</tr>
</table>
<hr /><h2>Method Documentation</h2><h3 class="fn"><a name="QGLBuffer" />QGLBuffer.__init__ (<i>self</i>)</h3><p>Constructs a new buffer object of type <a href="qglbuffer.html#Type-enum">QGLBuffer.VertexBuffer</a>.</p>
<p>Note: this constructor just creates the <a href="qglbuffer.html">QGLBuffer</a> instance. The actual buffer object
in the GL server is not created until <a href="qglbuffer.html#create">create</a>() is called.</p>
<p><b>See also</b> <a href="qglbuffer.html#create">create</a>().</p>


<h3 class="fn"><a name="QGLBuffer-2" />QGLBuffer.__init__ (<i>self</i>, <a href="qglbuffer.html#Type-enum">Type</a>&#160;<i>type</i>)</h3><p>Constructs a new buffer object of <i>type</i>.</p>
<p>Note: this constructor just creates the <a href="qglbuffer.html">QGLBuffer</a> instance. The actual buffer object
in the GL server is not created until <a href="qglbuffer.html#create">create</a>() is called.</p>
<p><b>See also</b> <a href="qglbuffer.html#create">create</a>().</p>


<h3 class="fn"><a name="QGLBuffer-3" />QGLBuffer.__init__ (<i>self</i>, <a href="qglbuffer.html">QGLBuffer</a>&#160;<i>other</i>)</h3><p>Constructs a shallow copy of <i>other</i>.</p>
<p>Note: <a href="qglbuffer.html">QGLBuffer</a> does not implement
copy-on-write semantics, so <i>other</i> will be affected whenever
the copy is modified.</p>


<h3 class="fn"><a name="allocate" />QGLBuffer.allocate (<i>self</i>, sip.voidptr&#160;<i>data</i>, int&#160;<i>count</i>)</h3><p>Allocates <i>count</i> bytes of space to the buffer, initialized
to the contents of <i>data</i>. Any previous contents will be
removed.</p>
<p>It is assumed that <a href="qglbuffer.html#create">create</a>()
has been called on this buffer and that it has been bound to the
current context.</p>
<p><b>See also</b> <a href="qglbuffer.html#create">create</a>(),
<a href="qglbuffer.html#read">read</a>(), and <a href="qglbuffer.html#write">write</a>().</p>


<h3 class="fn"><a name="allocate-2" />QGLBuffer.allocate (<i>self</i>, int&#160;<i>count</i>)</h3><p>This is an overloaded function.</p>
<p>Allocates <i>count</i> bytes of space to the buffer. Any
previous contents will be removed.</p>
<p>It is assumed that <a href="qglbuffer.html#create">create</a>()
has been called on this buffer and that it has been bound to the
current context.</p>
<p><b>See also</b> <a href="qglbuffer.html#create">create</a>() and
<a href="qglbuffer.html#write">write</a>().</p>


<h3 class="fn"><a name="bind" />bool QGLBuffer.bind (<i>self</i>)</h3><p>Binds the buffer associated with this object to the current GL
context. Returns false if binding was not possible, usually because
<a href="qglbuffer.html#type">type</a>() is not supported on this
GL implementation.</p>
<p>The buffer must be bound to the same <a href="qglcontext.html">QGLContext</a> current when <a href="qglbuffer.html#create">create</a>() was called, or to another
<a href="qglcontext.html">QGLContext</a> that is sharing with it.
Otherwise, false will be returned from this function.</p>
<p><b>See also</b> <a href="qglbuffer.html#release">release</a>()
and <a href="qglbuffer.html#create">create</a>().</p>


<h3 class="fn"><a name="bufferId" />int QGLBuffer.bufferId (<i>self</i>)</h3><p>Returns the GL identifier associated with this buffer; zero if
the buffer has not been created.</p>
<p><b>See also</b> <a href="qglbuffer.html#isCreated">isCreated</a>().</p>


<h3 class="fn"><a name="create" />bool QGLBuffer.create (<i>self</i>)</h3><p>Creates the buffer object in the GL server. Returns true if the
object was created; false otherwise.</p>
<p>This function must be called with a current <a href="qglcontext.html">QGLContext</a>. The buffer will be bound to and
can only be used in that context (or any other context that is
shared with it).</p>
<p>This function will return false if the GL implementation does
not support buffers, or there is no current <a href="qglcontext.html">QGLContext</a>.</p>
<p><b>See also</b> <a href="qglbuffer.html#isCreated">isCreated</a>(), <a href="qglbuffer.html#allocate">allocate</a>(), <a href="qglbuffer.html#write">write</a>(), and <a href="qglbuffer.html#destroy">destroy</a>().</p>


<h3 class="fn"><a name="destroy" />QGLBuffer.destroy (<i>self</i>)</h3><p>Destroys this buffer object, including the storage being used in
the GL server. All references to the buffer will become
invalid.</p>


<h3 class="fn"><a name="isCreated" />bool QGLBuffer.isCreated (<i>self</i>)</h3><p>Returns true if this buffer has been created; false
otherwise.</p>
<p><b>See also</b> <a href="qglbuffer.html#create">create</a>() and
<a href="qglbuffer.html#destroy">destroy</a>().</p>


<h3 class="fn"><a name="map" />sip.voidptr QGLBuffer.map (<i>self</i>, <a href="qglbuffer.html#Access-enum">Access</a>&#160;<i>access</i>)</h3><p>Maps the contents of this buffer into the application's memory
space and returns a pointer to it. Returns null if memory mapping
is not possible. The <i>access</i> parameter indicates the type of
access to be performed.</p>
<p>It is assumed that <a href="qglbuffer.html#create">create</a>()
has been called on this buffer and that it has been bound to the
current context.</p>
<p>This function is only supported under OpenGL/ES if the
<tt>GL_OES_mapbuffer</tt> extension is present.</p>
<p><b>See also</b> <a href="qglbuffer.html#unmap">unmap</a>(),
<a href="qglbuffer.html#create">create</a>(), and <a href="qglbuffer.html#bind">bind</a>().</p>


<h3 class="fn"><a name="read" />bool QGLBuffer.read (<i>self</i>, int&#160;<i>offset</i>, sip.voidptr&#160;<i>data</i>, int&#160;<i>count</i>)</h3><p>Reads the <i>count</i> bytes in this buffer starting at
<i>offset</i> into <i>data</i>. Returns true on success; false if
reading from the buffer is not supported. Buffer reading is not
supported under OpenGL/ES.</p>
<p>It is assumed that this buffer has been bound to the current
context.</p>
<p><b>See also</b> <a href="qglbuffer.html#write">write</a>() and
<a href="qglbuffer.html#bind">bind</a>().</p>


<h3 class="fn"><a name="release" />QGLBuffer.release (<i>self</i>)</h3><p>Releases the buffer associated with this object from the current
GL context.</p>
<p>This function must be called with the same <a href="qglcontext.html">QGLContext</a> current as when <a href="qglbuffer.html#bind">bind</a>() was called on the buffer.</p>
<p><b>See also</b> <a href="qglbuffer.html#bind">bind</a>().</p>


<h3 class="fn"><a name="release-2" />QGLBuffer.release (<a href="qglbuffer.html#Type-enum">Type</a>&#160;<i>type</i>)</h3><p>Releases the buffer associated with <i>type</i> in the current
<a href="qglcontext.html">QGLContext</a>.</p>
<p>This function is a direct call to <tt>glBindBuffer(type, 0)</tt>
for use when the caller does not know which <a href="qglbuffer.html">QGLBuffer</a> has been bound to the context but
wants to make sure that it is released.</p>
<pre class="cpp">
 <span class="type"><a href="qglbuffer.html">QGLBuffer</a></span><span class="operator">.</span><a href="qglbuffer.html#release">release</a>(<span class="type"><a href="qglbuffer.html">QGLBuffer</a></span><span class="operator">.</span>VertexBuffer);
</pre>


<h3 class="fn"><a name="setUsagePattern" />QGLBuffer.setUsagePattern (<i>self</i>, <a href="qglbuffer.html#UsagePattern-enum">UsagePattern</a>&#160;<i>value</i>)</h3><p>Sets the usage pattern for this buffer object to <i>value</i>.
This function must be called before <a href="qglbuffer.html#allocate">allocate</a>() or <a href="qglbuffer.html#write">write</a>().</p>
<p><b>See also</b> <a href="qglbuffer.html#usagePattern">usagePattern</a>(), <a href="qglbuffer.html#allocate">allocate</a>(), and <a href="qglbuffer.html#write">write</a>().</p>


<h3 class="fn"><a name="size" />int QGLBuffer.size (<i>self</i>)</h3><p>Returns the size of the data in this buffer, for reading
operations. Returns -1 if fetching the buffer size is not
supported, or the buffer has not been created.</p>
<p>It is assumed that this buffer has been bound to the current
context.</p>
<p><b>See also</b> <a href="qglbuffer.html#isCreated">isCreated</a>() and <a href="qglbuffer.html#bind">bind</a>().</p>


<h3 class="fn"><a name="type" /><a href="qglbuffer.html#Type-enum">Type</a> QGLBuffer.type (<i>self</i>)</h3><p>Returns the type of buffer represented by this object.</p>


<h3 class="fn"><a name="unmap" />bool QGLBuffer.unmap (<i>self</i>)</h3><p>Unmaps the buffer after it was mapped into the application's
memory space with a previous call to <a href="qglbuffer.html#map">map</a>(). Returns true if the unmap
succeeded; false otherwise.</p>
<p>It is assumed that this buffer has been bound to the current
context, and that it was previously mapped with <a href="qglbuffer.html#map">map</a>().</p>
<p>This function is only supported under OpenGL/ES if the
<tt>GL_OES_mapbuffer</tt> extension is present.</p>
<p><b>See also</b> <a href="qglbuffer.html#map">map</a>().</p>


<h3 class="fn"><a name="usagePattern" /><a href="qglbuffer.html#UsagePattern-enum">UsagePattern</a> QGLBuffer.usagePattern (<i>self</i>)</h3><p>Returns the usage pattern for this buffer object. The default
value is <a href="qglbuffer.html#UsagePattern-enum">StaticDraw</a>.</p>
<p><b>See also</b> <a href="qglbuffer.html#setUsagePattern">setUsagePattern</a>().</p>


<h3 class="fn"><a name="write" />QGLBuffer.write (<i>self</i>, int&#160;<i>offset</i>, sip.voidptr&#160;<i>data</i>, int&#160;<i>count</i>)</h3><p>Replaces the <i>count</i> bytes of this buffer starting at
<i>offset</i> with the contents of <i>data</i>. Any other bytes in
the buffer will be left unmodified.</p>
<p>It is assumed that <a href="qglbuffer.html#create">create</a>()
has been called on this buffer and that it has been bound to the
current context.</p>
<p><b>See also</b> <a href="qglbuffer.html#create">create</a>(),
<a href="qglbuffer.html#read">read</a>(), and <a href="qglbuffer.html#allocate">allocate</a>().</p>


<address><hr /><div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address"><td align="left" width="25%">PyQt&#160;4.10 for Windows</td><td align="center" width="50%">Copyright &#169; <a href="http://www.riverbankcomputing.com">Riverbank&#160;Computing&#160;Ltd</a> and <a href="http://www.qtsoftware.com">Nokia</a> 2012</td><td align="right" width="25%">Qt&#160;4.8.4</td></tr></table></div></address></body></html>