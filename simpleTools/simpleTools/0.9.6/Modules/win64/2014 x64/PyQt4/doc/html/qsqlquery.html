<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html><head><title>QSqlQuery Class Reference</title><style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style></head><body><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr /><td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" width="32" /></td><td width="1">&#160;&#160;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&#160;&#183; <a href="classes.html"><font color="#004faf">All Classes</font></a>&#160;&#183; <a href="modules.html"><font color="#004faf">Modules</font></a></td></table><h1 align="center">QSqlQuery Class Reference<br /><sup><sup>[<a href="qtsql.html">QtSql</a> module]</sup></sup></h1><p>The QSqlQuery class provides a means of executing and
manipulating SQL statements. <a href="#details">More...</a></p>

<h3>Types</h3><ul><li><div class="fn" />enum <b><a href="qsqlquery.html#BatchExecutionMode-enum">BatchExecutionMode</a></b> { ValuesAsRows, ValuesAsColumns }</li></ul><h3>Methods</h3><ul><li><div class="fn" /><b><a href="qsqlquery.html#QSqlQuery">__init__</a></b> (<i>self</i>, QSqlResult&#160;<i>r</i>)</li><li><div class="fn" /><b><a href="qsqlquery.html#QSqlQuery-2">__init__</a></b> (<i>self</i>, QString&#160;<i>query</i>&#160;=&#160;QString(), QSqlDatabase&#160;<i>db</i>&#160;=&#160;QSqlDatabase())</li><li><div class="fn" /><b><a href="qsqlquery.html#QSqlQuery-3">__init__</a></b> (<i>self</i>, QSqlDatabase&#160;<i>db</i>)</li><li><div class="fn" /><b><a href="qsqlquery.html#QSqlQuery-4">__init__</a></b> (<i>self</i>, QSqlQuery&#160;<i>other</i>)</li><li><div class="fn" /><b><a href="qsqlquery.html#addBindValue">addBindValue</a></b> (<i>self</i>, QVariant&#160;<i>val</i>, QSql.ParamType&#160;<i>type</i>&#160;=&#160;QSql.In)</li><li><div class="fn" />int <b><a href="qsqlquery.html#at">at</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qsqlquery.html#bindValue">bindValue</a></b> (<i>self</i>, QString&#160;<i>placeholder</i>, QVariant&#160;<i>val</i>, QSql.ParamType&#160;<i>type</i>&#160;=&#160;QSql.In)</li><li><div class="fn" /><b><a href="qsqlquery.html#bindValue-2">bindValue</a></b> (<i>self</i>, int&#160;<i>pos</i>, QVariant&#160;<i>val</i>, QSql.ParamType&#160;<i>type</i>&#160;=&#160;QSql.In)</li><li><div class="fn" />QVariant <b><a href="qsqlquery.html#boundValue">boundValue</a></b> (<i>self</i>, QString&#160;<i>placeholder</i>)</li><li><div class="fn" />QVariant <b><a href="qsqlquery.html#boundValue-2">boundValue</a></b> (<i>self</i>, int&#160;<i>pos</i>)</li><li><div class="fn" />dict-of-QString-QVariant <b><a href="qsqlquery.html#boundValues">boundValues</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qsqlquery.html#clear">clear</a></b> (<i>self</i>)</li><li><div class="fn" />QSqlDriver <b><a href="qsqlquery.html#driver">driver</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qsqlquery.html#exec">exec_</a></b> (<i>self</i>, QString&#160;<i>query</i>)</li><li><div class="fn" />bool <b><a href="qsqlquery.html#exec-2">exec_</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qsqlquery.html#execBatch">execBatch</a></b> (<i>self</i>, BatchExecutionMode&#160;<i>mode</i>&#160;=&#160;QSqlQuery.ValuesAsRows)</li><li><div class="fn" />QString <b><a href="qsqlquery.html#executedQuery">executedQuery</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qsqlquery.html#finish">finish</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qsqlquery.html#first">first</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qsqlquery.html#isActive">isActive</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qsqlquery.html#isForwardOnly">isForwardOnly</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qsqlquery.html#isNull">isNull</a></b> (<i>self</i>, int&#160;<i>field</i>)</li><li><div class="fn" />bool <b><a href="qsqlquery.html#isSelect">isSelect</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qsqlquery.html#isValid">isValid</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qsqlquery.html#last">last</a></b> (<i>self</i>)</li><li><div class="fn" />QSqlError <b><a href="qsqlquery.html#lastError">lastError</a></b> (<i>self</i>)</li><li><div class="fn" />QVariant <b><a href="qsqlquery.html#lastInsertId">lastInsertId</a></b> (<i>self</i>)</li><li><div class="fn" />QString <b><a href="qsqlquery.html#lastQuery">lastQuery</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qsqlquery.html#next">next</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qsqlquery.html#nextResult">nextResult</a></b> (<i>self</i>)</li><li><div class="fn" />QSql.NumericalPrecisionPolicy <b><a href="qsqlquery.html#numericalPrecisionPolicy">numericalPrecisionPolicy</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qsqlquery.html#numRowsAffected">numRowsAffected</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qsqlquery.html#prepare">prepare</a></b> (<i>self</i>, QString&#160;<i>query</i>)</li><li><div class="fn" />bool <b><a href="qsqlquery.html#previous">previous</a></b> (<i>self</i>)</li><li><div class="fn" />QSqlRecord <b><a href="qsqlquery.html#record">record</a></b> (<i>self</i>)</li><li><div class="fn" />QSqlResult <b><a href="qsqlquery.html#result">result</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qsqlquery.html#seek">seek</a></b> (<i>self</i>, int&#160;<i>index</i>, bool&#160;<i>relative</i>&#160;=&#160;False)</li><li><div class="fn" /><b><a href="qsqlquery.html#setForwardOnly">setForwardOnly</a></b> (<i>self</i>, bool&#160;<i>forward</i>)</li><li><div class="fn" /><b><a href="qsqlquery.html#setNumericalPrecisionPolicy">setNumericalPrecisionPolicy</a></b> (<i>self</i>, QSql.NumericalPrecisionPolicy&#160;<i>precisionPolicy</i>)</li><li><div class="fn" />int <b><a href="qsqlquery.html#size">size</a></b> (<i>self</i>)</li><li><div class="fn" />QVariant <b><a href="qsqlquery.html#value">value</a></b> (<i>self</i>, int&#160;<i>i</i>)</li></ul><a name="details" /><hr /><h2>Detailed Description</h2><p>The QSqlQuery class provides a means of executing and
manipulating SQL statements.</p>
<p>QSqlQuery encapsulates the functionality involved in creating,
navigating and retrieving data from SQL queries which are executed
on a <a href="qsqldatabase.html">QSqlDatabase</a>. It can be used
to execute DML (data manipulation language) statements, such as
<tt>SELECT</tt>, <tt>INSERT</tt>, <tt>UPDATE</tt> and
<tt>DELETE</tt>, as well as DDL (data definition language)
statements, such as <tt>CREATE</tt> <tt>TABLE</tt>. It can also be
used to execute database-specific commands which are not standard
SQL (e.g. <tt>SET DATESTYLE=ISO</tt> for PostgreSQL).</p>
<p>Successfully executed SQL statements set the query's state to
active so that <a href="qsqlquery.html#isActive">isActive</a>()
returns true. Otherwise the query's state is set to inactive. In
either case, when executing a new SQL statement, the query is
positioned on an invalid record. An active query must be navigated
to a valid record (so that <a href="qsqlquery.html#isValid">isValid</a>() returns true) before values
can be retrieved.</p>
<p>For some databases, if an active query that is a <tt>SELECT</tt>
statement exists when you call <a href="qsqldatabase.html#commit">commit()</a> or <a href="qsqldatabase.html#rollback">rollback()</a>, the commit or rollback
will fail. See <a href="qsqlquery.html#isActive">isActive</a>() for
details.</p>
<a id="qsqlquery-examples" name="qsqlquery-examples" />
<p>Navigating records is performed with the following
functions:</p>
<ul>
<li><a href="qsqlquery.html#next">next</a>()</li>
<li><a href="qsqlquery.html#previous">previous</a>()</li>
<li><a href="qsqlquery.html#first">first</a>()</li>
<li><a href="qsqlquery.html#last">last</a>()</li>
<li><a href="qsqlquery.html#seek">seek</a>()</li>
</ul>
<p>These functions allow the programmer to move forward, backward
or arbitrarily through the records returned by the query. If you
only need to move forward through the results (e.g., by using
<a href="qsqlquery.html#next">next</a>()), you can use <a href="qsqlquery.html#setForwardOnly">setForwardOnly</a>(), which will
save a significant amount of memory overhead and improve
performance on some databases. Once an active query is positioned
on a valid record, data can be retrieved using <a href="qsqlquery.html#value">value</a>(). All data is transferred from
the SQL backend using <a href="qtwebkit-bridge.html#qvariants">QVariants</a>.</p>
<p>For example:</p>
<pre class="cpp">
     <span class="type">QSqlQuery</span> query(<span class="string">"SELECT country FROM artist"</span>);
     <span class="keyword">while</span> (query<span class="operator">.</span>next()) {
         <span class="type"><a href="qstring.html">QString</a></span> country <span class="operator">=</span> query<span class="operator">.</span>value(<span class="number">0</span>)<span class="operator">.</span>toString();
         doSomething(country);
     }
</pre>
<p>To access the data returned by a query, use value(int). Each
field in the data returned by a <tt>SELECT</tt> statement is
accessed by passing the field's position in the statement, starting
from 0. This makes using <tt>SELECT *</tt> queries inadvisable
because the order of the fields returned is indeterminate.</p>
<p>For the sake of efficiency, there are no functions to access a
field by name (unless you use prepared queries with names, as
explained below). To convert a field name into an index, use
<a href="qsqlquery.html#record">record</a>().<a href="qsqlrecord.html#indexOf">indexOf()</a>, for example:</p>
<pre class="cpp">
     <span class="type">QSqlQuery</span> query(<span class="string">"SELECT * FROM artist"</span>);
     <span class="type">int</span> fieldNo <span class="operator">=</span> query<span class="operator">.</span>record()<span class="operator">.</span>indexOf(<span class="string">"country"</span>);
     <span class="keyword">while</span> (query<span class="operator">.</span>next()) {
         <span class="type"><a href="qstring.html">QString</a></span> country <span class="operator">=</span> query<span class="operator">.</span>value(fieldNo)<span class="operator">.</span>toString();
         doSomething(country);
     }
</pre>
<p>QSqlQuery supports prepared query execution and the binding of
parameter values to placeholders. Some databases don't support
these features, so for those, Qt emulates the required
functionality. For example, the Oracle and ODBC drivers have proper
prepared query support, and Qt makes use of it; but for databases
that don't have this support, Qt implements the feature itself,
e.g. by replacing placeholders with actual values when a query is
executed. Use <a href="qsqlquery.html#numRowsAffected">numRowsAffected</a>() to find out
how many rows were affected by a non-<tt>SELECT</tt> query, and
<a href="qsqlquery.html#size">size</a>() to find how many were
retrieved by a <tt>SELECT</tt>.</p>
<p>Oracle databases identify placeholders by using a colon-name
syntax, e.g <tt>:name</tt>. ODBC simply uses <tt>?</tt> characters.
Qt supports both syntaxes, with the restriction that you can't mix
them in the same query.</p>
<p>You can retrieve the values of all the fields in a single
variable (a map) using <a href="qsqlquery.html#boundValues">boundValues</a>().</p>
<a id="approaches-to-binding-values" name="approaches-to-binding-values" />
<h3>Approaches to Binding Values</h3>
<p>Below we present the same example using each of the four
different binding approaches, as well as one example of binding
values to a stored procedure.</p>
<p><b>Named binding using named placeholders:</b></p>
<pre class="cpp">
     <span class="type">QSqlQuery</span> query;
     query<span class="operator">.</span>prepare(<span class="string">"INSERT INTO person (id, forename, surname) "</span>
                   <span class="string">"VALUES (:id, :forename, :surname)"</span>);
     query<span class="operator">.</span>bindValue(<span class="string">":id"</span><span class="operator">,</span> <span class="number">1001</span>);
     query<span class="operator">.</span>bindValue(<span class="string">":forename"</span><span class="operator">,</span> <span class="string">"Bart"</span>);
     query<span class="operator">.</span>bindValue(<span class="string">":surname"</span><span class="operator">,</span> <span class="string">"Simpson"</span>);
     query<span class="operator">.</span>exec();
</pre>
<p><b>Positional binding using named placeholders:</b></p>
<pre class="cpp">
     <span class="type">QSqlQuery</span> query;
     query<span class="operator">.</span>prepare(<span class="string">"INSERT INTO person (id, forename, surname) "</span>
                   <span class="string">"VALUES (:id, :forename, :surname)"</span>);
     query<span class="operator">.</span>bindValue(<span class="number">0</span><span class="operator">,</span> <span class="number">1001</span>);
     query<span class="operator">.</span>bindValue(<span class="number">1</span><span class="operator">,</span> <span class="string">"Bart"</span>);
     query<span class="operator">.</span>bindValue(<span class="number">2</span><span class="operator">,</span> <span class="string">"Simpson"</span>);
     query<span class="operator">.</span>exec();
</pre>
<p><b>Binding values using positional placeholders (version
1):</b></p>
<pre class="cpp">
     <span class="type">QSqlQuery</span> query;
     query<span class="operator">.</span>prepare(<span class="string">"INSERT INTO person (id, forename, surname) "</span>
                   <span class="string">"VALUES (?, ?, ?)"</span>);
     query<span class="operator">.</span>bindValue(<span class="number">0</span><span class="operator">,</span> <span class="number">1001</span>);
     query<span class="operator">.</span>bindValue(<span class="number">1</span><span class="operator">,</span> <span class="string">"Bart"</span>);
     query<span class="operator">.</span>bindValue(<span class="number">2</span><span class="operator">,</span> <span class="string">"Simpson"</span>);
     query<span class="operator">.</span>exec();
</pre>
<p><b>Binding values using positional placeholders (version
2):</b></p>
<pre class="cpp">
     <span class="type">QSqlQuery</span> query;
     query<span class="operator">.</span>prepare(<span class="string">"INSERT INTO person (id, forename, surname) "</span>
                   <span class="string">"VALUES (?, ?, ?)"</span>);
     query<span class="operator">.</span>addBindValue(<span class="number">1001</span>);
     query<span class="operator">.</span>addBindValue(<span class="string">"Bart"</span>);
     query<span class="operator">.</span>addBindValue(<span class="string">"Simpson"</span>);
     query<span class="operator">.</span>exec();
</pre>
<p><b>Binding values to a stored procedure:</b></p>
<p>This code calls a stored procedure called <tt>AsciiToInt()</tt>,
passing it a character through its in parameter, and taking its
result in the out parameter.</p>
<pre class="cpp">
     <span class="type">QSqlQuery</span> query;
     query<span class="operator">.</span>prepare(<span class="string">"CALL AsciiToInt(?, ?)"</span>);
     query<span class="operator">.</span>bindValue(<span class="number">0</span><span class="operator">,</span> <span class="string">"A"</span>);
     query<span class="operator">.</span>bindValue(<span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="type"><a href="qsql.html">QSql</a></span><span class="operator">.</span>Out);
     query<span class="operator">.</span>exec();
     <span class="type">int</span> i <span class="operator">=</span> query<span class="operator">.</span>boundValue(<span class="number">1</span>)<span class="operator">.</span>toInt(); <span class="comment">// i is 65</span>
</pre>
<p>Note that unbound parameters will retain their values.</p>
<p>Stored procedures that uses the return statement to return
values, or return multiple result sets, are not fully supported.
For specific details see <a href="sql-driver.html">SQL Database
Drivers</a>.</p>
<p><b>Warning:</b> You must load the SQL driver and open the
connection before a QSqlQuery is created. Also, the connection must
remain open while the query exists; otherwise, the behavior of
QSqlQuery is undefined.</p>
<hr /><h2>Type Documentation</h2><h3 class="fn"><a name="BatchExecutionMode-enum" />QSqlQuery.BatchExecutionMode</h3><table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QSqlQuery.ValuesAsRows</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">- Updates multiple rows. Treats every entry in
a <a href="qvariant.html#QVariantList-typedef">QVariantList</a> as
a value for updating the next row.</td>
</tr>
<tr>
<td class="topAlign"><tt>QSqlQuery.ValuesAsColumns</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">- Updates a single row. Treats every entry in
a <a href="qvariant.html#QVariantList-typedef">QVariantList</a> as
a single value of an array type.</td>
</tr>
</table>
<hr /><h2>Method Documentation</h2><h3 class="fn"><a name="QSqlQuery" />QSqlQuery.__init__ (<i>self</i>, <a href="qsqlresult.html">QSqlResult</a>&#160;<i>r</i>)</h3><p>Constructs a <a href="qsqlquery.html">QSqlQuery</a> object which
uses the <a href="qsqlresult.html">QSqlResult</a> <i>result</i> to
communicate with a database.</p>


<h3 class="fn"><a name="QSqlQuery-2" />QSqlQuery.__init__ (<i>self</i>, QString&#160;<i>query</i>&#160;=&#160;QString(), <a href="qsqldatabase.html">QSqlDatabase</a>&#160;<i>db</i>&#160;=&#160;QSqlDatabase())</h3><p>Constructs a <a href="qsqlquery.html">QSqlQuery</a> object using
the SQL <i>query</i> and the database <i>db</i>. If <i>db</i> is
not specified, or is invalid, the application's default database is
used. If <i>query</i> is not an empty string, it will be
executed.</p>
<p><b>See also</b> <a href="qsqldatabase.html">QSqlDatabase</a>.</p>


<h3 class="fn"><a name="QSqlQuery-3" />QSqlQuery.__init__ (<i>self</i>, <a href="qsqldatabase.html">QSqlDatabase</a>&#160;<i>db</i>)</h3><p>Constructs a <a href="qsqlquery.html">QSqlQuery</a> object using
the database <i>db</i>. If <i>db</i> is invalid, the application's
default database will be used.</p>
<p><b>See also</b> <a href="qsqldatabase.html">QSqlDatabase</a>.</p>


<h3 class="fn"><a name="QSqlQuery-4" />QSqlQuery.__init__ (<i>self</i>, <a href="qsqlquery.html">QSqlQuery</a>&#160;<i>other</i>)</h3><p>Constructs a copy of <i>other</i>.</p>


<h3 class="fn"><a name="addBindValue" />QSqlQuery.addBindValue (<i>self</i>, QVariant&#160;<i>val</i>, <a href="qsql-paramtype.html">QSql.ParamType</a>&#160;<i>type</i>&#160;=&#160;QSql.In)</h3><p>Adds the value <i>val</i> to the list of values when using
positional value binding. The order of the addBindValue() calls
determines which placeholder a value will be bound to in the
prepared query. If <i>paramType</i> is <a href="qsql.html#ParamTypeFlag-enum">QSql.Out</a> or <a href="qsql.html#ParamTypeFlag-enum">QSql.InOut</a>, the placeholder
will be overwritten with data from the database after the <a href="qsqlquery.html#exec">exec_</a>() call.</p>
<p>To bind a NULL value, use a null <a href="qvariant.html">QVariant</a>; for example, use
<tt>QVariant(QVariant.String)</tt> if you are binding a
string.</p>
<p><b>See also</b> <a href="qsqlquery.html#bindValue">bindValue</a>(), <a href="qsqlquery.html#prepare">prepare</a>(), <a href="qsqlquery.html#exec">exec_</a>(), <a href="qsqlquery.html#boundValue">boundValue</a>(), and <a href="qsqlquery.html#boundValues">boundValues</a>().</p>


<h3 class="fn"><a name="at" />int QSqlQuery.at (<i>self</i>)</h3><p>Returns the current internal position of the query. The first
record is at position zero. If the position is invalid, the
function returns <a href="qsql.html#Location-enum">QSql.BeforeFirstRow</a> or <a href="qsql.html#Location-enum">QSql.AfterLastRow</a>, which are special
negative values.</p>
<p><b>See also</b> <a href="qsqlquery.html#previous">previous</a>(), <a href="qsqlquery.html#next">next</a>(), <a href="qsqlquery.html#first">first</a>(), <a href="qsqlquery.html#last">last</a>(), <a href="qsqlquery.html#seek">seek</a>(), <a href="qsqlquery.html#isActive">isActive</a>(), and <a href="qsqlquery.html#isValid">isValid</a>().</p>


<h3 class="fn"><a name="bindValue" />QSqlQuery.bindValue (<i>self</i>, QString&#160;<i>placeholder</i>, QVariant&#160;<i>val</i>, <a href="qsql-paramtype.html">QSql.ParamType</a>&#160;<i>type</i>&#160;=&#160;QSql.In)</h3><p>Set the placeholder <i>placeholder</i> to be bound to value
<i>val</i> in the prepared statement. Note that the placeholder
mark (e.g <tt>:</tt>) must be included when specifying the
placeholder name. If <i>paramType</i> is <a href="qsql.html#ParamTypeFlag-enum">QSql.Out</a> or <a href="qsql.html#ParamTypeFlag-enum">QSql.InOut</a>, the placeholder
will be overwritten with data from the database after the <a href="qsqlquery.html#exec">exec_</a>() call. In this case, sufficient
space must be pre-allocated to store the result into.</p>
<p>To bind a NULL value, use a null <a href="qvariant.html">QVariant</a>; for example, use
<tt>QVariant(QVariant.String)</tt> if you are binding a
string.</p>
<p>Values cannot be bound to multiple locations in the query,
eg:</p>
<pre class="cpp">
 INSERT INTO testtable (id<span class="operator">,</span> name<span class="operator">,</span> samename) VALUES (:id<span class="operator">,</span> :name<span class="operator">,</span> :name)
</pre>
<p>Binding to name will bind to the first :name, but not the
second.</p>
<p><b>See also</b> <a href="qsqlquery.html#addBindValue">addBindValue</a>(), <a href="qsqlquery.html#prepare">prepare</a>(), <a href="qsqlquery.html#exec">exec_</a>(), <a href="qsqlquery.html#boundValue">boundValue</a>(), and <a href="qsqlquery.html#boundValues">boundValues</a>().</p>


<h3 class="fn"><a name="bindValue-2" />QSqlQuery.bindValue (<i>self</i>, int&#160;<i>pos</i>, QVariant&#160;<i>val</i>, <a href="qsql-paramtype.html">QSql.ParamType</a>&#160;<i>type</i>&#160;=&#160;QSql.In)</h3><p>Set the placeholder in position <i>pos</i> to be bound to value
<i>val</i> in the prepared statement. Field numbering starts at 0.
If <i>paramType</i> is <a href="qsql.html#ParamTypeFlag-enum">QSql.Out</a> or <a href="qsql.html#ParamTypeFlag-enum">QSql.InOut</a>, the placeholder
will be overwritten with data from the database after the <a href="qsqlquery.html#exec">exec_</a>() call.</p>


<h3 class="fn"><a name="boundValue" />QVariant QSqlQuery.boundValue (<i>self</i>, QString&#160;<i>placeholder</i>)</h3><p>Returns the value for the <i>placeholder</i>.</p>
<p><b>See also</b> <a href="qsqlquery.html#boundValues">boundValues</a>(), <a href="qsqlquery.html#bindValue">bindValue</a>(), and <a href="qsqlquery.html#addBindValue">addBindValue</a>().</p>


<h3 class="fn"><a name="boundValue-2" />QVariant QSqlQuery.boundValue (<i>self</i>, int&#160;<i>pos</i>)</h3><p>Returns the value for the placeholder at position
<i>pos</i>.</p>


<h3 class="fn"><a name="boundValues" />dict-of-QString-QVariant QSqlQuery.boundValues (<i>self</i>)</h3><p>Returns a map of the bound values.</p>
<p>With named binding, the bound values can be examined in the
following ways:</p>
<pre class="cpp">
     <span class="type"><a href="qmapiterator.html">QMapIterator</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">,</span> <span class="type"><a href="qvariant.html">QVariant</a></span><span class="operator">&gt;</span> i(query<span class="operator">.</span>boundValues());
     <span class="keyword">while</span> (i<span class="operator">.</span>hasNext()) {
         i<span class="operator">.</span>next();
         cout <span class="operator">&lt;</span><span class="operator">&lt;</span> i<span class="operator">.</span>key()<span class="operator">.</span>toAscii()<span class="operator">.</span>data() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">": "</span>
              <span class="operator">&lt;</span><span class="operator">&lt;</span> i<span class="operator">.</span>value()<span class="operator">.</span>toString()<span class="operator">.</span>toAscii()<span class="operator">.</span>data() <span class="operator">&lt;</span><span class="operator">&lt;</span> endl;
     }
</pre>
<p>With positional binding, the code becomes:</p>
<pre class="cpp">
     <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qvariant.html">QVariant</a></span><span class="operator">&gt;</span> list <span class="operator">=</span> query<span class="operator">.</span>boundValues()<span class="operator">.</span>values();
     <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> list<span class="operator">.</span>size(); <span class="operator">+</span><span class="operator">+</span>i)
         cout <span class="operator">&lt;</span><span class="operator">&lt;</span> i <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">": "</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> list<span class="operator">.</span>at(i)<span class="operator">.</span>toString()<span class="operator">.</span>toAscii()<span class="operator">.</span>data() <span class="operator">&lt;</span><span class="operator">&lt;</span> endl;
</pre>
<p><b>See also</b> <a href="qsqlquery.html#boundValue">boundValue</a>(), <a href="qsqlquery.html#bindValue">bindValue</a>(), and <a href="qsqlquery.html#addBindValue">addBindValue</a>().</p>


<h3 class="fn"><a name="clear" />QSqlQuery.clear (<i>self</i>)</h3><p>Clears the result set and releases any resources held by the
query. Sets the query state to inactive. You should rarely if ever
need to call this function.</p>


<h3 class="fn"><a name="driver" /><a href="qsqldriver.html">QSqlDriver</a> QSqlQuery.driver (<i>self</i>)</h3><p>Returns the database driver associated with the query.</p>


<h3 class="fn"><a name="exec" />bool QSqlQuery.exec_ (<i>self</i>, QString&#160;<i>query</i>)</h3><p>Executes the SQL in <i>query</i>. Returns true and sets the
query state to <a href="qsqlquery.html#isActive">active</a> if the
query was successful; otherwise returns false. The <i>query</i>
string must use syntax appropriate for the SQL database being
queried (for example, standard SQL).</p>
<p>After the query is executed, the query is positioned on an
<i>invalid</i> record and must be navigated to a valid record
before data values can be retrieved (for example, using <a href="qsqlquery.html#next">next</a>()).</p>
<p>Note that the last error for this query is reset when exec() is
called.</p>
<p>For SQLite, the query string can contain only one statement at a
time. If more than one statements is give, the function returns
false.</p>
<p>Example:</p>
<pre class="cpp">
     <span class="type"><a href="qsqlquery.html">QSqlQuery</a></span> query;
     query<span class="operator">.</span>exec(<span class="string">"INSERT INTO employee (id, name, salary) "</span>
                <span class="string">"VALUES (1001, 'Thad Beaumont', 65000)"</span>);
</pre>
<p><b>See also</b> <a href="qsqlquery.html#isActive">isActive</a>(), <a href="qsqlquery.html#isValid">isValid</a>(), <a href="qsqlquery.html#next">next</a>(), <a href="qsqlquery.html#previous">previous</a>(), <a href="qsqlquery.html#first">first</a>(), <a href="qsqlquery.html#last">last</a>(), and <a href="qsqlquery.html#seek">seek</a>().</p>


<h3 class="fn"><a name="exec-2" />bool QSqlQuery.exec_ (<i>self</i>)</h3><p>Executes a previously prepared SQL query. Returns true if the
query executed successfully; otherwise returns false.</p>
<p>Note that the last error for this query is reset when <a href="qsqlquery.html#exec">exec_</a>() is called.</p>
<p><b>See also</b> <a href="qsqlquery.html#prepare">prepare</a>(),
<a href="qsqlquery.html#bindValue">bindValue</a>(), <a href="qsqlquery.html#addBindValue">addBindValue</a>(), <a href="qsqlquery.html#boundValue">boundValue</a>(), and <a href="qsqlquery.html#boundValues">boundValues</a>().</p>


<h3 class="fn"><a name="execBatch" />bool QSqlQuery.execBatch (<i>self</i>, <a href="qsqlquery.html#BatchExecutionMode-enum">BatchExecutionMode</a>&#160;<i>mode</i>&#160;=&#160;QSqlQuery.ValuesAsRows)</h3><p>Executes a previously prepared SQL query in a batch. All the
bound parameters have to be lists of variants. If the database
doesn't support batch executions, the driver will simulate it using
conventional <a href="qsqlquery.html#exec">exec_</a>() calls.</p>
<p>Returns true if the query is executed successfully; otherwise
returns false.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qsqlquery.html">QSqlQuery</a></span> q;
 q<span class="operator">.</span><a href="qsqlquery.html#prepare">prepare</a>(<span class="string">"insert into myTable values (?, ?)"</span>);

 <span class="type"><a href="qvariant.html#QVariantList-typedef">QVariantList</a></span> ints;
 ints <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">1</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">2</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">4</span>;
 q<span class="operator">.</span><a href="qsqlquery.html#addBindValue">addBindValue</a>(ints);

 <span class="type"><a href="qvariant.html#QVariantList-typedef">QVariantList</a></span> names;
 names <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"Harald"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"Boris"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"Trond"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type"><a href="qvariant.html">QVariant</a></span>(<span class="type"><a href="qvariant.html">QVariant</a></span><span class="operator">.</span>String);
 q<span class="operator">.</span><a href="qsqlquery.html#addBindValue">addBindValue</a>(names);

 <span class="keyword">if</span> (<span class="operator">!</span>q<span class="operator">.</span>execBatch())
     <a href="qtcore.html#qDebug">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> q<span class="operator">.</span><a href="qsqlquery.html#lastError">lastError</a>();
</pre>
<p>The example above inserts four new rows into
<tt>myTable</tt>:</p>
<pre class="cpp">
 <span class="number">1</span>  Harald
 <span class="number">2</span>  Boris
 <span class="number">3</span>  Trond
 <span class="number">4</span>  NULL
</pre>
<p>To bind NULL values, a null <a href="qvariant.html">QVariant</a>
of the relevant type has to be added to the bound <a href="qvariant.html#QVariantList-typedef">QVariantList</a>; for example,
<tt>QVariant(QVariant.String)</tt> should be used if you are using
strings.</p>
<p><b>Note:</b> Every bound <a href="qvariant.html#QVariantList-typedef">QVariantList</a> must contain
the same amount of variants.</p>
<p><b>Note:</b> The type of the <a href="qtwebkit-bridge.html#qvariants">QVariants</a> in a list must not
change. For example, you cannot mix integer and string variants
within a <a href="qvariant.html#QVariantList-typedef">QVariantList</a>.</p>
<p>The <i>mode</i> parameter indicates how the bound <a href="qvariant.html#QVariantList-typedef">QVariantList</a> will be
interpreted. If <i>mode</i> is <tt>ValuesAsRows</tt>, every variant
within the <a href="qvariant.html#QVariantList-typedef">QVariantList</a> will be
interpreted as a value for a new row. <tt>ValuesAsColumns</tt> is a
special case for the Oracle driver. In this mode, every entry
within a <a href="qvariant.html#QVariantList-typedef">QVariantList</a> will be
interpreted as array-value for an IN or OUT value within a stored
procedure. Note that this will only work if the IN or OUT value is
a table-type consisting of only one column of a basic type, for
example <tt>TYPE myType IS TABLE OF VARCHAR(64) INDEX BY
BINARY_INTEGER;</tt></p>
<p>This function was introduced in Qt 4.2.</p>
<p><b>See also</b> <a href="qsqlquery.html#prepare">prepare</a>(),
<a href="qsqlquery.html#bindValue">bindValue</a>(), and <a href="qsqlquery.html#addBindValue">addBindValue</a>().</p>


<h3 class="fn"><a name="executedQuery" />QString QSqlQuery.executedQuery (<i>self</i>)</h3><p>Returns the last query that was successfully executed.</p>
<p>In most cases this function returns the same string as <a href="qsqlquery.html#lastQuery">lastQuery</a>(). If a prepared query
with placeholders is executed on a DBMS that does not support it,
the preparation of this query is emulated. The placeholders in the
original query are replaced with their bound values to form a new
query. This function returns the modified query. It is mostly
useful for debugging purposes.</p>
<p><b>See also</b> <a href="qsqlquery.html#lastQuery">lastQuery</a>().</p>


<h3 class="fn"><a name="finish" />QSqlQuery.finish (<i>self</i>)</h3><p>Instruct the database driver that no more data will be fetched
from this query until it is re-executed. There is normally no need
to call this function, but it may be helpful in order to free
resources such as locks or cursors if you intend to re-use the
query at a later time.</p>
<p>Sets the query to inactive. Bound values retain their
values.</p>
<p>This function was introduced in Qt 4.3.2.</p>
<p><b>See also</b> <a href="qsqlquery.html#prepare">prepare</a>(),
<a href="qsqlquery.html#exec">exec_</a>(), and <a href="qsqlquery.html#isActive">isActive</a>().</p>


<h3 class="fn"><a name="first" />bool QSqlQuery.first (<i>self</i>)</h3><p>Retrieves the first record in the result, if available, and
positions the query on the retrieved record. Note that the result
must be in the <a href="qsqlquery.html#isActive">active</a> state
and <a href="qsqlquery.html#isSelect">isSelect</a>() must return
true before calling this function or it will do nothing and return
false. Returns true if successful. If unsuccessful the query
position is set to an invalid position and false is returned.</p>
<p><b>See also</b> <a href="qsqlquery.html#next">next</a>(),
<a href="qsqlquery.html#previous">previous</a>(), <a href="qsqlquery.html#last">last</a>(), <a href="qsqlquery.html#seek">seek</a>(), <a href="qsqlquery.html#at">at</a>(), <a href="qsqlquery.html#isActive">isActive</a>(), and <a href="qsqlquery.html#isValid">isValid</a>().</p>


<h3 class="fn"><a name="isActive" />bool QSqlQuery.isActive (<i>self</i>)</h3><p>Returns true if the query is <i>active</i>. An active <a href="qsqlquery.html">QSqlQuery</a> is one that has been <a href="qsqlquery.html#exec">exec()'d</a> successfully but not yet
finished with. When you are finished with an active query, you can
make make the query inactive by calling <a href="qsqlquery.html#finish">finish</a>() or <a href="qsqlquery.html#clear">clear</a>(), or you can delete the <a href="qsqlquery.html">QSqlQuery</a> instance.</p>
<p><b>Note:</b> Of particular interest is an active query that is a
<tt>SELECT</tt> statement. For some databases that support
transactions, an active query that is a <tt>SELECT</tt> statement
can cause a <a href="qsqldatabase.html#commit">commit()</a> or a
<a href="qsqldatabase.html#rollback">rollback()</a> to fail, so
before committing or rolling back, you should make your active
<tt>SELECT</tt> statement query inactive using one of the ways
listed above.</p>
<p><b>See also</b> <a href="qsqlquery.html#isSelect">isSelect</a>().</p>


<h3 class="fn"><a name="isForwardOnly" />bool QSqlQuery.isForwardOnly (<i>self</i>)</h3><p>Returns true if you can only scroll forward through a result
set; otherwise returns false.</p>
<p><b>See also</b> <a href="qsqlquery.html#setForwardOnly">setForwardOnly</a>() and <a href="qsqlquery.html#next">next</a>().</p>


<h3 class="fn"><a name="isNull" />bool QSqlQuery.isNull (<i>self</i>, int&#160;<i>field</i>)</h3><p>Returns true if the query is <a href="qsqlquery.html#isActive">active</a> and positioned on a valid
record and the <i>field</i> is NULL; otherwise returns false. Note
that for some drivers, isNull() will not return accurate
information until after an attempt is made to retrieve data.</p>
<p><b>See also</b> <a href="qsqlquery.html#isActive">isActive</a>(), <a href="qsqlquery.html#isValid">isValid</a>(), and <a href="qsqlquery.html#value">value</a>().</p>


<h3 class="fn"><a name="isSelect" />bool QSqlQuery.isSelect (<i>self</i>)</h3><p>Returns true if the current query is a <tt>SELECT</tt>
statement; otherwise returns false.</p>


<h3 class="fn"><a name="isValid" />bool QSqlQuery.isValid (<i>self</i>)</h3><p>Returns true if the query is currently positioned on a valid
record; otherwise returns false.</p>


<h3 class="fn"><a name="last" />bool QSqlQuery.last (<i>self</i>)</h3><p>Retrieves the last record in the result, if available, and
positions the query on the retrieved record. Note that the result
must be in the <a href="qsqlquery.html#isActive">active</a> state
and <a href="qsqlquery.html#isSelect">isSelect</a>() must return
true before calling this function or it will do nothing and return
false. Returns true if successful. If unsuccessful the query
position is set to an invalid position and false is returned.</p>
<p><b>See also</b> <a href="qsqlquery.html#next">next</a>(),
<a href="qsqlquery.html#previous">previous</a>(), <a href="qsqlquery.html#first">first</a>(), <a href="qsqlquery.html#seek">seek</a>(), <a href="qsqlquery.html#at">at</a>(), <a href="qsqlquery.html#isActive">isActive</a>(), and <a href="qsqlquery.html#isValid">isValid</a>().</p>


<h3 class="fn"><a name="lastError" /><a href="qsqlerror.html">QSqlError</a> QSqlQuery.lastError (<i>self</i>)</h3><p>Returns error information about the last error (if any) that
occurred with this query.</p>
<p><b>See also</b> <a href="qsqlerror.html">QSqlError</a> and
<a href="qsqldatabase.html#lastError">QSqlDatabase.lastError</a>().</p>


<h3 class="fn"><a name="lastInsertId" />QVariant QSqlQuery.lastInsertId (<i>self</i>)</h3><p>Returns the object ID of the most recent inserted row if the
database supports it. An invalid <a href="qvariant.html">QVariant</a> will be returned if the query did not
insert any value or if the database does not report the id back. If
more than one row was touched by the insert, the behavior is
undefined.</p>
<p>For MySQL databases the row's auto-increment field will be
returned.</p>
<p><b>Note:</b> For this function to work in PSQL, the table table
must contain OIDs, which may not have been created by default.
Check the <tt>default_with_oids</tt> configuration variable to be
sure.</p>
<p><b>See also</b> <a href="qsqldriver.html#hasFeature">QSqlDriver.hasFeature</a>().</p>


<h3 class="fn"><a name="lastQuery" />QString QSqlQuery.lastQuery (<i>self</i>)</h3><p>Returns the text of the current query being used, or an empty
string if there is no current query text.</p>
<p><b>See also</b> <a href="qsqlquery.html#executedQuery">executedQuery</a>().</p>


<h3 class="fn"><a name="next" />bool QSqlQuery.next (<i>self</i>)</h3><p>Retrieves the next record in the result, if available, and
positions the query on the retrieved record. Note that the result
must be in the <a href="qsqlquery.html#isActive">active</a> state
and <a href="qsqlquery.html#isSelect">isSelect</a>() must return
true before calling this function or it will do nothing and return
false.</p>
<p>The following rules apply:</p>
<ul>
<li>If the result is currently located before the first record,
e.g. immediately after a query is executed, an attempt is made to
retrieve the first record.</li>
<li>If the result is currently located after the last record, there
is no change and false is returned.</li>
<li>If the result is located somewhere in the middle, an attempt is
made to retrieve the next record.</li>
</ul>
<p>If the record could not be retrieved, the result is positioned
after the last record and false is returned. If the record is
successfully retrieved, true is returned.</p>
<p><b>See also</b> <a href="qsqlquery.html#previous">previous</a>(), <a href="qsqlquery.html#first">first</a>(), <a href="qsqlquery.html#last">last</a>(), <a href="qsqlquery.html#seek">seek</a>(), <a href="qsqlquery.html#at">at</a>(), <a href="qsqlquery.html#isActive">isActive</a>(), and <a href="qsqlquery.html#isValid">isValid</a>().</p>


<h3 class="fn"><a name="nextResult" />bool QSqlQuery.nextResult (<i>self</i>)</h3><p>Discards the current result set and navigates to the next if
available.</p>
<p>Some databases are capable of returning multiple result sets for
stored procedures or SQL batches (a query strings that contains
multiple statements). If multiple result sets are available after
executing a query this function can be used to navigate to the next
result set(s).</p>
<p>If a new result set is available this function will return true.
The query will be repositioned on an <i>invalid</i> record in the
new result set and must be navigated to a valid record before data
values can be retrieved. If a new result set isn't available the
function returns false and the query is set to inactive. In any
case the old result set will be discarded.</p>
<p>When one of the statements is a non-select statement a count of
affected rows may be available instead of a result set.</p>
<p>Note that some databases, i.e. Microsoft SQL Server, requires
non-scrollable cursors when working with multiple result sets. Some
databases may execute all statements at once while others may delay
the execution until the result set is actually accessed, and some
databases may have restrictions on which statements are allowed to
be used in a SQL batch.</p>
<p>This function was introduced in Qt 4.4.</p>
<p><b>See also</b> <a href="qsqldriver.html#hasFeature">QSqlDriver.hasFeature</a>(), <a href="qsqlquery.html#setForwardOnly">setForwardOnly</a>(), <a href="qsqlquery.html#next">next</a>(), <a href="qsqlquery.html#isSelect">isSelect</a>(), <a href="qsqlquery.html#numRowsAffected">numRowsAffected</a>(), <a href="qsqlquery.html#isActive">isActive</a>(), and <a href="qsqlquery.html#lastError">lastError</a>().</p>


<h3 class="fn"><a name="numericalPrecisionPolicy" /><a href="qsql.html#NumericalPrecisionPolicy-enum">QSql.NumericalPrecisionPolicy</a> QSqlQuery.numericalPrecisionPolicy (<i>self</i>)</h3><p>Returns the current precision policy.</p>
<p><b>See also</b> <a href="qsql.html#NumericalPrecisionPolicy-enum">QSql.NumericalPrecisionPolicy</a>
and <a href="qsqlquery.html#setNumericalPrecisionPolicy">setNumericalPrecisionPolicy</a>().</p>


<h3 class="fn"><a name="numRowsAffected" />int QSqlQuery.numRowsAffected (<i>self</i>)</h3><p>Returns the number of rows affected by the result's SQL
statement, or -1 if it cannot be determined. Note that for
<tt>SELECT</tt> statements, the value is undefined; use <a href="qsqlquery.html#size">size</a>() instead. If the query is not
<a href="qsqlquery.html#isActive">active</a>, -1 is returned.</p>
<p><b>See also</b> <a href="qsqlquery.html#size">size</a>() and
<a href="qsqldriver.html#hasFeature">QSqlDriver.hasFeature</a>().</p>


<h3 class="fn"><a name="prepare" />bool QSqlQuery.prepare (<i>self</i>, QString&#160;<i>query</i>)</h3><p>Prepares the SQL query <i>query</i> for execution. Returns true
if the query is prepared successfully; otherwise returns false.</p>
<p>The query may contain placeholders for binding values. Both
Oracle style colon-name (e.g., <tt>:surname</tt>), and ODBC style
(<tt>?</tt>) placeholders are supported; but they cannot be mixed
in the same query. See the <a href="qsqlquery.html#qsqlquery-examples">Detailed Description</a> for
examples.</p>
<p>Portability note: Some databases choose to delay preparing a
query until it is executed the first time. In this case, preparing
a syntactically wrong query succeeds, but every consecutive
<a href="qsqlquery.html#exec">exec_</a>() will fail.</p>
<p>For SQLite, the query string can contain only one statement at a
time. If more than one statements are give, the function returns
false.</p>
<p>Example:</p>
<pre class="cpp">
     <span class="type"><a href="qsqlquery.html">QSqlQuery</a></span> query;
     query<span class="operator">.</span>prepare(<span class="string">"INSERT INTO person (id, forename, surname) "</span>
                   <span class="string">"VALUES (:id, :forename, :surname)"</span>);
     query<span class="operator">.</span>bindValue(<span class="string">":id"</span><span class="operator">,</span> <span class="number">1001</span>);
     query<span class="operator">.</span>bindValue(<span class="string">":forename"</span><span class="operator">,</span> <span class="string">"Bart"</span>);
     query<span class="operator">.</span>bindValue(<span class="string">":surname"</span><span class="operator">,</span> <span class="string">"Simpson"</span>);
     query<span class="operator">.</span>exec();
</pre>
<p><b>See also</b> <a href="qsqlquery.html#exec">exec_</a>(),
<a href="qsqlquery.html#bindValue">bindValue</a>(), and <a href="qsqlquery.html#addBindValue">addBindValue</a>().</p>


<h3 class="fn"><a name="previous" />bool QSqlQuery.previous (<i>self</i>)</h3><p>Retrieves the previous record in the result, if available, and
positions the query on the retrieved record. Note that the result
must be in the <a href="qsqlquery.html#isActive">active</a> state
and <a href="qsqlquery.html#isSelect">isSelect</a>() must return
true before calling this function or it will do nothing and return
false.</p>
<p>The following rules apply:</p>
<ul>
<li>If the result is currently located before the first record,
there is no change and false is returned.</li>
<li>If the result is currently located after the last record, an
attempt is made to retrieve the last record.</li>
<li>If the result is somewhere in the middle, an attempt is made to
retrieve the previous record.</li>
</ul>
<p>If the record could not be retrieved, the result is positioned
before the first record and false is returned. If the record is
successfully retrieved, true is returned.</p>
<p><b>See also</b> <a href="qsqlquery.html#next">next</a>(),
<a href="qsqlquery.html#first">first</a>(), <a href="qsqlquery.html#last">last</a>(), <a href="qsqlquery.html#seek">seek</a>(), <a href="qsqlquery.html#at">at</a>(), <a href="qsqlquery.html#isActive">isActive</a>(), and <a href="qsqlquery.html#isValid">isValid</a>().</p>


<h3 class="fn"><a name="record" /><a href="qsqlrecord.html">QSqlRecord</a> QSqlQuery.record (<i>self</i>)</h3><p>Returns a <a href="qsqlrecord.html">QSqlRecord</a> containing
the field information for the current query. If the query points to
a valid row (<a href="qsqlquery.html#isValid">isValid</a>() returns
true), the record is populated with the row's values. An empty
record is returned when there is no active query (<a href="qsqlquery.html#isActive">isActive</a>() returns false).</p>
<p>To retrieve values from a query, <a href="qsqlquery.html#value">value</a>() should be used since its
index-based lookup is faster.</p>
<p>In the following example, a <tt>SELECT * FROM</tt> query is
executed. Since the order of the columns is not defined, <a href="qsqlrecord.html#indexOf">QSqlRecord.indexOf</a>() is used to
obtain the index of a column.</p>
<pre class="cpp">
 <span class="type"><a href="qsqlquery.html">QSqlQuery</a></span> q(<span class="string">"select * from employees"</span>);
 <span class="type"><a href="qsqlrecord.html">QSqlRecord</a></span> rec <span class="operator">=</span> q<span class="operator">.</span>record();

 <a href="qtcore.html#qDebug">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"Number of columns: "</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> rec<span class="operator">.</span>count();

 <span class="type">int</span> nameCol <span class="operator">=</span> rec<span class="operator">.</span>indexOf(<span class="string">"name"</span>); <span class="comment">// index of the field "name"</span>
 <span class="keyword">while</span> (q<span class="operator">.</span>next())
     <a href="qtcore.html#qDebug">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> q<span class="operator">.</span><a href="qsqlquery.html#value">value</a>(nameCol)<span class="operator">.</span>toString(); <span class="comment">// output all names</span>
</pre>
<p><b>See also</b> <a href="qsqlquery.html#value">value</a>().</p>


<h3 class="fn"><a name="result" /><a href="qsqlresult.html">QSqlResult</a> QSqlQuery.result (<i>self</i>)</h3><p>Returns the result associated with the query.</p>


<h3 class="fn"><a name="seek" />bool QSqlQuery.seek (<i>self</i>, int&#160;<i>index</i>, bool&#160;<i>relative</i>&#160;=&#160;False)</h3><p>Retrieves the record at position <i>index</i>, if available, and
positions the query on the retrieved record. The first record is at
position 0. Note that the query must be in an <a href="qsqlquery.html#isActive">active</a> state and <a href="qsqlquery.html#isSelect">isSelect</a>() must return true before
calling this function.</p>
<p>If <i>relative</i> is false (the default), the following rules
apply:</p>
<ul>
<li>If <i>index</i> is negative, the result is positioned before
the first record and false is returned.</li>
<li>Otherwise, an attempt is made to move to the record at position
<i>index</i>. If the record at position <i>index</i> could not be
retrieved, the result is positioned after the last record and false
is returned. If the record is successfully retrieved, true is
returned.</li>
</ul>
<p>If <i>relative</i> is true, the following rules apply:</p>
<ul>
<li>If the result is currently positioned before the first record
or on the first record, and <i>index</i> is negative, there is no
change, and false is returned.</li>
<li>If the result is currently located after the last record, and
<i>index</i> is positive, there is no change, and false is
returned.</li>
<li>If the result is currently located somewhere in the middle, and
the relative offset <i>index</i> moves the result below zero, the
result is positioned before the first record and false is
returned.</li>
<li>Otherwise, an attempt is made to move to the record
<i>index</i> records ahead of the current record (or <i>index</i>
records behind the current record if <i>index</i> is negative). If
the record at offset <i>index</i> could not be retrieved, the
result is positioned after the last record if <i>index</i> &gt;= 0,
(or before the first record if <i>index</i> is negative), and false
is returned. If the record is successfully retrieved, true is
returned.</li>
</ul>
<p><b>See also</b> <a href="qsqlquery.html#next">next</a>(),
<a href="qsqlquery.html#previous">previous</a>(), <a href="qsqlquery.html#first">first</a>(), <a href="qsqlquery.html#last">last</a>(), <a href="qsqlquery.html#at">at</a>(), <a href="qsqlquery.html#isActive">isActive</a>(), and <a href="qsqlquery.html#isValid">isValid</a>().</p>


<h3 class="fn"><a name="setForwardOnly" />QSqlQuery.setForwardOnly (<i>self</i>, bool&#160;<i>forward</i>)</h3><p>Sets forward only mode to <i>forward</i>. If <i>forward</i> is
true, only <a href="qsqlquery.html#next">next</a>() and <a href="qsqlquery.html#seek">seek</a>() with positive values, are allowed
for navigating the results.</p>
<p>Forward only mode can be (depending on the driver) more memory
efficient since results do not need to be cached. It will also
improve performance on some databases. For this to be true, you
must call <tt>setForwardOnly()</tt> before the query is prepared or
executed. Note that the constructor that takes a query and a
database may execute the query.</p>
<p>Forward only mode is off by default.</p>
<p>Setting forward only to false is a suggestion to the database
engine, which has the final say on whether a result set is forward
only or scrollable. <a href="qsqlquery.html#isForwardOnly">isForwardOnly</a>() will always
return the correct status of the result set.</p>
<p><b>Note:</b> Calling setForwardOnly after execution of the query
will result in unexpected results at best, and crashes at
worst.</p>
<p><b>See also</b> <a href="qsqlquery.html#isForwardOnly">isForwardOnly</a>(), <a href="qsqlquery.html#next">next</a>(), <a href="qsqlquery.html#seek">seek</a>(), and <a href="qsqlresult.html#setForwardOnly">QSqlResult.setForwardOnly</a>().</p>


<h3 class="fn"><a name="setNumericalPrecisionPolicy" />QSqlQuery.setNumericalPrecisionPolicy (<i>self</i>, <a href="qsql.html#NumericalPrecisionPolicy-enum">QSql.NumericalPrecisionPolicy</a>&#160;<i>precisionPolicy</i>)</h3><p>Instruct the database driver to return numerical values with a
precision specified by <i>precisionPolicy</i>.</p>
<p>The Oracle driver, for example, can retrieve numerical values as
strings to prevent the loss of precision. If high precision doesn't
matter, use this method to increase execution speed by bypassing
string conversions.</p>
<p>Note: Drivers that don't support fetching numerical values with
low precision will ignore the precision policy. You can use
<a href="qsqldriver.html#hasFeature">QSqlDriver.hasFeature</a>()
to find out whether a driver supports this feature.</p>
<p>Note: Setting the precision policy doesn't affect the currently
active query. Call <a href="qsqlquery.html#exec">exec_</a>(<a href="qstring.html">QString</a>) or <a href="qsqlquery.html#prepare">prepare</a>() in order to activate the
policy.</p>
<p><b>See also</b> <a href="qsql.html#NumericalPrecisionPolicy-enum">QSql.NumericalPrecisionPolicy</a>
and <a href="qsqlquery.html#numericalPrecisionPolicy">numericalPrecisionPolicy</a>().</p>


<h3 class="fn"><a name="size" />int QSqlQuery.size (<i>self</i>)</h3><p>Returns the size of the result (number of rows returned), or -1
if the size cannot be determined or if the database does not
support reporting information about query sizes. Note that for
non-<tt>SELECT</tt> statements (<a href="qsqlquery.html#isSelect">isSelect</a>() returns false), size()
will return -1. If the query is not active (<a href="qsqlquery.html#isActive">isActive</a>() returns false), -1 is
returned.</p>
<p>To determine the number of rows affected by a
non-<tt>SELECT</tt> statement, use <a href="qsqlquery.html#numRowsAffected">numRowsAffected</a>().</p>
<p><b>See also</b> <a href="qsqlquery.html#isActive">isActive</a>(), <a href="qsqlquery.html#numRowsAffected">numRowsAffected</a>(), and
<a href="qsqldriver.html#hasFeature">QSqlDriver.hasFeature</a>().</p>


<h3 class="fn"><a name="value" />QVariant QSqlQuery.value (<i>self</i>, int&#160;<i>i</i>)</h3><p>Returns the value of field <i>index</i> in the current
record.</p>
<p>The fields are numbered from left to right using the text of the
<tt>SELECT</tt> statement, e.g. in</p>
<pre class="cpp">
 SELECT forename<span class="operator">,</span> surname FROM people;
</pre>
<p>field 0 is <tt>forename</tt> and field 1 is <tt>surname</tt>.
Using <tt>SELECT *</tt> is not recommended because the order of the
fields in the query is undefined.</p>
<p>An invalid <a href="qvariant.html">QVariant</a> is returned if
field <i>index</i> does not exist, if the query is inactive, or if
the query is positioned on an invalid record.</p>
<p><b>See also</b> <a href="qsqlquery.html#previous">previous</a>(), <a href="qsqlquery.html#next">next</a>(), <a href="qsqlquery.html#first">first</a>(), <a href="qsqlquery.html#last">last</a>(), <a href="qsqlquery.html#seek">seek</a>(), <a href="qsqlquery.html#isActive">isActive</a>(), and <a href="qsqlquery.html#isValid">isValid</a>().</p>


<address><hr /><div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address"><td align="left" width="25%">PyQt&#160;4.10 for Windows</td><td align="center" width="50%">Copyright &#169; <a href="http://www.riverbankcomputing.com">Riverbank&#160;Computing&#160;Ltd</a> and <a href="http://www.qtsoftware.com">Nokia</a> 2012</td><td align="right" width="25%">Qt&#160;4.8.4</td></tr></table></div></address></body></html>