// qpainter.sip generated by MetaSIP on Fri Mar  1 21:45:59 2013
//
// This file is part of the QtGui Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// If you are unsure which license is appropriate for your use, please
// contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%ModuleCode
#include <qpainter.h>
%End

class QPainter
{
%TypeHeaderCode
#include <qpainter.h>
%End

%TypeCode
// Return an array on the heap of class instances extracted from a set of
// Python arguments.
template<class TYPE>
static TYPE *qtgui_inst_array(const TYPE *first, PyObject *t, sipTypeDef *td)
{
    TYPE *arr = new TYPE[1 + PyTuple_GET_SIZE(t)];

    arr[0] = *first;

    for (SIP_SSIZE_T i = 0; i < PyTuple_GET_SIZE(t); ++i)
    {
        int iserr = 0, state;
        TYPE *itm;

        itm  = reinterpret_cast<TYPE *>(sipForceConvertToType(PyTuple_GET_ITEM(t, i), td, 0, SIP_NOT_NONE, &state, &iserr));

        if (iserr)
        {
            sipReleaseType(itm, td, state);

            PyErr_Format(PyExc_TypeError, "each argument must be an instance of %s", sipTypeAsPyTypeObject(td)->tp_name);

            delete[] arr;
            return 0;
        }

        arr[1 + i] = *itm;

        sipReleaseType(itm, td, state);
    }

    return arr;
}
%End

public:
    enum RenderHint
    {
        Antialiasing,
        TextAntialiasing,
        SmoothPixmapTransform,
%If (Qt_4_3_0 -)
        HighQualityAntialiasing,
%End
%If (Qt_4_4_0 -)
        NonCosmeticDefaultPen,
%End
%If (Qt_5_0_0 -)
        Qt4CompatiblePainting,
%End
    };

    typedef QFlags<QPainter::RenderHint> RenderHints;
    QPainter();
    explicit QPainter(QPaintDevice *);
    ~QPainter();
    SIP_PYOBJECT __enter__();
%MethodCode
        // Check a device was passed.
        if (sipCpp->isActive())
        {
            // Just return a reference to self.
            sipRes = sipSelf;
            Py_INCREF(sipRes);
        }
        else
        {
            PyErr_SetString(PyExc_ValueError, "QPainter must be created with a device");
            sipRes = 0;
        }
%End

    void __exit__(SIP_PYOBJECT type, SIP_PYOBJECT value, SIP_PYOBJECT traceback);
%MethodCode
        sipCpp->end();
%End

    QPaintDevice *device() const;
    bool begin(QPaintDevice *);
    bool end();
    bool isActive() const;
%If (Qt_5_0_0 -)
    void initFrom(const QPaintDevice *device);
%End
%If (- Qt_5_0_0)
    void initFrom(const QWidget *widget);
%End

    enum CompositionMode
    {
        CompositionMode_SourceOver,
        CompositionMode_DestinationOver,
        CompositionMode_Clear,
        CompositionMode_Source,
        CompositionMode_Destination,
        CompositionMode_SourceIn,
        CompositionMode_DestinationIn,
        CompositionMode_SourceOut,
        CompositionMode_DestinationOut,
        CompositionMode_SourceAtop,
        CompositionMode_DestinationAtop,
        CompositionMode_Xor,
%If (Qt_4_3_0 -)
        CompositionMode_Plus,
%End
%If (Qt_4_3_0 -)
        CompositionMode_Multiply,
%End
%If (Qt_4_3_0 -)
        CompositionMode_Screen,
%End
%If (Qt_4_3_0 -)
        CompositionMode_Overlay,
%End
%If (Qt_4_3_0 -)
        CompositionMode_Darken,
%End
%If (Qt_4_3_0 -)
        CompositionMode_Lighten,
%End
%If (Qt_4_3_0 -)
        CompositionMode_ColorDodge,
%End
%If (Qt_4_3_0 -)
        CompositionMode_ColorBurn,
%End
%If (Qt_4_3_0 -)
        CompositionMode_HardLight,
%End
%If (Qt_4_3_0 -)
        CompositionMode_SoftLight,
%End
%If (Qt_4_3_0 -)
        CompositionMode_Difference,
%End
%If (Qt_4_3_0 -)
        CompositionMode_Exclusion,
%End
%If (Qt_4_5_0 -)
        RasterOp_SourceOrDestination,
%End
%If (Qt_4_5_0 -)
        RasterOp_SourceAndDestination,
%End
%If (Qt_4_5_0 -)
        RasterOp_SourceXorDestination,
%End
%If (Qt_4_5_0 -)
        RasterOp_NotSourceAndNotDestination,
%End
%If (Qt_4_5_0 -)
        RasterOp_NotSourceOrNotDestination,
%End
%If (Qt_4_5_0 -)
        RasterOp_NotSourceXorDestination,
%End
%If (Qt_4_5_0 -)
        RasterOp_NotSource,
%End
%If (Qt_4_5_0 -)
        RasterOp_NotSourceAndDestination,
%End
%If (Qt_4_5_0 -)
        RasterOp_SourceAndNotDestination,
%End
%If (Qt_5_0_0 -)
        RasterOp_NotSourceOrDestination,
%End
%If (Qt_5_0_0 -)
        RasterOp_SourceOrNotDestination,
%End
%If (Qt_5_0_0 -)
        RasterOp_ClearDestination,
%End
%If (Qt_5_0_0 -)
        RasterOp_SetDestination,
%End
%If (Qt_5_0_0 -)
        RasterOp_NotDestination,
%End
    };

    void setCompositionMode(QPainter::CompositionMode mode);
    QPainter::CompositionMode compositionMode() const;
    const QFont &font() const;
    void setFont(const QFont &f);
    QFontMetrics fontMetrics() const;
    QFontInfo fontInfo() const;
    void setPen(const QColor &color);
    void setPen(const QPen &pen);
    void setPen(Qt::PenStyle style);
    const QPen &pen() const;
    void setBrush(const QBrush &brush);
    void setBrush(Qt::BrushStyle style);
    const QBrush &brush() const;
    void setBackgroundMode(Qt::BGMode mode);
    Qt::BGMode backgroundMode() const;
    QPoint brushOrigin() const;
    void setBrushOrigin(const QPointF &);
    void setBackground(const QBrush &bg);
    const QBrush &background() const;
    QRegion clipRegion() const;
    QPainterPath clipPath() const;
    void setClipRect(const QRectF &rectangle, Qt::ClipOperation operation = Qt::ReplaceClip);
    void setClipRegion(const QRegion &region, Qt::ClipOperation operation = Qt::ReplaceClip);
    void setClipPath(const QPainterPath &path, Qt::ClipOperation operation = Qt::ReplaceClip);
    void setClipping(bool enable);
    bool hasClipping() const;
    void save();
    void restore();
    void setMatrix(const QMatrix &matrix, bool combine = false);
    const QMatrix &matrix() const;
    const QMatrix &deviceMatrix() const;
    void resetMatrix();
    void setMatrixEnabled(bool enabled);
    bool matrixEnabled() const;
    void scale(qreal sx, qreal sy);
    void shear(qreal sh, qreal sv);
    void rotate(qreal a);
    void translate(const QPointF &offset);
    QRect window() const;
    void setWindow(const QRect &window);
    QRect viewport() const;
    void setViewport(const QRect &viewport);
    void setViewTransformEnabled(bool enable);
    bool viewTransformEnabled() const;
    void strokePath(const QPainterPath &path, const QPen &pen);
    void fillPath(const QPainterPath &path, const QBrush &brush);
    void drawPath(const QPainterPath &path);
    void drawPoints(const QPointF *point, ...);
%MethodCode
        QPointF *points = qtgui_inst_array<QPointF>(a0, a1, sipType_QPointF);
        
        if (points)
        {
            sipCpp->drawPoints(points, 1 + PyTuple_GET_SIZE(a1));
            delete[] points;
        }
        else
            sipIsErr = 1;
%End

    void drawPoints(const QPolygonF &points);
    void drawPoints(const QPoint *point, ...);
%MethodCode
        QPoint *points = qtgui_inst_array<QPoint>(a0, a1, sipType_QPoint);
        
        if (points)
        {
            sipCpp->drawPoints(points, 1 + PyTuple_GET_SIZE(a1));
            delete[] points;
        }
        else
            sipIsErr = 1;
%End

    void drawPoints(const QPolygon &points);
    void drawLines(const QLineF *line, ...);
%MethodCode
        QLineF *lines = qtgui_inst_array<QLineF>(a0, a1, sipType_QLineF);
        
        if (lines)
        {
            sipCpp->drawLines(lines, 1 + PyTuple_GET_SIZE(a1));
            delete[] lines;
        }
        else
            sipIsErr = 1;
%End

    void drawLines(const QVector<QLineF> &lines);
    void drawLines(const QPointF *pointPair, ...);
%MethodCode
        QPointF *pairs = qtgui_inst_array<QPointF>(a0, a1, sipType_QPointF);
        
        if (pairs)
        {
            sipCpp->drawLines(pairs, (1 + PyTuple_GET_SIZE(a1)) / 2);
            delete[] pairs;
        }
        else
            sipIsErr = 1;
%End

    void drawLines(const QVector<QPointF> &pointPairs);
    void drawLines(const QLine *line, ...);
%MethodCode
        QLine *lines = qtgui_inst_array<QLine>(a0, a1, sipType_QLine);
        
        if (lines)
        {
            sipCpp->drawLines(lines, 1 + PyTuple_GET_SIZE(a1));
            delete[] lines;
        }
        else
            sipIsErr = 1;
%End

    void drawLines(const QVector<QLine> &lines);
    void drawLines(const QPoint *pointPair, ...);
%MethodCode
        QPoint *pairs = qtgui_inst_array<QPoint>(a0, a1, sipType_QPoint);
        
        if (pairs)
        {
            sipCpp->drawLines(pairs, (1 + PyTuple_GET_SIZE(a1)) / 2);
            delete[] pairs;
        }
        else
            sipIsErr = 1;
%End

    void drawLines(const QVector<QPoint> &pointPairs);
    void drawRects(const QRectF *rect, ...);
%MethodCode
        QRectF *rects = qtgui_inst_array<QRectF>(a0, a1, sipType_QRectF);
        
        if (rects)
        {
            sipCpp->drawRects(rects, 1 + PyTuple_GET_SIZE(a1));
            delete[] rects;
        }
        else
            sipIsErr = 1;
%End

    void drawRects(const QVector<QRectF> &rects);
    void drawRects(const QRect *rect, ...);
%MethodCode
        QRect *rects = qtgui_inst_array<QRect>(a0, a1, sipType_QRect);
        
        if (rects)
        {
            sipCpp->drawRects(rects, 1 + PyTuple_GET_SIZE(a1));
            delete[] rects;
        }
        else
            sipIsErr = 1;
%End

    void drawRects(const QVector<QRect> &rects);
    void drawEllipse(const QRectF &r);
    void drawEllipse(const QRect &r);
    void drawPolyline(const QPointF *point, ...);
%MethodCode
        QPointF *points = qtgui_inst_array<QPointF>(a0, a1, sipType_QPointF);
        
        if (points)
        {
            sipCpp->drawPolyline(points, 1 + PyTuple_GET_SIZE(a1));
            delete[] points;
        }
        else
            sipIsErr = 1;
%End

    void drawPolyline(const QPolygonF &polyline);
    void drawPolyline(const QPoint *point, ...);
%MethodCode
        QPoint *points = qtgui_inst_array<QPoint>(a0, a1, sipType_QPoint);
        
        if (points)
        {
            sipCpp->drawPolyline(points, 1 + PyTuple_GET_SIZE(a1));
            delete[] points;
        }
        else
            sipIsErr = 1;
%End

    void drawPolyline(const QPolygon &polyline);
    void drawPolygon(const QPointF *point, ...);
%MethodCode
        QPointF *points = qtgui_inst_array<QPointF>(a0, a1, sipType_QPointF);
        
        if (points)
        {
            sipCpp->drawPolygon(points, 1 + PyTuple_GET_SIZE(a1));
            delete[] points;
        }
        else
            sipIsErr = 1;
%End

    void drawPolygon(const QPolygonF &points, Qt::FillRule fillRule = Qt::OddEvenFill);
    void drawPolygon(const QPoint *point, ...);
%MethodCode
        QPoint *points = qtgui_inst_array<QPoint>(a0, a1, sipType_QPoint);
        
        if (points)
        {
            sipCpp->drawPolygon(points, 1 + PyTuple_GET_SIZE(a1));
            delete[] points;
        }
        else
            sipIsErr = 1;
%End

    void drawPolygon(const QPolygon &points, Qt::FillRule fillRule = Qt::OddEvenFill);
    void drawConvexPolygon(const QPointF *point, ...);
%MethodCode
        QPointF *points = qtgui_inst_array<QPointF>(a0, a1, sipType_QPointF);
        
        if (points)
        {
            sipCpp->drawConvexPolygon(points, 1 + PyTuple_GET_SIZE(a1));
            delete[] points;
        }
        else
            sipIsErr = 1;
%End

    void drawConvexPolygon(const QPolygonF &poly);
    void drawConvexPolygon(const QPoint *point, ...);
%MethodCode
        QPoint *points = qtgui_inst_array<QPoint>(a0, a1, sipType_QPoint);
        
        if (points)
        {
            sipCpp->drawConvexPolygon(points, 1 + PyTuple_GET_SIZE(a1));
            delete[] points;
        }
        else
            sipIsErr = 1;
%End

    void drawConvexPolygon(const QPolygon &poly);
    void drawArc(const QRectF &rect, int a, int alen);
    void drawPie(const QRectF &rect, int a, int alen);
    void drawChord(const QRectF &rect, int a, int alen);
    void drawRoundRect(const QRectF &r, int xRound = 25, int yRound = 25);
    void drawTiledPixmap(const QRectF &rectangle, const QPixmap &pixmap, const QPointF &pos = QPointF());
    void drawPicture(const QPointF &p, const QPicture &picture);
    void drawPixmap(const QRectF &targetRect, const QPixmap &pixmap, const QRectF &sourceRect);
    void setLayoutDirection(Qt::LayoutDirection direction);
    Qt::LayoutDirection layoutDirection() const;
    void drawText(const QPointF &p, const QString &s);
    void drawText(const QRectF &rectangle, int flags, const QString &text, QRectF *boundingRect /Out/ = 0);
    void drawText(const QRect &rectangle, int flags, const QString &text, QRect *boundingRect /Out/ = 0);
    void drawText(const QRectF &rectangle, const QString &text, const QTextOption &option = QTextOption());
    QRectF boundingRect(const QRectF &rect, int flags, const QString &text);
    QRect boundingRect(const QRect &rect, int flags, const QString &text);
    QRectF boundingRect(const QRectF &rectangle, const QString &text, const QTextOption &option = QTextOption());
    void fillRect(const QRectF &, const QBrush &);
    void fillRect(const QRect &, const QBrush &);
    void eraseRect(const QRectF &);
    void setRenderHint(QPainter::RenderHint hint, bool on = true);
    QFlags<QPainter::RenderHint> renderHints() const;
%If (Qt_4_2_0 -)
    void setRenderHints(QFlags<QPainter::RenderHint> hints, bool on = true);
%End
    QPaintEngine *paintEngine() const;
    static void setRedirected(const QPaintDevice *device, QPaintDevice *replacement, const QPoint &offset = QPoint());
    static QPaintDevice *redirected(const QPaintDevice *device, QPoint *offset = 0);
    static void restoreRedirected(const QPaintDevice *device);
    void drawLine(const QLineF &l);
    void drawLine(const QLine &line);
    void drawLine(int x1, int y1, int x2, int y2);
    void drawLine(const QPoint &p1, const QPoint &p2);
    void drawLine(const QPointF &p1, const QPointF &p2);
    void drawRect(const QRectF &rect);
    void drawRect(int x, int y, int w, int h);
    void drawRect(const QRect &r);
    void drawPoint(const QPointF &p);
    void drawPoint(int x, int y);
    void drawPoint(const QPoint &p);
    void drawRoundRect(int x, int y, int w, int h, int xRound = 25, int yRound = 25);
    void drawRoundRect(const QRect &r, int xRound = 25, int yRound = 25);
    void drawEllipse(int x, int y, int w, int h);
    void drawArc(const QRect &r, int a, int alen);
    void drawArc(int x, int y, int w, int h, int a, int alen);
    void drawPie(const QRect &rect, int a, int alen);
    void drawPie(int x, int y, int w, int h, int a, int alen);
    void drawChord(const QRect &rect, int a, int alen);
    void drawChord(int x, int y, int w, int h, int a, int alen);
    void setClipRect(int x, int y, int width, int height, Qt::ClipOperation operation = Qt::ReplaceClip);
    void setClipRect(const QRect &rectangle, Qt::ClipOperation operation = Qt::ReplaceClip);
    void eraseRect(const QRect &rect);
    void eraseRect(int x, int y, int w, int h);
    void fillRect(int x, int y, int w, int h, const QBrush &b);
    void setBrushOrigin(int x, int y);
    void setBrushOrigin(const QPoint &p);
    void drawTiledPixmap(const QRect &rectangle, const QPixmap &pixmap, const QPoint &pos = QPoint());
    void drawTiledPixmap(int x, int y, int width, int height, const QPixmap &pixmap, int sx = 0, int sy = 0);
    void drawPixmap(const QRect &targetRect, const QPixmap &pixmap, const QRect &sourceRect);
    void drawPixmap(const QPointF &p, const QPixmap &pm);
    void drawPixmap(const QPoint &p, const QPixmap &pm);
    void drawPixmap(const QRect &r, const QPixmap &pm);
    void drawPixmap(int x, int y, const QPixmap &pm);
    void drawPixmap(int x, int y, int w, int h, const QPixmap &pm);
    void drawPixmap(int x, int y, int w, int h, const QPixmap &pm, int sx, int sy, int sw, int sh);
    void drawPixmap(int x, int y, const QPixmap &pm, int sx, int sy, int sw, int sh);
    void drawPixmap(const QPointF &p, const QPixmap &pm, const QRectF &sr);
    void drawPixmap(const QPoint &p, const QPixmap &pm, const QRect &sr);
    void drawImage(const QRectF &targetRect, const QImage &image, const QRectF &sourceRect, Qt::ImageConversionFlags flags = Qt::AutoColor);
    void drawImage(const QRect &targetRect, const QImage &image, const QRect &sourceRect, Qt::ImageConversionFlags flags = Qt::AutoColor);
    void drawImage(const QPointF &p, const QImage &image, const QRectF &sr, Qt::ImageConversionFlags flags = Qt::AutoColor);
    void drawImage(const QPoint &p, const QImage &image, const QRect &sr, Qt::ImageConversionFlags flags = Qt::AutoColor);
    void drawImage(const QRectF &r, const QImage &image);
    void drawImage(const QRect &r, const QImage &image);
    void drawImage(const QPointF &p, const QImage &image);
    void drawImage(const QPoint &p, const QImage &image);
    void drawImage(int x, int y, const QImage &image, int sx = 0, int sy = 0, int sw = -1, int sh = -1, Qt::ImageConversionFlags flags = Qt::AutoColor);
    void drawText(const QPoint &p, const QString &s);
    void drawText(int x, int y, int width, int height, int flags, const QString &text, QRect *boundingRect /Out/ = 0);
    void drawText(int x, int y, const QString &s);
    QRect boundingRect(int x, int y, int w, int h, int flags, const QString &text);
%If (Qt_4_2_0 -)
    QMatrix combinedMatrix() const;
%End
%If (Qt_4_2_0 -)
    qreal opacity() const;
%End
%If (Qt_4_2_0 -)
    void setOpacity(qreal opacity);
%End
    void translate(qreal dx, qreal dy);
    void translate(const QPoint &offset);
    void setViewport(int x, int y, int w, int h);
    void setWindow(int x, int y, int w, int h);
%If (Qt_4_2_0 -)
    const QMatrix &worldMatrix() const;
%End
%If (Qt_4_2_0 -)
    void setWorldMatrix(const QMatrix &matrix, bool combine = false);
%End
%If (Qt_4_2_0 -)
    bool worldMatrixEnabled() const;
%End
%If (Qt_4_2_0 -)
    void setWorldMatrixEnabled(bool enabled);
%End
    void drawPicture(int x, int y, const QPicture &p);
    void drawPicture(const QPoint &pt, const QPicture &p);
%If (Qt_4_3_0 -)
    void setTransform(const QTransform &transform, bool combine = false);
%End
%If (Qt_4_3_0 -)
    const QTransform &transform() const;
%End
%If (Qt_4_3_0 -)
    const QTransform &deviceTransform() const;
%End
%If (Qt_4_3_0 -)
    void resetTransform();
%End
%If (Qt_4_3_0 -)
    void setWorldTransform(const QTransform &matrix, bool combine = false);
%End
%If (Qt_4_3_0 -)
    const QTransform &worldTransform() const;
%End
%If (Qt_4_3_0 -)
    QTransform combinedTransform() const;
%End
%If (Qt_4_3_0 -)
    bool testRenderHint(QPainter::RenderHint hint) const;
%End
%If (Qt_4_4_0 -)
    void drawRoundedRect(const QRectF &rect, qreal xRadius, qreal yRadius, Qt::SizeMode mode = Qt::AbsoluteSize);
%End
%If (Qt_4_4_0 -)
    void drawRoundedRect(int x, int y, int w, int h, qreal xRadius, qreal yRadius, Qt::SizeMode mode = Qt::AbsoluteSize);
%End
%If (Qt_4_4_0 -)
    void drawRoundedRect(const QRect &rect, qreal xRadius, qreal yRadius, Qt::SizeMode mode = Qt::AbsoluteSize);
%End
%If (Qt_4_4_0 -)
    void drawEllipse(const QPointF &center, qreal rx, qreal ry);
%End
%If (Qt_4_4_0 -)
    void drawEllipse(const QPoint &center, int rx, int ry);
%End
%If (Qt_4_5_0 -)
    void fillRect(const QRectF &, const QColor &color);
%End
%If (Qt_4_5_0 -)
    void fillRect(const QRect &, const QColor &color);
%End
%If (Qt_4_5_0 -)
    void fillRect(int x, int y, int w, int h, const QColor &b);
%End
%If (Qt_4_5_0 -)
    void fillRect(int x, int y, int w, int h, Qt::GlobalColor c);
%End
%If (Qt_4_5_0 -)
    void fillRect(const QRect &r, Qt::GlobalColor c);
%End
%If (Qt_4_5_0 -)
    void fillRect(const QRectF &r, Qt::GlobalColor c);
%End
%If (Qt_4_5_0 -)
    void fillRect(int x, int y, int w, int h, Qt::BrushStyle style);
%End
%If (Qt_4_5_0 -)
    void fillRect(const QRect &r, Qt::BrushStyle style);
%End
%If (Qt_4_5_0 -)
    void fillRect(const QRectF &r, Qt::BrushStyle style);
%End
%If (Qt_4_6_0 -)
    void beginNativePainting();
%End
%If (Qt_4_6_0 -)
    void endNativePainting();
%End
%If (Qt_4_7_0 -)

    class PixmapFragment
    {
%TypeHeaderCode
#include <qpainter.h>
%End

    public:
        qreal x;
        qreal y;
        qreal sourceLeft;
        qreal sourceTop;
        qreal width;
        qreal height;
        qreal scaleX;
        qreal scaleY;
        qreal rotation;
        qreal opacity;
        static QPainter::PixmapFragment create(const QPointF &pos, const QRectF &sourceRect, qreal scaleX = 1, qreal scaleY = 1, qreal rotation = 0, qreal opacity = 1) /Factory/;
    };

%End
%If (Qt_4_7_0 -)

    enum PixmapFragmentHint
    {
        OpaqueHint,
    };

%End
%If (Qt_4_7_0 -)
    typedef QFlags<QPainter::PixmapFragmentHint> PixmapFragmentHints;
%End
%If (Qt_4_7_0 -)
    void drawPixmapFragments(SIP_PYLIST fragments /DocType="list-of-QPainter.PixmapFragment"/, const QPixmap &pixmap, QFlags<QPainter::PixmapFragmentHint> hints = 0);
%MethodCode
        // Allocate temporary storage for the C++ conversions.
        SIP_SSIZE_T numFragments = PyList_GET_SIZE(a0);
        QPainter::PixmapFragment *fragments = new QPainter::PixmapFragment[numFragments];
        
        // Convert the fragments.
        for (SIP_SSIZE_T i = 0; i < numFragments; ++i)
        {
            void *cpp = sipForceConvertToType(PyList_GET_ITEM(a0, i), sipType_QPainter_PixmapFragment, NULL, SIP_NO_CONVERTORS, NULL, &sipIsErr);
        
            fragments[i] = *reinterpret_cast<QPainter::PixmapFragment *>(cpp);
        }
        
        if (!sipIsErr)
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->drawPixmapFragments(fragments, numFragments, *a1, *a2);
            Py_END_ALLOW_THREADS
        }
        
        delete[] fragments;
%End

%End
%If (Qt_4_8_0 - Qt_5_0_0)
    void drawPixmapFragments(SIP_PYLIST targetRects /DocType="list-of-QRectF"/, SIP_PYLIST sourceRects /AllowNone, DocType="list-of-QRectF"/, const QPixmap &pixmap, QFlags<QPainter::PixmapFragmentHint> hints = 0);
%MethodCode
        // Allocate temporary storage for the C++ conversions.
        QRectF *target, *source;
        SIP_SSIZE_T numFragments = PyList_GET_SIZE(a0);
        
        if (a1)
        {
            if (PyList_GET_SIZE(a1) < numFragments)
                numFragments = PyList_GET_SIZE(a1);
        
            source = new QRectF[numFragments];
        }
        else
        {
            source = 0;
        }
        
        target = new QRectF[numFragments];
        
        // Convert the target and source.
        for (SIP_SSIZE_T i = 0; i < numFragments; ++i)
        {
            void *cpp;
        
            cpp = sipForceConvertToType(PyList_GET_ITEM(a0, i), sipType_QRectF, NULL, SIP_NO_CONVERTORS, NULL, &sipIsErr);
                
            target[i] = *reinterpret_cast<QRectF *>(cpp);
        
            if (source)
            {
                cpp = sipForceConvertToType(PyList_GET_ITEM(a1, i), sipType_QRectF, NULL, SIP_NO_CONVERTORS, NULL, &sipIsErr);
                
                source[i] = *reinterpret_cast<QRectF *>(cpp);
            }
        }
                
        if (!sipIsErr)
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->drawPixmapFragments(target, source, numFragments, *a2, *a3);
            Py_END_ALLOW_THREADS
        }
                
        delete[] target;
        
        if (source)
            delete[] source;
%End

%End
%If (Qt_4_7_0 -)
    void drawStaticText(const QPointF &topLeftPosition, const QStaticText &staticText);
%End
%If (Qt_4_7_0 -)
    void drawStaticText(const QPoint &p, const QStaticText &staticText);
%End
%If (Qt_4_7_0 -)
    void drawStaticText(int x, int y, const QStaticText &staticText);
%End
%If (Qt_4_8_0 -)
    QRectF clipBoundingRect() const;
%End
%If (Qt_4_8_0 -)
%If (PyQt_RawFont)
    void drawGlyphRun(const QPointF &position, const QGlyphRun &glyphRun);
%End
%End

private:
%If (Qt_4_2_0 -)
    QPainter(const QPainter &);
%End
};

QFlags<QPainter::RenderHint> operator|(QPainter::RenderHint f1, QFlags<QPainter::RenderHint> f2);
