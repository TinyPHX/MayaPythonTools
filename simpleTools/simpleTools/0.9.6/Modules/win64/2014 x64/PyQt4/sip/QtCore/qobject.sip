// qobject.sip generated by MetaSIP on Fri Mar  1 21:45:57 2013
//
// This file is part of the QtCore Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// If you are unsure which license is appropriate for your use, please
// contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


class QWidget /External/;
typedef QList<QObject*> QObjectList;

class QObject /Supertype=sip.wrapper/
{
%TypeHeaderCode
#include <qobject.h>
%End

%TypeCode
// This is needed by the tr() and trUt8() handwritten implementations.
#include <qcoreapplication.h>


// These are the helper functions for QObject::findChild() and
// QObject::findChildren.

// Wrap the given type in a 1-tuple.
static PyObject *qtcore_type_to_tuple(PyObject *type)
{
    PyObject *tuple = PyTuple_New(1);

    if (tuple)
    {
        Py_INCREF(type);
        PyTuple_SET_ITEM(tuple, 0, type);
    }

    return tuple;
}


// Check all elements of a given tuple are type objects and return a new
// reference to the tuple if so.
static PyObject *qtcore_check_tuple_types(PyObject *types)
{
    for (SIP_SSIZE_T i = 0; i < PyTuple_GET_SIZE(types); ++i)
        if (!PyObject_TypeCheck(PyTuple_GET_ITEM(types, i), &PyType_Type))
        {
            PyErr_SetString(PyExc_TypeError,
                    "all elements of the types argument must be type objects");
            return 0;
        }

    Py_INCREF(types);
    return types;
}


// Do the main work of finding a child.
static PyObject *qtcore_do_find_child(const QObject *parent, PyObject *types, const QString &name)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);
        PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);

        if (!pyo)
            return 0;

        if (name.isNull() || obj->objectName() == name)
            for (SIP_SSIZE_T t = 0; t < PyTuple_GET_SIZE(types); ++t)
                if (PyType_IsSubtype(Py_TYPE(pyo), (PyTypeObject *)PyTuple_GET_ITEM(types, t)))
                    return pyo;

        Py_DECREF(pyo);
    }

    for (i = 0; i < children.size(); ++i)
    {
        PyObject *pyo = qtcore_do_find_child(children.at(i), types, name);

        if (pyo != Py_None)
            return pyo;

        Py_DECREF(pyo);
    }

    Py_INCREF(Py_None);
    return Py_None;
}


// Find a child that is one of a number of types and with an optional name.
static PyObject *qtcore_FindChild(const QObject *parent, PyObject *types, const QString &name)
{
    // Check that the types checking was successful.
    if (!types)
        return 0;

    PyObject *child = qtcore_do_find_child(parent, types, name);

    Py_DECREF(types);

    return child;
}


// Do the main work of finding the children with a string name.
static bool qtcore_do_find_children(const QObject *parent, PyObject *types, const QString &name, PyObject *list)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);
        PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);

        if (!pyo)
            return false;

        if (name.isNull() || obj->objectName() == name)
            for (SIP_SSIZE_T t = 0; t < PyTuple_GET_SIZE(types); ++t)
                if (PyType_IsSubtype(Py_TYPE(pyo), (PyTypeObject *)PyTuple_GET_ITEM(types, t)))
                    if (PyList_Append(list, pyo) < 0)
                    {
                        Py_DECREF(pyo);
                        return false;
                    }

        Py_DECREF(pyo);

        bool ok = qtcore_do_find_children(obj, types, name, list);

        if (!ok)
            return false;
    }

    return true;
}


// Find a child that is one of a number of types and with an optional string
// name.
static PyObject *qtcore_FindChildren(const QObject *parent, PyObject *types, const QString &name)
{
    // Check that the types checking was successful.
    if (!types)
        return 0;

    PyObject *list = PyList_New(0);

    if (list)
        if (!qtcore_do_find_children(parent, types, name, list))
            Py_DECREF(list);

    Py_DECREF(types);

    return list;
}


// Do the main work of finding the children with a regular expression name.
static bool qtcore_do_find_children(const QObject *parent, PyObject *types, const QRegExp &re, PyObject *list)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);
        PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);

        if (!pyo)
            return false;

        if (re.indexIn(obj->objectName()) >= 0)
            for (SIP_SSIZE_T t = 0; t < PyTuple_GET_SIZE(types); ++t)
                if (PyType_IsSubtype(Py_TYPE(pyo), (PyTypeObject *)PyTuple_GET_ITEM(types, t)))
                    if (PyList_Append(list, pyo) < 0)
                    {
                        Py_DECREF(pyo);
                        return false;
                    }

        Py_DECREF(pyo);

        bool ok = qtcore_do_find_children(obj, types, re, list);

        if (!ok)
            return false;
    }

    return true;
}


// Find a child that is one of a number of types and with an optional regular
// expression name.
static PyObject *qtcore_FindChildren(const QObject *parent, PyObject *types, const QRegExp &re)
{
    // Check that the types checking was successful.
    if (!types)
        return 0;

    PyObject *list = PyList_New(0);

    if (list)
        if (!qtcore_do_find_children(parent, types, re, list))
            Py_DECREF(list);

    Py_DECREF(types);

    return list;
}
%End

%ConvertToSubClassCode
    static struct class_graph {
        const char *name;
        sipTypeDef **type;
        int yes, no;
    } graph[] = {
    #if QT_VERSION >= 0x040400
        {sipName_QSharedMemory, &sipType_QSharedMemory, -1, 1},
    #else
        {0, 0, -1, 1},
    #endif
        {sipName_QObjectCleanupHandler, &sipType_QObjectCleanupHandler, -1, 2},
        {sipName_QMimeData, &sipType_QMimeData, -1, 3},
        {sipName_QSettings, &sipType_QSettings, -1, 4},
        {sipName_QAbstractEventDispatcher, &sipType_QAbstractEventDispatcher, -1, 5},
    #if QT_VERSION >= 0x040400
        {sipName_QThreadPool, &sipType_QThreadPool, -1, 6},
    #else
        {0, 0, -1, 6},
    #endif
        {sipName_QSocketNotifier, &sipType_QSocketNotifier, -1, 7},
        {sipName_QTimer, &sipType_QTimer, -1, 8},
        {sipName_QPluginLoader, &sipType_QPluginLoader, -1, 9},
        {sipName_QSignalMapper, &sipType_QSignalMapper, -1, 10},
    #if QT_VERSION >= 0x040600
        {sipName_QAbstractState, &sipType_QAbstractState, 22, 11},
    #else
        {0, 0, 22, 11},
    #endif
        {sipName_QIODevice, &sipType_QIODevice, 26, 12},
        {sipName_QTranslator, &sipType_QTranslator, -1, 13},
    #if QT_VERSION >= 0x040600
        {sipName_QAbstractTransition, &sipType_QAbstractTransition, 30, 14},
    #else
        {0, 0, 30, 14},
    #endif
        {sipName_QCoreApplication, &sipType_QCoreApplication, -1, 15},
    #if QT_VERSION >= 0x040200
        {sipName_QTimeLine, &sipType_QTimeLine, -1, 16},
    #else
        {0, 0, -1, 16},
    #endif
        {sipName_QAbstractItemModel, &sipType_QAbstractItemModel, 32, 17},
    #if QT_VERSION >= 0x040600
        {sipName_QAbstractAnimation, &sipType_QAbstractAnimation, 34, 18},
    #else
        {0, 0, 34, 18},
    #endif
        {sipName_QEventLoop, &sipType_QEventLoop, -1, 19},
    #if QT_VERSION >= 0x040200
        {sipName_QFileSystemWatcher, &sipType_QFileSystemWatcher, -1, 20},
    #else
        {0, 0, -1, 20},
    #endif
        {sipName_QLibrary, &sipType_QLibrary, -1, 21},
        {sipName_QThread, &sipType_QThread, -1, -1},
    #if QT_VERSION >= 0x040600
        {sipName_QState, &sipType_QState, 25, 23},
        {sipName_QFinalState, &sipType_QFinalState, -1, 24},
        {sipName_QHistoryState, &sipType_QHistoryState, -1, -1},
        {sipName_QStateMachine, &sipType_QStateMachine, -1, -1},
    #else
        {0, 0, 25, 23},
        {0, 0, -1, 24},
        {0, 0, -1, -1},
        {0, 0, -1, -1},
    #endif
        {sipName_QBuffer, &sipType_QBuffer, -1, 27},
        {sipName_QFile, &sipType_QFile, 29, 28},
        {sipName_QProcess, &sipType_QProcess, -1, -1},
        {sipName_QTemporaryFile, &sipType_QTemporaryFile, -1, -1},
    #if QT_VERSION >= 0x040600
        {sipName_QEventTransition, &sipType_QEventTransition, -1, 31},
        {sipName_QSignalTransition, &sipType_QSignalTransition, -1, -1},
    #else
        {0, 0, -1, 31},
        {0, 0, -1, -1},
    #endif
        {sipName_QAbstractListModel, &sipType_QAbstractListModel, -1, 33},
        {sipName_QAbstractTableModel, &sipType_QAbstractTableModel, -1, -1},
    #if QT_VERSION >= 0x040600
        {sipName_QAnimationGroup, &sipType_QAnimationGroup, 37, 35},
        {sipName_QVariantAnimation, &sipType_QVariantAnimation, 39, 36},
        {sipName_QPauseAnimation, &sipType_QPauseAnimation, -1, -1},
        {sipName_QSequentialAnimationGroup, &sipType_QSequentialAnimationGroup, -1, 38},
        {sipName_QParallelAnimationGroup, &sipType_QParallelAnimationGroup, -1, -1},
        {sipName_QPropertyAnimation, &sipType_QPropertyAnimation, -1, -1},
    #else
        {0, 0, 37, 35},
        {0, 0, 39, 36},
        {0, 0, -1, -1},
        {0, 0, -1, 38},
        {0, 0, -1, -1},
        {0, 0, -1, -1},
    #endif
    };
    
    int i = 0;
    
    sipType = 0;
    
    do
    {
        struct class_graph *cg = &graph[i];
    
        if (cg->name != NULL && sipCpp->inherits(cg->name))
        {
            sipType = *cg->type;
            i = cg->yes;
        }
        else
            i = cg->no;
    }
    while (i >= 0);
%End

public:
    static const QMetaObject staticMetaObject {
%GetCode
        sipPy = qpycore_qobject_staticmetaobject(sipPyType);
%End

    };
    const QMetaObject *metaObject() const;
    explicit QObject(QObject *parent /TransferThis/ = 0);
    virtual ~QObject();
    void pyqtConfigure(SIP_PYOBJECT) /NoArgParser/;
%Docstring
QObject.pyqtConfigure(...)

Each keyword argument is either the name of a Qt property or a Qt signal.
For properties the property is set to the given value which should be of an
appropriate type.
For signals the signal is connected to the given value which should be a
callable.
%End

%MethodCode
        // Check there are no positional arguments.
        if (PyTuple_Size(sipArgs) > 0)
        {
            PyErr_SetString(PyExc_TypeError, "QObject.pyqtConfigure() has no positional arguments");
            return 0;
        }
        
        // Get the QObject self.
        void *qobj = sipGetCppPtr((sipSimpleWrapper *)sipSelf, sipType_QObject);
        
        if (!qobj)
            return 0;
        
        // Configure it and raise an exception if any aren't known.
        if (qpycore_pyqtconfigure(sipSelf, reinterpret_cast<QObject *>(qobj), sipKwds) < 0)
            return 0;
        
        Py_INCREF(Py_None);
        return Py_None;
%End

    SIP_PYOBJECT __getattr__(const char *name) const;
%MethodCode
        // PyQt5: Fix the const cast.
        sipRes = qpycore_qobject_getattr(const_cast<QObject *>(sipCpp), sipSelf, a0);
%End

    virtual bool event(QEvent *);
    virtual bool eventFilter(QObject *, QEvent *);
%If (Qt_5_0_0 -)
    QString tr(const char *sourceText, const char *disambiguation = 0, int n = -1) const;
%MethodCode
        // Note that tr() is really a static method.  We pretend it isn't so we can use
        // self to get hold of the class name.
        
        sipRes = new QString(QCoreApplication::translate(Py_TYPE(sipSelf)->tp_name, a0, a1, a2));
%End

%End
%If (Qt_4_2_0 - Qt_5_0_0)
    QString tr(SIP_PYOBJECT sourceText /DocType="str"/, const char *disambiguation = 0, int n = -1) const;
%MethodCode
        // Note that tr() is really a static method.  We pretend it isn't so we can use
        // self to get hold of the class name.
        
        const char *source = qpycore_encode(&a0, QCoreApplication::CodecForTr);
        
        if (source)
        {
            sipRes = new QString(QCoreApplication::translate(Py_TYPE(sipSelf)->tp_name,
                    source, a1, QCoreApplication::CodecForTr, a2));
            Py_DECREF(a0);
        }
        else
        {
            sipIsErr = 1;
        }
%End

%End
%If (- Qt_4_2_0)
    QString tr(SIP_PYOBJECT sourceText /DocType="str"/, const char *disambiguation = 0) const;
%MethodCode
        // Note that tr() is really a static method.  We pretend it isn't so we can use
        // self to get hold of the class name.
        
        if (QCoreApplication::instance())
        {
            const char *source = qpycore_encode(&a0, QCoreApplication::DefaultCodec);
        
            if (source)
            {
                sipRes = new QString(QCoreApplication::instance()->translate(Py_TYPE(sipSelf)->tp_name, source, a1, QCoreApplication::DefaultCodec));
                Py_DECREF(a0);
            }
            else
            {
                sipIsErr = 1;
            }
        }
        else
        {
            const char *source = sipString_AsLatin1String(&a0);
        
            if (source)
            {
                sipRes = new QString(QString::fromLatin1(source));
                Py_DECREF(a0);
            }
            else
            {
                sipIsErr = 1;
            }
        }
%End

%End
%If (Qt_4_2_0 -)
%If (PyQt_Deprecated_5_0)
    QString trUtf8(SIP_PYOBJECT sourceText /DocType="str"/, const char *disambiguation = 0, int n = -1) const;
%MethodCode
        // Note that trUtf8() is really a static method.  We pretend it isn't aren't so
        // we can use self to get hold of the class name.
        
        const char *source = qpycore_encode(&a0, QCoreApplication::UnicodeUTF8);
        
        if (source)
        {
            sipRes = new QString(QCoreApplication::translate(Py_TYPE(sipSelf)->tp_name,
                    source, a1, QCoreApplication::UnicodeUTF8, a2));
            Py_DECREF(a0);
        }
        else
        {
            sipIsErr = 1;
        }
%End

%End
%End
%If (- Qt_4_2_0)
    QString trUtf8(SIP_PYOBJECT sourceText /DocType="str"/, const char *disambiguation = 0) const;
%MethodCode
        // Note that trUtf8() is really a static method.  We pretend it isn't aren't so
        // we can use self to get hold of the class name.
        
        if (QCoreApplication::instance())
        {
            const char *source = qpycore_encode(&a0, QCoreApplication::UnicodeUTF8);
        
            if (source)
            {
                sipRes = new QString(QCoreApplication::instance()->translate(Py_TYPE(sipSelf)->tp_name, source, a1, QCoreApplication::UnicodeUTF8));
                Py_DECREF(a0);
            }
            else
            {
                sipIsErr = 1;
            }
        }
        else
        {
            const char *source = sipString_AsUTF8String(&a0);
        
            if (source)
            {
                sipRes = new QString(QString::fromUtf8(source));
                Py_DECREF(a0);
            }
            else
            {
                sipIsErr = 1;
            }
        }
%End

%End
    SIP_PYOBJECT findChild(SIP_PYTYPE type, const QString &name /DocValue="Py_v3:''"/ = QString()) const /DocType="QObject"/;
%MethodCode
        sipRes = qtcore_FindChild(sipCpp, qtcore_type_to_tuple(a0), *a1);
        
        if (!sipRes)
            sipIsErr = 1;
%End

    SIP_PYOBJECT findChild(SIP_PYTUPLE types /DocValue="tuple-of-types"/, const QString &name /DocValue="Py_v3:''"/ = QString()) const /DocType="QObject"/;
%MethodCode
        sipRes = qtcore_FindChild(sipCpp, qtcore_check_tuple_types(a0), *a1);
        
        if (!sipRes)
            sipIsErr = 1;
%End

    SIP_PYLIST findChildren(SIP_PYTYPE type, const QString &name /DocValue="Py_v3:''"/ = QString()) const /DocType="list-of-QObject"/;
%MethodCode
        sipRes = qtcore_FindChildren(sipCpp, qtcore_type_to_tuple(a0), *a1);
        
        if (!sipRes)
            sipIsErr = 1;
%End

    SIP_PYLIST findChildren(SIP_PYTUPLE types /DocValue="tuple-of-types"/, const QString &name /DocValue="Py_v3:''"/ = QString()) const /DocType="list-of-QObject"/;
%MethodCode
        sipRes = qtcore_FindChildren(sipCpp, qtcore_check_tuple_types(a0), *a1);
        
        if (!sipRes)
            sipIsErr = 1;
%End

    SIP_PYLIST findChildren(SIP_PYTYPE type, const QRegExp &regExp) const /DocType="list-of-QObject"/;
%MethodCode
        sipRes = qtcore_FindChildren(sipCpp, qtcore_type_to_tuple(a0), *a1);
        
        if (!sipRes)
            sipIsErr = 1;
%End

    SIP_PYLIST findChildren(SIP_PYTUPLE types /DocValue="tuple-of-types"/, const QRegExp &regExp) const /DocType="list-of-QObject"/;
%MethodCode
        sipRes = qtcore_FindChildren(sipCpp, qtcore_check_tuple_types(a0), *a1);
        
        if (!sipRes)
            sipIsErr = 1;
%End

    void emit(SIP_SIGNAL, ...);
%MethodCode
        if (!qpycore_qobject_emit(sipCpp, a0, a1))
            sipIsErr = 1;
%End

    QString objectName() const;
    void setObjectName(const QString &name);
    bool isWidgetType() const;
%If (Qt_5_0_0 -)
    bool isWindowType() const;
%End
    bool signalsBlocked() const;
    bool blockSignals(bool b);
    QThread *thread() const;
    void moveToThread(QThread *thread);
%If (Qt_5_0_0 -)
    int startTimer(int interval, Qt::TimerType timerType = Qt::CoarseTimer);
%End
%If (- Qt_5_0_0)
    int startTimer(int interval);
%End
    void killTimer(int id);
    const QObjectList &children() const;
    void setParent(QObject * /TransferThis/);
    void installEventFilter(QObject *);
    void removeEventFilter(QObject *);
    static SIP_PYOBJECT connect(SIP_QOBJECT, SIP_SIGNAL, SIP_QOBJECT, SIP_SLOT, Qt::ConnectionType=Qt::AutoConnection) /DocType="bool"/;
%MethodCode
        sipRes = sipConnectRx(a0, a1, a2, a3, (int)a4);
%End

    static SIP_PYOBJECT connect(SIP_QOBJECT, SIP_SIGNAL, SIP_PYCALLABLE, Qt::ConnectionType=Qt::AutoConnection) /DocType="bool"/;
%MethodCode
        sipRes = sipConnectRx(a0, a1, a2, 0, (int)a3);
%End

    SIP_PYOBJECT connect(SIP_QOBJECT, SIP_SIGNAL, SIP_SLOT, Qt::ConnectionType=Qt::AutoConnection) const /DocType="bool"/;
%MethodCode
        sipRes = sipConnectRx(a0, a1, sipSelf, a2, (int)a3);
%End

    static SIP_PYOBJECT disconnect(SIP_QOBJECT, SIP_SIGNAL, SIP_QOBJECT, SIP_SLOT) /DocType="bool"/;
%MethodCode
        sipRes = sipDisconnectRx(a0, a1, a2, a3);
%End

    static SIP_PYOBJECT disconnect(SIP_QOBJECT, SIP_SIGNAL, SIP_PYCALLABLE) /DocType="bool"/;
%MethodCode
        sipRes = sipDisconnectRx(a0, a1, a2, 0);
%End

    void dumpObjectInfo();
    void dumpObjectTree();
%If (Qt_4_2_0 -)
    QList<QByteArray> dynamicPropertyNames() const;
%End
    bool setProperty(const char *name, const QVariant &value);
    QVariant property(const char *name) const;

signals:
    void destroyed(QObject *object = 0);
%If (Qt_5_0_0 -)
    void objectNameChanged(const QString &objectName);
%End

public:
    QObject *parent() const;
    bool inherits(const char *classname) const;

public slots:
    void deleteLater() /TransferThis/;

protected:
    QObject *sender() const /ReleaseGIL/;
%MethodCode
        typedef QObject *(*helper_func)(QObject *);
        
        static helper_func helper = 0;
        
        if (!helper)
            helper = (helper_func)sipImportSymbol("qpycore_qobject_sender");
        
        // sender() must be called without the GIL to avoid possible deadlocks between
        // the GIL ad Qt's internal thread data mutex.
        
        Py_BEGIN_ALLOW_THREADS
        
        #if defined(SIP_PROTECTED_IS_PUBLIC)
        sipRes = sipCpp->sender();
        #else
        sipRes = sipCpp->sipProtect_sender();
        #endif
        
        Py_END_ALLOW_THREADS
        
        if (helper)
            sipRes = helper(sipRes);
%End

    int receivers(SIP_SIGNAL signal) const;
%MethodCode
        // We need to take into account any proxies for Python signals. Import the
        // helper if it hasn't already been done.
        typedef int (*helper_func)(QObject *, const char *, int);
        
        static helper_func helper = 0;
        
        if (!helper)
            helper = (helper_func)sipImportSymbol("qpycore_qobject_receivers");
        
        // PyQt5: Get rid of the const casts.
        if (helper)
        #if defined(SIP_PROTECTED_IS_PUBLIC)
            sipRes = helper(const_cast<QObject *>(sipCpp), a0, sipCpp->receivers(a0));
        #else
            sipRes = helper(const_cast<QObject *>(static_cast<const QObject *>(sipCpp)), a0, sipCpp->sipProtect_receivers(a0));
        #endif
%End

    virtual void timerEvent(QTimerEvent *);
    virtual void childEvent(QChildEvent *);
    virtual void customEvent(QEvent *);
%If (Qt_5_0_0 -)
    virtual void connectNotify(const QMetaMethod &signal);
%End
%If (- Qt_5_0_0)
    virtual void connectNotify(SIP_SIGNAL signal);
%End
%If (Qt_5_0_0 -)
    virtual void disconnectNotify(const QMetaMethod &signal);
%End
%If (- Qt_5_0_0)
    virtual void disconnectNotify(SIP_SIGNAL signal);
%End
%If (Qt_4_8_0 -)
    int senderSignalIndex() const;
%End
%If (Qt_5_0_0 -)
    bool isSignalConnected(const QMetaMethod &signal) const;
%End

private:
    QObject(const QObject &);
};

SIP_PYOBJECT Q_CLASSINFO(const char *name, const char *value) /DocType=""/;
%MethodCode
    sipRes = qpycore_ClassInfo(a0, a1);
%End

SIP_PYOBJECT Q_ENUMS(...) /DocType=""/;
%MethodCode
    sipRes = qpycore_register_int_types(a0);
%End

SIP_PYOBJECT Q_FLAGS(...) /DocType=""/;
%MethodCode
    sipRes = qpycore_register_int_types(a0);
%End

SIP_PYOBJECT QT_TR_NOOP(SIP_PYOBJECT /DocType="str"/) /DocType="str"/;
%MethodCode
    Py_INCREF(a0);
    sipRes = a0;
%End

SIP_PYOBJECT QT_TR_NOOP_UTF8(SIP_PYOBJECT /DocType="str"/) /DocType="str"/;
%MethodCode
    Py_INCREF(a0);
    sipRes = a0;
%End

SIP_PYOBJECT QT_TRANSLATE_NOOP(SIP_PYOBJECT /DocType="str"/, SIP_PYOBJECT /DocType="str"/) /DocType="str"/;
%MethodCode
    Py_INCREF(a1);
    sipRes = a1;
%End

SIP_PYOBJECT SLOT(const char * /Encoding="ASCII"/) /DocType="str"/;
%MethodCode
    QByteArray ns = QMetaObject::normalizedSignature(a0);
    ns.prepend('1');
    
    if ((sipRes = SIPBytes_FromString(ns.constData())) == NULL)
        sipIsErr = 1;
%End

SIP_PYOBJECT SIGNAL(const char * /Encoding="ASCII"/) /DocType="str"/;
%MethodCode
    QByteArray ns = QMetaObject::normalizedSignature(a0);
    ns.prepend('2');
    
    if ((sipRes = SIPBytes_FromString(ns.constData())) == NULL)
        sipIsErr = 1;
%End

SIP_PYOBJECT pyqtSlot(const char *signature, const char *name = 0, const char *result = 0) /NoArgParser/;
%Docstring
@pyqtSlot(*types, str name=None, str result=None)

This is a decorator applied to Python methods of a QObject that marks them
as Qt slots.
The non-keyword arguments are the types of the slot arguments and each may
be a Python type object or a string specifying a C++ type.
name is the name of the slot and defaults to the name of the method.
result is type of the value returned by the slot.
%End

%MethodCode
    return qpycore_pyqtslot(sipArgs, sipKwds);
%End

SIP_PYOBJECT pyqtSignature(const char *signature, const char *result = 0) /NoArgParser/;
%Docstring
@pyqtSignature(str signature,  str result=None)

This is deprecated, use pyqtSlot() instead.

This is a decorator applied to Python methods of a QObject that marks them
as Qt slots.
signature is a string specifying the C++ signature of the slot.
result is type of the value returned by the slot.
%End

%MethodCode
    return qpycore_pyqtsignature(sipArgs, sipKwds);
%End

%ModuleHeaderCode
#include <qpycore_api.h>
%End

%ModuleCode
// These optional parts of the legacy Qt support API for SIP are implemented.
// This cannot go into qpycore_api.h as they need to be in a particular
// position in the generated code.

#undef sipQtCreateUniversalSignal
#undef sipQtFindUniversalSignal

extern "C"
{
    void *sipQtCreateUniversalSignal(void *tx, const char **sig);
    void *sipQtFindUniversalSignal(void *tx, const char **sig);
    void *sipQtCreateUniversalSlot(sipWrapper *tx, const char *sig,
            PyObject *rxObj, const char *slot, const char **member, int flags);
    void sipQtDestroyUniversalSlot(void *rx);
    void *sipQtFindSlot(void *tx, const char *sig, PyObject *rxObj,
            const char *slot, const char **member);
    int sipQtConnect(void *tx, const char *sig, void *rx, const char *slot,
            int type);
    int sipQtDisconnect(void *tx, const char *sig, void *rx, const char *slot);
    int sipQtSameSignalSlotName(const char *s1, const char *s2);
    sipSlot *sipQtFindSipslot(void *tx, void **context);
}
%End

%InitialisationCode
qpycore_init();
%End

%PostInitialisationCode
qpycore_post_init(sipModuleDict);
%End
