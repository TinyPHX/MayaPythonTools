// qmatrix4x4.sip generated by MetaSIP on Fri Mar  1 21:45:59 2013
//
// This file is part of the QtGui Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// If you are unsure which license is appropriate for your use, please
// contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%If (Qt_4_6_0 -)
%ModuleCode
#include <qmatrix4x4.h>
%End
%End

%If (Qt_4_6_0 -)

class QMatrix4x4
{
%TypeHeaderCode
#include <qmatrix4x4.h>
%End

%PickleCode
    PYQT_FLOAT data[16];
    
    // We want the data in row-major order.
    sipCpp->copyDataTo(data);
    
    sipRes = Py_BuildValue((char *)"dddddddddddddddd",
            (double)data[0], (double)data[1], (double)data[2], (double)data[3],
            (double)data[4], (double)data[5], (double)data[6], (double)data[7],
            (double)data[8], (double)data[9], (double)data[10], (double)data[11],
            (double)data[12], (double)data[13], (double)data[14], (double)data[15]);
%End

public:
    QMatrix4x4();
%If (Qt_5_0_0 -)
    explicit QMatrix4x4(SIP_PYOBJECT values /DocType="sequence-of-float"/) [(const float *values)];
%MethodCode
        float values[16];
        
        if ((sipError = qtgui_matrixDataFromSequence(a0, 16, values)) == sipErrorNone)
            sipCpp = new QMatrix4x4(values);
%End

%End
%If (- Qt_5_0_0)
    explicit QMatrix4x4(SIP_PYOBJECT values /DocType="sequence-of-float"/) [(const qreal *values)];
%MethodCode
        qreal values[16];
        
        if ((sipError = qtgui_matrixDataFromSequence(a0, 16, values)) == sipErrorNone)
            sipCpp = new QMatrix4x4(values);
%End

%End
%If (Qt_5_0_0 -)
    QMatrix4x4(float m11, float m12, float m13, float m14, float m21, float m22, float m23, float m24, float m31, float m32, float m33, float m34, float m41, float m42, float m43, float m44);
%End
%If (- Qt_5_0_0)
    QMatrix4x4(qreal m11, qreal m12, qreal m13, qreal m14, qreal m21, qreal m22, qreal m23, qreal m24, qreal m31, qreal m32, qreal m33, qreal m34, qreal m41, qreal m42, qreal m43, qreal m44);
%End
    QMatrix4x4(const QTransform &transform);
    QMatrix4x4(const QMatrix &matrix);
    SIP_PYOBJECT __repr__() const /DocType="str"/;
%MethodCode
        bool bad = false;
        int i;
        PyObject *m[16];
        PYQT_FLOAT data[16];
        
        // The raw data is in column-major order but we want row-major order.
        sipCpp->copyDataTo(data);
        
        for (i = 0; i < 16; ++i)
        {
            m[i] = PyFloat_FromDouble(data[i]);
        
            if (!m[i])
                bad = true;
        }
        
        if (!bad)
        {
        #if PY_MAJOR_VERSION >= 3
            sipRes = PyUnicode_FromFormat("PyQt4.QtGui.QMatrix4x4("
                    "%R, %R, %R, %R, "
                    "%R, %R, %R, %R, "
                    "%R, %R, %R, %R, "
                    "%R, %R, %R, %R)",
                    m[0], m[1], m[2], m[3],
                    m[4], m[5], m[6], m[7],
                    m[8], m[9], m[10], m[11],
                    m[12], m[13], m[14], m[15]);
        #else
            sipRes = PyString_FromString("PyQt4.QtGui.QMatrix4x4(");
        
            for (i = 0; i < 16; ++i)
            {
                if (i != 0)
                    PyString_ConcatAndDel(&sipRes, PyString_FromString(", "));
        
                PyString_ConcatAndDel(&sipRes, PyObject_Repr(m[i]));
            }
        
            PyString_ConcatAndDel(&sipRes, PyString_FromString(")"));
        #endif
        }
        
        for (i = 0; i < 16; ++i)
            Py_XDECREF(m[i]);
%End

%If (Qt_5_0_0 -)
    double determinant() const;
%End
%If (- Qt_5_0_0)
    qreal determinant() const;
%End
    QMatrix4x4 inverted(bool *invertible = 0) const;
    QMatrix4x4 transposed() const;
    QMatrix3x3 normalMatrix() const;
    void scale(const QVector3D &vector);
%If (Qt_5_0_0 -)
    void scale(float x, float y);
%End
%If (- Qt_5_0_0)
    void scale(qreal x, qreal y);
%End
%If (Qt_5_0_0 -)
    void scale(float x, float y, float z);
%End
%If (- Qt_5_0_0)
    void scale(qreal x, qreal y, qreal z);
%End
%If (Qt_5_0_0 -)
    void scale(float factor);
%End
%If (- Qt_5_0_0)
    void scale(qreal factor);
%End
    void translate(const QVector3D &vector);
%If (Qt_5_0_0 -)
    void translate(float x, float y);
%End
%If (- Qt_5_0_0)
    void translate(qreal x, qreal y);
%End
%If (Qt_5_0_0 -)
    void translate(float x, float y, float z);
%End
%If (- Qt_5_0_0)
    void translate(qreal x, qreal y, qreal z);
%End
%If (Qt_5_0_0 -)
    void rotate(float angle, const QVector3D &vector);
%End
%If (- Qt_5_0_0)
    void rotate(qreal angle, const QVector3D &vector);
%End
%If (Qt_5_0_0 -)
    void rotate(float angle, float x, float y, float z = 0.0f);
%End
%If (- Qt_5_0_0)
    void rotate(qreal angle, qreal x, qreal y, qreal z = 0.0);
%End
    void rotate(const QQuaternion &quaternion);
    void ortho(const QRect &rect);
    void ortho(const QRectF &rect);
%If (Qt_5_0_0 -)
    void ortho(float left, float right, float bottom, float top, float nearPlane, float farPlane);
%End
%If (- Qt_5_0_0)
    void ortho(qreal left, qreal right, qreal bottom, qreal top, qreal nearPlane, qreal farPlane);
%End
%If (Qt_5_0_0 -)
    void frustum(float left, float right, float bottom, float top, float nearPlane, float farPlane);
%End
%If (- Qt_5_0_0)
    void frustum(qreal left, qreal right, qreal bottom, qreal top, qreal nearPlane, qreal farPlane);
%End
%If (Qt_5_0_0 -)
    void perspective(float angle, float aspect, float nearPlane, float farPlane);
%End
%If (- Qt_5_0_0)
    void perspective(qreal angle, qreal aspect, qreal nearPlane, qreal farPlane);
%End
    void lookAt(const QVector3D &eye, const QVector3D &center, const QVector3D &up);
    void flipCoordinates();
%If (Qt_5_0_0 -)
    SIP_PYLIST copyDataTo() const /DocType="list-of-float"/;
%MethodCode
        float values[16];
        
        sipCpp->copyDataTo(values);
        sipError = qtgui_matrixDataAsList(16, values, &sipRes);
%End

%End
%If (- Qt_5_0_0)
    SIP_PYLIST copyDataTo() const /DocType="list-of-float"/;
%MethodCode
        qreal values[16];
        
        sipCpp->copyDataTo(values);
        sipError = qtgui_matrixDataAsList(16, values, &sipRes);
%End

%End
    QMatrix toAffine() const;
    QTransform toTransform() const;
%If (Qt_5_0_0 -)
    QTransform toTransform(float distanceToPlane) const;
%End
%If (- Qt_5_0_0)
    QTransform toTransform(qreal distanceToPlane) const;
%End
    QRect mapRect(const QRect &rect) const;
    QRectF mapRect(const QRectF &rect) const;
%If (Qt_5_0_0 -)
    SIP_PYLIST data() /DocType="list-of-float"/;
%MethodCode
        sipError = qtgui_matrixDataAsList(16, sipCpp->constData(), &sipRes);
%End

%End
%If (- Qt_5_0_0)
    SIP_PYLIST data() /DocType="list-of-float"/;
%MethodCode
        sipError = qtgui_matrixDataAsList(16, sipCpp->constData(), &sipRes);
%End

%End
    void optimize();
    SIP_PYOBJECT __getitem__(SIP_PYOBJECT) const;
%MethodCode
        int row, column;
        
        if ((sipError = qtgui_matrixParseIndex(a0, 4, 4, &row, &column)) == sipErrorNone)
        {
            sipRes = PyFloat_FromDouble(sipCpp->operator()(row, column));
        
            if (!sipRes)
                sipError = sipErrorFail;
        }
%End

    void __setitem__(SIP_PYOBJECT, qreal);
%MethodCode
        int row, column;
        
        if ((sipError = qtgui_matrixParseIndex(a0, 4, 4, &row, &column)) == sipErrorNone)
            sipCpp->operator()(row, column) = a1;
%End

    QVector4D column(int index) const;
    void setColumn(int index, const QVector4D &value);
    QVector4D row(int index) const;
    void setRow(int index, const QVector4D &value);
    bool isIdentity() const;
    void setToIdentity();
%If (Qt_5_0_0 -)
    void fill(float value);
%End
%If (- Qt_5_0_0)
    void fill(qreal value);
%End
    QMatrix4x4 &operator+=(const QMatrix4x4 &other);
    QMatrix4x4 &operator-=(const QMatrix4x4 &other);
    QMatrix4x4 &operator*=(const QMatrix4x4 &other);
%If (Qt_5_0_0 -)
    QMatrix4x4 &operator*=(float factor);
%End
%If (- Qt_5_0_0)
    QMatrix4x4 &operator*=(qreal factor);
%End
%If (Qt_5_0_0 -)
    QMatrix4x4 &operator/=(float divisor);
%End
%If (- Qt_5_0_0)
    QMatrix4x4 &operator/=(qreal divisor);
%End
    bool operator==(const QMatrix4x4 &other) const;
    bool operator!=(const QMatrix4x4 &other) const;
    QPoint map(const QPoint &point) const;
    QPointF map(const QPointF &point) const;
    QVector3D map(const QVector3D &point) const;
    QVector3D mapVector(const QVector3D &vector) const;
    QVector4D map(const QVector4D &point) const;
};

%End
%If (Qt_5_0_0 -)
QMatrix4x4 operator/(const QMatrix4x4 &matrix, float divisor);
%End
%If (Qt_4_6_0 - Qt_5_0_0)
QMatrix4x4 operator/(const QMatrix4x4 &matrix, qreal divisor);
%End
%If (Qt_4_6_0 -)
QMatrix4x4 operator+(const QMatrix4x4 &m1, const QMatrix4x4 &m2);
%End
%If (Qt_4_6_0 -)
QMatrix4x4 operator-(const QMatrix4x4 &m1, const QMatrix4x4 &m2);
%End
%If (Qt_4_6_0 -)
QMatrix4x4 operator*(const QMatrix4x4 &m1, const QMatrix4x4 &m2);
%End
%If (Qt_4_6_0 -)
QVector3D operator*(const QVector3D &vector, const QMatrix4x4 &matrix);
%End
%If (Qt_4_6_0 -)
QVector3D operator*(const QMatrix4x4 &matrix, const QVector3D &vector);
%End
%If (Qt_4_6_0 -)
QVector4D operator*(const QVector4D &vector, const QMatrix4x4 &matrix);
%End
%If (Qt_4_6_0 -)
QVector4D operator*(const QMatrix4x4 &matrix, const QVector4D &vector);
%End
%If (Qt_4_6_0 -)
QPoint operator*(const QPoint &point, const QMatrix4x4 &matrix);
%End
%If (Qt_4_6_0 -)
QPointF operator*(const QPointF &point, const QMatrix4x4 &matrix);
%End
%If (Qt_4_6_0 -)
QPoint operator*(const QMatrix4x4 &matrix, const QPoint &point);
%End
%If (Qt_4_6_0 -)
QPointF operator*(const QMatrix4x4 &matrix, const QPointF &point);
%End
%If (Qt_4_6_0 -)
QMatrix4x4 operator-(const QMatrix4x4 &matrix);
%End
%If (Qt_5_0_0 -)
QMatrix4x4 operator*(float factor, const QMatrix4x4 &matrix);
%End
%If (Qt_4_6_0 - Qt_5_0_0)
QMatrix4x4 operator*(qreal factor, const QMatrix4x4 &matrix);
%End
%If (Qt_5_0_0 -)
QMatrix4x4 operator*(const QMatrix4x4 &matrix, float factor);
%End
%If (Qt_4_6_0 - Qt_5_0_0)
QMatrix4x4 operator*(const QMatrix4x4 &matrix, qreal factor);
%End
%If (Qt_4_6_0 -)
bool qFuzzyCompare(const QMatrix4x4 &m1, const QMatrix4x4 &m2);
%End
%If (Qt_4_6_0 -)
QDataStream &operator<<(QDataStream &, const QMatrix4x4 & /Constrained/);
%End
%If (Qt_4_6_0 -)
QDataStream &operator>>(QDataStream &, QMatrix4x4 & /Constrained/);
%End

%ModuleHeaderCode
// Helpers for the matrix classes.
#if QT_VERSION >= 0x050000
typedef float PYQT_FLOAT;
#else
typedef qreal PYQT_FLOAT;
#endif

sipErrorState qtgui_matrixParseIndex(PyObject *tup, int nr_rows,
        int nr_columns, int *row, int *column);
sipErrorState qtgui_matrixDataFromSequence(PyObject *seq, int nr_values,
        PYQT_FLOAT *values);
sipErrorState qtgui_matrixDataAsList(int nr_values, const PYQT_FLOAT *values,
        PyObject **list);
%End

%ModuleCode
// Convert a Python object to a row and column.
sipErrorState qtgui_matrixParseIndex(PyObject *tup, int nr_rows,
        int nr_columns, int *row, int *column)
{
    sipErrorState es = sipErrorContinue;

#if PY_VERSION_HEX >= 0x02050000
    if (PyTuple_Check(tup) && PyArg_ParseTuple(tup, "ii", row, column))
#else
    if (PyTuple_Check(tup) && PyArg_ParseTuple(tup, const_cast<char *>("ii"), row, column))
#endif
        if (*row >= 0 && *row < nr_rows && *column >= 0 && *column < nr_columns)
            es = sipErrorNone;

    if (es == sipErrorContinue)
        PyErr_Format(PyExc_IndexError, "an index must be a row in the range 0 to %d and a column in the range 0 to %d", nr_rows - 1, nr_columns - 1);

    return es;
}


// Convert a Python object to an array of qreals.
sipErrorState qtgui_matrixDataFromSequence(PyObject *seq, int nr_values,
        PYQT_FLOAT *values)
{
    sipErrorState es;

    if (PySequence_Size(seq) == nr_values)
    {
        es = sipErrorNone;

        for (int i = 0; i < nr_values; ++i)
        {
            PyObject *value = PySequence_GetItem(seq, i);

            if (!value)
            {
                es = sipErrorFail;
                break;
            }

            PyErr_Clear();

            double d = PyFloat_AsDouble(value);

            if (PyErr_Occurred())
            {
                Py_DECREF(value);
                es = sipErrorContinue;
                break;
            }

            Py_DECREF(value);

            *values++ = d;
        }
    }
    else
    {
        es = sipErrorContinue;
    }

    if (es == sipErrorContinue)
        PyErr_Format(PyExc_TypeError, "a sequence of %d floats is expected",
                nr_values);

    return es;
}


// Convert an array of qreals to a Python list.
sipErrorState qtgui_matrixDataAsList(int nr_values, const PYQT_FLOAT *values,
        PyObject **list)
{
    PyObject *l = PyList_New(nr_values);

    if (!l)
        return sipErrorFail;

    for (int i = 0; i < nr_values; ++i)
    {
        PyObject *value = PyFloat_FromDouble(*values++);

        if (!value)
        {
            Py_DECREF(l);
            return sipErrorFail;
        }

        PyList_SET_ITEM(l, i, value);
    }

    *list = l;

    return sipErrorNone;
}
%End
