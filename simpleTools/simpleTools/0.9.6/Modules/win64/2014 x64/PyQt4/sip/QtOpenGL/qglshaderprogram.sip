// qglshaderprogram.sip generated by MetaSIP on Fri Mar  1 21:46:01 2013
//
// This file is part of the QtOpenGL Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// If you are unsure which license is appropriate for your use, please
// contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%If (Qt_4_6_0 -)
%ModuleCode
#include <qglshaderprogram.h>
%End
%End

%If (Qt_4_6_0 -)

class QGLShader : QObject
{
%TypeHeaderCode
#include <qglshaderprogram.h>
%End

public:
    enum ShaderTypeBit
    {
        Vertex,
        Fragment,
%If (Qt_4_7_0 -)
        Geometry,
%End
    };

    typedef QFlags<QGLShader::ShaderTypeBit> ShaderType;
    QGLShader(QFlags<QGLShader::ShaderTypeBit> type, QObject *parent /TransferThis/ = 0);
    QGLShader(QFlags<QGLShader::ShaderTypeBit> type, const QGLContext *context, QObject *parent /TransferThis/ = 0);
    virtual ~QGLShader();
    QFlags<QGLShader::ShaderTypeBit> shaderType() const;
    bool compileSourceCode(const QByteArray &source);
    bool compileSourceCode(const QString &source);
    bool compileSourceFile(const QString &fileName);
    QByteArray sourceCode() const;
    bool isCompiled() const;
    QString log() const;
    GLuint shaderId() const;
%If (Qt_4_7_0 -)
    static bool hasOpenGLShaders(QFlags<QGLShader::ShaderTypeBit> type, const QGLContext *context = 0);
%End

private:
    QGLShader(const QGLShader &);
};

%End
%If (Qt_4_6_0 -)
QFlags<QGLShader::ShaderTypeBit> operator|(QGLShader::ShaderTypeBit f1, QFlags<QGLShader::ShaderTypeBit> f2);
%End
%If (Qt_4_6_0 -)

class QGLShaderProgram : QObject
{
%TypeHeaderCode
#include <qglshaderprogram.h>
%End

public:
    explicit QGLShaderProgram(QObject *parent /TransferThis/ = 0);
    QGLShaderProgram(const QGLContext *context, QObject *parent /TransferThis/ = 0);
    virtual ~QGLShaderProgram();
    bool addShader(QGLShader *shader);
    void removeShader(QGLShader *shader);
    QList<QGLShader*> shaders() const;
    bool addShaderFromSourceCode(QFlags<QGLShader::ShaderTypeBit> type, const QByteArray &source);
    bool addShaderFromSourceCode(QFlags<QGLShader::ShaderTypeBit> type, const QString &source);
    bool addShaderFromSourceFile(QFlags<QGLShader::ShaderTypeBit> type, const QString &fileName);
    void removeAllShaders();
    virtual bool link();
    bool isLinked() const;
    QString log() const;
    bool bind();
    void release();
    GLuint programId() const;
    void bindAttributeLocation(const QByteArray &name, int location);
    void bindAttributeLocation(const QString &name, int location);
    int attributeLocation(const QByteArray &name) const;
    int attributeLocation(const QString &name) const;
    void setAttributeArray(int location, SIP_PYOBJECT values /DocType="sequence"/);
%MethodCode
        const GLfloat *values;
        int tsize;
        
        values = qpyopengl_attribute_array(a1, sipSelf, SIPLong_FromLong(a0), &tsize,
                &sipError);
        
        if (values)
            sipCpp->setAttributeArray(a0, values, tsize);
%End

    void setAttributeArray(const char *name, SIP_PYOBJECT values /DocType="sequence"/);
%MethodCode
        const GLfloat *values;
        int tsize;
        
        values = qpyopengl_attribute_array(a1, sipSelf, SIPBytes_FromString(a0),
                &tsize, &sipError);
        
        if (values)
            sipCpp->setAttributeArray(a0, values, tsize);
%End

    void setAttributeValue(int location, GLfloat value);
    void setAttributeValue(int location, GLfloat x, GLfloat y);
    void setAttributeValue(int location, GLfloat x, GLfloat y, GLfloat z);
    void setAttributeValue(int location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
    void setAttributeValue(int location, const QVector2D &value);
    void setAttributeValue(int location, const QVector3D &value);
    void setAttributeValue(int location, const QVector4D &value);
    void setAttributeValue(int location, const QColor &value);
    void setAttributeValue(const char *name, GLfloat value);
    void setAttributeValue(const char *name, GLfloat x, GLfloat y);
    void setAttributeValue(const char *name, GLfloat x, GLfloat y, GLfloat z);
    void setAttributeValue(const char *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
    void setAttributeValue(const char *name, const QVector2D &value);
    void setAttributeValue(const char *name, const QVector3D &value);
    void setAttributeValue(const char *name, const QVector4D &value);
    void setAttributeValue(const char *name, const QColor &value);
    void enableAttributeArray(int location);
    void enableAttributeArray(const char *name);
    void disableAttributeArray(int location);
    void disableAttributeArray(const char *name);
    int uniformLocation(const QByteArray &name) const;
    int uniformLocation(const QString &name) const;
    void setUniformValueArray(int location, SIP_PYOBJECT values /DocType="sequence"/);
%MethodCode
        const void *values;
        const sipTypeDef *array_type;
        int array_len, tsize;
        
        values = qpyopengl_uniform_value_array(a1, sipSelf, SIPLong_FromLong(a0),
                    &array_type, &array_len, &tsize, &sipError);
                
        if (values)
        {
            if (array_type == sipType_QVector2D)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QVector2D *>(values), array_len);
            else if (array_type == sipType_QVector3D)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QVector3D *>(values), array_len);
            else if (array_type == sipType_QVector4D)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QVector4D *>(values), array_len);
            else if (array_type == sipType_QMatrix2x2)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QMatrix2x2 *>(values), array_len);
            else if (array_type == sipType_QMatrix2x3)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QMatrix2x3 *>(values), array_len);
            else if (array_type == sipType_QMatrix2x4)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QMatrix2x4 *>(values), array_len);
            else if (array_type == sipType_QMatrix3x2)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QMatrix3x2 *>(values), array_len);
            else if (array_type == sipType_QMatrix3x3)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QMatrix3x3 *>(values), array_len);
            else if (array_type == sipType_QMatrix3x4)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QMatrix3x4 *>(values), array_len);
            else if (array_type == sipType_QMatrix4x2)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QMatrix4x2 *>(values), array_len);
            else if (array_type == sipType_QMatrix4x3)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QMatrix4x3 *>(values), array_len);
            else if (array_type == sipType_QMatrix4x4)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QMatrix4x4 *>(values), array_len);
            else
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const GLfloat *>(values), array_len, tsize);
        }
%End

    void setUniformValueArray(const char *name, SIP_PYOBJECT values /DocType="sequence"/);
%MethodCode
        const void *values;
        const sipTypeDef *array_type;
        int array_len, tsize;
        
        values = qpyopengl_uniform_value_array(a1, sipSelf, SIPBytes_FromString(a0),
                    &array_type, &array_len, &tsize, &sipError);
                
        if (values)
        {
            if (array_type == sipType_QVector2D)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QVector2D *>(values), array_len);
            else if (array_type == sipType_QVector3D)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QVector3D *>(values), array_len);
            else if (array_type == sipType_QVector4D)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QVector4D *>(values), array_len);
            else if (array_type == sipType_QMatrix2x2)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QMatrix2x2 *>(values), array_len);
            else if (array_type == sipType_QMatrix2x3)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QMatrix2x3 *>(values), array_len);
            else if (array_type == sipType_QMatrix2x4)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QMatrix2x4 *>(values), array_len);
            else if (array_type == sipType_QMatrix3x2)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QMatrix3x2 *>(values), array_len);
            else if (array_type == sipType_QMatrix3x3)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QMatrix3x3 *>(values), array_len);
            else if (array_type == sipType_QMatrix3x4)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QMatrix3x4 *>(values), array_len);
            else if (array_type == sipType_QMatrix4x2)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QMatrix4x2 *>(values), array_len);
            else if (array_type == sipType_QMatrix4x3)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QMatrix4x3 *>(values), array_len);
            else if (array_type == sipType_QMatrix4x4)
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const QMatrix4x4 *>(values), array_len);
            else
                sipCpp->setUniformValueArray(a0,
                        reinterpret_cast<const GLfloat *>(values), array_len, tsize);
        }
%End

    void setUniformValue(int location, GLint value /Constrained/);
    void setUniformValue(int location, GLfloat value /Constrained/);
    void setUniformValue(int location, GLfloat x, GLfloat y);
    void setUniformValue(int location, GLfloat x, GLfloat y, GLfloat z);
    void setUniformValue(int location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
    void setUniformValue(int location, const QVector2D &value);
    void setUniformValue(int location, const QVector3D &value);
    void setUniformValue(int location, const QVector4D &value);
    void setUniformValue(int location, const QColor &color);
    void setUniformValue(int location, const QPoint &point);
    void setUniformValue(int location, const QPointF &point);
    void setUniformValue(int location, const QSize &size);
    void setUniformValue(int location, const QSizeF &size);
    void setUniformValue(int location, const QMatrix2x2 &value);
    void setUniformValue(int location, const QMatrix2x3 &value);
    void setUniformValue(int location, const QMatrix2x4 &value);
    void setUniformValue(int location, const QMatrix3x2 &value);
    void setUniformValue(int location, const QMatrix3x3 &value);
    void setUniformValue(int location, const QMatrix3x4 &value);
    void setUniformValue(int location, const QMatrix4x2 &value);
    void setUniformValue(int location, const QMatrix4x3 &value);
    void setUniformValue(int location, const QMatrix4x4 &value);
    void setUniformValue(int location, const QTransform &value);
    void setUniformValue(const char *name, GLint value /Constrained/);
    void setUniformValue(const char *name, GLfloat value /Constrained/);
    void setUniformValue(const char *name, GLfloat x, GLfloat y);
    void setUniformValue(const char *name, GLfloat x, GLfloat y, GLfloat z);
    void setUniformValue(const char *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
    void setUniformValue(const char *name, const QVector2D &value);
    void setUniformValue(const char *name, const QVector3D &value);
    void setUniformValue(const char *name, const QVector4D &value);
    void setUniformValue(const char *name, const QColor &color);
    void setUniformValue(const char *name, const QPoint &point);
    void setUniformValue(const char *name, const QPointF &point);
    void setUniformValue(const char *name, const QSize &size);
    void setUniformValue(const char *name, const QSizeF &size);
    void setUniformValue(const char *name, const QMatrix2x2 &value);
    void setUniformValue(const char *name, const QMatrix2x3 &value);
    void setUniformValue(const char *name, const QMatrix2x4 &value);
    void setUniformValue(const char *name, const QMatrix3x2 &value);
    void setUniformValue(const char *name, const QMatrix3x3 &value);
    void setUniformValue(const char *name, const QMatrix3x4 &value);
    void setUniformValue(const char *name, const QMatrix4x2 &value);
    void setUniformValue(const char *name, const QMatrix4x3 &value);
    void setUniformValue(const char *name, const QMatrix4x4 &value);
    void setUniformValue(const char *name, const QTransform &value);
    static bool hasOpenGLShaderPrograms(const QGLContext *context = 0);
%If (Qt_4_7_0 -)
    void setGeometryOutputVertexCount(int count);
%End
%If (Qt_4_7_0 -)
    int geometryOutputVertexCount() const;
%End
%If (Qt_4_7_0 -)
    void setGeometryInputType(GLenum inputType);
%End
%If (Qt_4_7_0 -)
    GLenum geometryInputType() const;
%End
%If (Qt_4_7_0 -)
    void setGeometryOutputType(GLenum outputType);
%End
%If (Qt_4_7_0 -)
    GLenum geometryOutputType() const;
%End
%If (Qt_4_7_0 -)
    void setAttributeBuffer(int location, GLenum type, int offset, int tupleSize, int stride = 0);
%End
%If (Qt_4_7_0 -)
    void setAttributeBuffer(const char *name, GLenum type, int offset, int tupleSize, int stride = 0);
%End

private:
    QGLShaderProgram(const QGLShaderProgram &);
};

%End
