// qpair.sip generated by MetaSIP on Fri Mar  1 21:45:57 2013
//
// This file is part of the QtCore Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// If you are unsure which license is appropriate for your use, please
// contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


// QPair<int, int> is implemented as a Python 2-element tuple.
%MappedType QPair<int, int> /DocType="tuple-of-int-int"/
{
%TypeHeaderCode
#include <qpair.h>
%End

%ConvertFromTypeCode
    // Create the tuple.
    return Py_BuildValue((char *)"ii", sipCpp->first, sipCpp->second);
%End

%ConvertToTypeCode
    // Check the type if that is all that is required.
    if (sipIsErr == NULL)
        return (PyTuple_Size(sipPy) == 2);

    QPair<int, int> *qp = new QPair<int, int>;
 
    qp->first = SIPLong_AsLong(PyTuple_GET_ITEM(sipPy, 0));
    qp->second = SIPLong_AsLong(PyTuple_GET_ITEM(sipPy, 1));

    *sipCppPtr = qp;
 
    return sipGetState(sipTransferObj);
%End
};
// QPair<unsigned, unsigned> is implemented as a Python 2-element tuple.
%MappedType QPair<unsigned, unsigned> /DocType="tuple-of-int-int"/
{
%TypeHeaderCode
#include <qpair.h>
%End

%ConvertFromTypeCode
    // Create the tuple.
    return Py_BuildValue((char *)"II", sipCpp->first, sipCpp->second);
%End

%ConvertToTypeCode
    // Check the type if that is all that is required.
    if (sipIsErr == NULL)
        return (PyTuple_Size(sipPy) == 2);

    QPair<unsigned, unsigned> *qp = new QPair<unsigned, unsigned>;
 
    qp->first = PyLong_AsUnsignedLong(PyTuple_GET_ITEM(sipPy, 0));
    qp->second = PyLong_AsUnsignedLong(PyTuple_GET_ITEM(sipPy, 1));

    *sipCppPtr = qp;
 
    return sipGetState(sipTransferObj);
%End
};
%If (Qt_4_5_0 -)
// QPair<TYPE, int> is implemented as a Python 2-element tuple.
template<TYPE>
%MappedType QPair<TYPE, int> /DocType="tuple-of-TYPE-int"/
{
%TypeHeaderCode
#include <qpair.h>
%End

%ConvertFromTypeCode
    // Create the tuple.
    PyObject *tup = PyTuple_New(2);

    if (!tup)
        return 0;

    PyObject *obj;

    // Convert the first part.
    TYPE *t = new TYPE(sipCpp->first);

    obj = sipConvertFromNewType(t, sipType_TYPE, sipTransferObj);

    if (!obj)
    {
        delete t;

        Py_DECREF(tup);
        return 0;
    }

    PyTuple_SET_ITEM(tup, 0, obj);

    // Convert the second part.
    obj = SIPLong_FromLong(sipCpp->second);

    if (!obj)
    {
        Py_DECREF(tup);
        return 0;
    }

    PyTuple_SET_ITEM(tup, 1, obj);

    return tup;
%End

%ConvertToTypeCode
    // Check the type if that is all that is required.
    if (sipIsErr == NULL)
        return (PyTuple_Size(sipPy) == 2 && sipCanConvertToType(PyTuple_GET_ITEM(sipPy, 0), sipType_TYPE, SIP_NOT_NONE));

    QPair<TYPE, int> *qp = new QPair<TYPE, int>;

    int state;
    TYPE *t = reinterpret_cast<TYPE *>(sipConvertToType(PyTuple_GET_ITEM(sipPy, 0), sipType_TYPE, sipTransferObj, SIP_NOT_NONE, &state, sipIsErr));

    if (*sipIsErr)
    {
        sipReleaseType(t, sipType_TYPE, state);

        delete qp;
        return 0;
    }

    qp->first = *t;
    sipReleaseType(t, sipType_TYPE, state);

    qp->second = SIPLong_AsLong(PyTuple_GET_ITEM(sipPy, 1));

    *sipCppPtr = qp;

    return sipGetState(sipTransferObj);
%End
};
%End
